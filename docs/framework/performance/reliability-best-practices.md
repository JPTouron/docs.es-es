---
title: Procedimientos recomendados para la confiabilidad
description: Consulte prácticas recomendadas para la confiabilidad en aplicaciones de servidor basadas en host .NET, como SQL Server. Evitar que se pierdan recursos o se desconecten.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474246"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="d4962-104">Procedimientos recomendados para la confiabilidad</span><span class="sxs-lookup"><span data-stu-id="d4962-104">Reliability Best Practices</span></span>

<span data-ttu-id="d4962-105">Las siguientes reglas de confiabilidad están orientadas a SQL Server, pero también se aplican a cualquier aplicación de servidor basada en host.</span><span class="sxs-lookup"><span data-stu-id="d4962-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="d4962-106">Es extremadamente importante que los servidores como SQL Server no pierdan recursos ni se interrumpan.</span><span class="sxs-lookup"><span data-stu-id="d4962-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="d4962-107">Pero eso no se puede realizar mediante la escritura de código devuelto para todos los métodos que modifican el estado de un objeto.</span><span class="sxs-lookup"><span data-stu-id="d4962-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="d4962-108">El objetivo no es escribir código administrado confiable al 100 por cien que se recupere de los errores en todas las ubicaciones con código devuelto.</span><span class="sxs-lookup"><span data-stu-id="d4962-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="d4962-109">Eso sería una tarea desalentadora con escasa probabilidad de éxito.</span><span class="sxs-lookup"><span data-stu-id="d4962-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="d4962-110">El Common Language Runtime (CLR) no puede proporcionar fácilmente garantías lo bastante seguras para el código administrado para que la escritura de código perfecto sea viable.</span><span class="sxs-lookup"><span data-stu-id="d4962-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="d4962-111">Tenga en cuenta que, a diferencia de ASP.NET, SQL Server solo usa un proceso que no se puede reciclar sin cerrar una base de datos durante un período inaceptablemente prolongado.</span><span class="sxs-lookup"><span data-stu-id="d4962-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="d4962-112">Con estas garantías más débiles y al ejecutarse en un único proceso, la confiabilidad se basa en terminar subprocesos o reciclar dominios de aplicación cuando es necesario, y en tomar precauciones para asegurarse de que no se pierden recursos del sistema operativo como identificadores o memoria.</span><span class="sxs-lookup"><span data-stu-id="d4962-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="d4962-113">Incluso con esta restricción de confiabilidad más simple, sigue habiendo un requisito de confiabilidad significativo:</span><span class="sxs-lookup"><span data-stu-id="d4962-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="d4962-114">No perder nunca recursos del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="d4962-115">Identificar todos los tipos de bloqueos administrados para el CLR.</span><span class="sxs-lookup"><span data-stu-id="d4962-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="d4962-116">No interrumpir nunca el estado compartido entre dominios de aplicación, lo que permite que el reciclaje de <xref:System.AppDomain> funcione sin problemas.</span><span class="sxs-lookup"><span data-stu-id="d4962-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="d4962-117">Aunque teóricamente sea posible escribir código administrado para controlar excepciones <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> y <xref:System.OutOfMemoryException>, no es razonable esperar que los desarrolladores escriban este tipo de código sólido a lo largo de toda una aplicación.</span><span class="sxs-lookup"><span data-stu-id="d4962-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="d4962-118">Por ese motivo, las excepciones fuera de banda hacen que se finalice el subproceso en ejecución; y si el subproceso finalizado estaba editando el estado compartido, lo que se puede determinar si el subproceso mantiene un bloqueo, entonces se descarga el <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="d4962-119">Cuando se finaliza un método que está editando el estado compartido, el estado quedará dañado porque no es posible escribir código devuelto confiable para las actualizaciones del estado compartido.</span><span class="sxs-lookup"><span data-stu-id="d4962-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="d4962-120">En la versión 2.0 de .NET Framework, el único host que requiere confiabilidad es SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4962-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="d4962-121">Si el ensamblado se va a ejecutar en SQL Server, debe realizar el trabajo de confiabilidad para todos los elementos de ese ensamblado, incluso si hay características específicas que están deshabilitadas cuando se ejecutan en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="d4962-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="d4962-122">Esto es obligatorio porque el motor de análisis de código examina el código en el nivel de ensamblado y no puede diferenciar el código deshabilitado.</span><span class="sxs-lookup"><span data-stu-id="d4962-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="d4962-123">Otra consideración a la hora de programar es que SQL Server ejecuta todo el contenido en un proceso y el reciclaje de <xref:System.AppDomain> se usa para limpiar todos los recursos, como los identificadores de memoria y del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="d4962-124">No puede depender de los finalizadores, destructores ni de bloques `try/finally` para el código devuelto.</span><span class="sxs-lookup"><span data-stu-id="d4962-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="d4962-125">Es posible que se interrumpan o que no se llamen.</span><span class="sxs-lookup"><span data-stu-id="d4962-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="d4962-126">Se pueden iniciar excepciones asincrónicas en ubicaciones inesperadas, posiblemente en cada instrucción del equipo: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> y <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="d4962-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="d4962-127">Los subprocesos administrados no son necesariamente subprocesos Win32 en SQL; pueden ser fibras.</span><span class="sxs-lookup"><span data-stu-id="d4962-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="d4962-128">El estado compartido mutable de todo el proceso o del dominio de varias aplicaciones es muy difícil de modificar de forma segura y debe evitarse siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="d4962-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="d4962-129">Las condiciones de memoria insuficiente son frecuentes en SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4962-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="d4962-130">Si las bibliotecas hospedadas en SQL Server no actualizan correctamente su estado compartido, hay una probabilidad alta de que el código no se recupere hasta que se haya reiniciado la base de datos.</span><span class="sxs-lookup"><span data-stu-id="d4962-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="d4962-131">Además, en algunos casos extremos, es posible que esto pueda provocar un error en el proceso de SQL Server, haciendo que la base de datos se reinicie.</span><span class="sxs-lookup"><span data-stu-id="d4962-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="d4962-132">Reiniciar la base de datos puede dejar fuera de servicio a un sitio web o afectar a las operaciones de la empresa, lo que afecta negativamente a la disponibilidad.</span><span class="sxs-lookup"><span data-stu-id="d4962-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="d4962-133">Una pérdida lenta de recursos del sistema operativo, como la memoria o los identificadores, puede hacer que se acabe produciendo un error en la asignación de identificadores por parte del servidor sin posibilidad de recuperación, o posiblemente que se degrade el rendimiento del servidor de forma lenta y se reduzca la disponibilidad de las aplicaciones de un cliente.</span><span class="sxs-lookup"><span data-stu-id="d4962-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="d4962-134">Es evidente que estos escenarios se deben evitar.</span><span class="sxs-lookup"><span data-stu-id="d4962-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="d4962-135">Reglas de procedimientos recomendados</span><span class="sxs-lookup"><span data-stu-id="d4962-135">Best practice rules</span></span>

<span data-ttu-id="d4962-136">En la introducción nos centramos en qué tendría que detectar la revisión del código administrado que se ejecuta en el servidor para aumentar la estabilidad y confiabilidad de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="d4962-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="d4962-137">Todas estas comprobaciones son recomendables en general y absolutamente necesarias en el servidor.</span><span class="sxs-lookup"><span data-stu-id="d4962-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="d4962-138">En el caso de un interbloqueo o de una restricción de recursos, SQL Server anulará un subproceso o un <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="d4962-139">Cuando esto sucede, solo se garantiza la ejecución de código devuelto en una región de ejecución restringida (CER).</span><span class="sxs-lookup"><span data-stu-id="d4962-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="d4962-140">Usar SafeHandle para evitar pérdidas de recursos</span><span class="sxs-lookup"><span data-stu-id="d4962-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="d4962-141">En el caso de una descarga de <xref:System.AppDomain>, no se puede depender de la ejecución de bloques `finally` o finalizadores, por lo que es importante abstraer el acceso a todos los recursos del sistema operativo a través de la clase <xref:System.Runtime.InteropServices.SafeHandle> en lugar de <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef> o clases similares.</span><span class="sxs-lookup"><span data-stu-id="d4962-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="d4962-142">Esto permite que el CLR realice el seguimiento y cierre los identificadores usados incluso en el caso de anulación de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="d4962-143"><xref:System.Runtime.InteropServices.SafeHandle> usará un finalizador crítico que el CLR ejecutará siempre.</span><span class="sxs-lookup"><span data-stu-id="d4962-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="d4962-144">El identificador del sistema operativo se almacena en el controlador seguro desde el momento en que se crea hasta el momento en que se libera.</span><span class="sxs-lookup"><span data-stu-id="d4962-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="d4962-145">No hay ninguna período de tiempo durante el que una excepción <xref:System.Threading.ThreadAbortException> pueda provocar la pérdida de un identificador.</span><span class="sxs-lookup"><span data-stu-id="d4962-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="d4962-146">Además, la invocación de plataforma realizará el recuento de referencias del identificador, lo que permite un seguimiento estricto de la duración del identificador, evitando un problema de seguridad con una condición de carrera entre `Dispose` y un método que actualmente use el identificador.</span><span class="sxs-lookup"><span data-stu-id="d4962-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="d4962-147">La mayoría de las clases que actualmente tienen un finalizador simplemente para limpiar un identificador del sistema operativo ya no lo necesitarán.</span><span class="sxs-lookup"><span data-stu-id="d4962-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="d4962-148">En su lugar, el finalizador estará en la clase derivada <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="d4962-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="d4962-149">Tenga en cuenta que <xref:System.Runtime.InteropServices.SafeHandle> no es un sustituto de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d4962-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="d4962-150">Todavía hay posibles ventajas de contención de recursos y rendimiento a la eliminación explícita de recursos del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="d4962-151">Simplemente tenga en cuenta que es posible que los bloques `finally` que eliminan explícitamente de los recursos no se ejecuten hasta su finalización.</span><span class="sxs-lookup"><span data-stu-id="d4962-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="d4962-152"><xref:System.Runtime.InteropServices.SafeHandle> permite implementar su propio método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> que realiza el trabajo necesario para liberar el identificador, como pasar el estado a una rutina de liberación de identificadores del sistema operativo o liberar un conjunto de identificadores en un bucle.</span><span class="sxs-lookup"><span data-stu-id="d4962-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="d4962-153">El CLR garantiza que este método se ejecute.</span><span class="sxs-lookup"><span data-stu-id="d4962-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="d4962-154">Es responsabilidad del autor de la implementación de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> asegurarse de que el identificador se libera en todas las circunstancias.</span><span class="sxs-lookup"><span data-stu-id="d4962-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="d4962-155">Si no lo hace, se producirá la pérdida del identificador, lo que a menudo produce la pérdida de recursos nativos asociados al identificador.</span><span class="sxs-lookup"><span data-stu-id="d4962-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="d4962-156">Por tanto, es fundamental estructurar las clases derivadas de <xref:System.Runtime.InteropServices.SafeHandle> para que la implementación de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> no requiera la asignación de ningún recurso que pueda no estar disponible en el momento de la invocación.</span><span class="sxs-lookup"><span data-stu-id="d4962-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="d4962-157">Tenga en cuenta que se permite llamar a métodos que pueden producir un error en la implementación de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> siempre que el código pueda controlar esos errores y finalizar el contrato para liberar el identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="d4962-158">Para la depuración, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> tiene un valor devuelto de <xref:System.Boolean>, que se puede establecer en `false` si se produce un error catastrófico que impida la liberación del recurso.</span><span class="sxs-lookup"><span data-stu-id="d4962-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="d4962-159">Si se hace esto, se activará el MDA [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md), si está habilitado, para ayudar a identificar el problema.</span><span class="sxs-lookup"><span data-stu-id="d4962-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="d4962-160">No afecta el tiempo de ejecución de ninguna otra forma; no se volverá a llamar a <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> para el mismo recurso y, por tanto, el identificador se perderá.</span><span class="sxs-lookup"><span data-stu-id="d4962-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="d4962-161"><xref:System.Runtime.InteropServices.SafeHandle> no es adecuado en ciertos contextos.</span><span class="sxs-lookup"><span data-stu-id="d4962-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="d4962-162">Como el método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> se puede ejecutar en un subproceso de finalizador de <xref:System.GC>, los identificadores que deban liberarse en un subproceso concreto no deben estar contenidos en <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="d4962-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="d4962-163">El CLR puede limpiar los contenedores RCW sin ningún código adicional.</span><span class="sxs-lookup"><span data-stu-id="d4962-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="d4962-164">Para el código que usa invocación de plataforma y trata un objeto COM como un `IUnknown*` o <xref:System.IntPtr>, el código debe reescribirse para usar un contenedor RCW.</span><span class="sxs-lookup"><span data-stu-id="d4962-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="d4962-165">Es posible que <xref:System.Runtime.InteropServices.SafeHandle> no sea adecuado para este escenario debido a la posibilidad de que un método de liberación no administrado se vuelva a llamar en código administrado.</span><span class="sxs-lookup"><span data-stu-id="d4962-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-166">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-166">Code analysis rule</span></span>

<span data-ttu-id="d4962-167">Use <xref:System.Runtime.InteropServices.SafeHandle> para encapsular los recursos del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="d4962-168">No use <xref:System.Runtime.InteropServices.HandleRef> o campos de tipo <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="d4962-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="d4962-169">Asegurarse de que los finalizadores no tienen que ejecutarse para evitar la pérdida de recursos del sistema operativo</span><span class="sxs-lookup"><span data-stu-id="d4962-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="d4962-170">Revise cuidadosamente los finalizadores para asegurarse de que, incluso si no se ejecutan, no se produzca una pérdida de recursos críticos del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="d4962-171">A diferencia de una descarga normal de <xref:System.AppDomain> cuando se está ejecutando la aplicación en un estado estable o cuando un servidor (como por ejemplo SQL Server) se apaga, los objetos no se finalizan durante un descarga inesperada de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="d4962-172">Asegúrese de que no se pierden recursos en caso de una descarga inesperada, ya que no se puede garantizar la exactitud de la aplicación, pero se debe mantener la integridad del servidor sin que haya pérdida de recursos.</span><span class="sxs-lookup"><span data-stu-id="d4962-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="d4962-173">Use <xref:System.Runtime.InteropServices.SafeHandle> para liberar los recursos del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="d4962-174">Asegúrese de que no es necesario que las cláusulas finally se ejecuten para evitar la pérdida de recursos del sistema operativo</span><span class="sxs-lookup"><span data-stu-id="d4962-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="d4962-175">No se garantiza que las cláusulas `finally` se ejecuten fuera de las CER, lo que obliga a los desarrolladores de bibliotecas a no confiar en el código de un bloque `finally` para liberar recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="d4962-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="d4962-176">La solución recomendada es usar <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="d4962-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-177">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-177">Code analysis rule</span></span>

<span data-ttu-id="d4962-178">Use <xref:System.Runtime.InteropServices.SafeHandle> para limpiar los recursos del sistema operativo en lugar de `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="d4962-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="d4962-179">No use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> para encapsular los recursos.</span><span class="sxs-lookup"><span data-stu-id="d4962-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="d4962-180">Si se tiene que ejecutar la cláusula finally, colóquela en una CER.</span><span class="sxs-lookup"><span data-stu-id="d4962-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="d4962-181">Todos los bloqueos deben pasar por el código de bloqueo administrado existente</span><span class="sxs-lookup"><span data-stu-id="d4962-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="d4962-182">El CLR debe saber cuándo el código está en un bloqueo para saber que debe anular el <xref:System.AppDomain> en lugar de limitarse a anular el subproceso.</span><span class="sxs-lookup"><span data-stu-id="d4962-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="d4962-183">Anular el subproceso podría ser peligroso dado que los datos en los que opera el subproceso podrían quedar en un estado incoherente.</span><span class="sxs-lookup"><span data-stu-id="d4962-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="d4962-184">Por tanto, tendría que reciclarse <xref:System.AppDomain> por completo.</span><span class="sxs-lookup"><span data-stu-id="d4962-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="d4962-185">Las consecuencias de no poder identificar un bloqueo pueden ser interbloqueos o resultados incorrectos.</span><span class="sxs-lookup"><span data-stu-id="d4962-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="d4962-186">Use los métodos <xref:System.Threading.Thread.BeginCriticalRegion%2A> y <xref:System.Threading.Thread.EndCriticalRegion%2A> para identificar regiones de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d4962-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="d4962-187">Son métodos estáticos de la clase <xref:System.Threading.Thread> que solo se aplican al subproceso actual, lo que ayuda a impedir que un subproceso edite el recuento de bloqueos de otro.</span><span class="sxs-lookup"><span data-stu-id="d4962-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="d4962-188"><xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> tienen integrada esta notificación al CLR, por lo que se recomienda su uso, así como el uso de la [instrucción lock](../../csharp/language-reference/keywords/lock-statement.md), que usa estos métodos.</span><span class="sxs-lookup"><span data-stu-id="d4962-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="d4962-189">Otros mecanismos de bloqueo, como los bloqueos por subproceso y <xref:System.Threading.AutoResetEvent>, deben llamar a estos métodos para notificar al CLR que se está entrando en una sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d4962-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="d4962-190">Estos métodos no toman ningún bloqueo; informan al CLR que se está ejecutando código en una sección crítica y la anulación del subproceso podría dejar un estado compartido incoherente.</span><span class="sxs-lookup"><span data-stu-id="d4962-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="d4962-191">Si ha definido su propio tipo de bloqueo, como un clase <xref:System.Threading.ReaderWriterLock> personalizada, use estos métodos de recuento de bloqueos.</span><span class="sxs-lookup"><span data-stu-id="d4962-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-192">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-192">Code analysis rule</span></span>

<span data-ttu-id="d4962-193">Marque e identifique todos los bloqueos mediante <xref:System.Threading.Thread.BeginCriticalRegion%2A> y <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4962-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="d4962-194">No use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> y <xref:System.Threading.Interlocked.Decrement%2A> en un bucle.</span><span class="sxs-lookup"><span data-stu-id="d4962-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="d4962-195">No realice una invocación de plataforma de las variantes de Win32 de estos métodos.</span><span class="sxs-lookup"><span data-stu-id="d4962-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="d4962-196">No use <xref:System.Threading.Thread.Sleep%2A> en un bucle.</span><span class="sxs-lookup"><span data-stu-id="d4962-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="d4962-197">No use campos volátiles.</span><span class="sxs-lookup"><span data-stu-id="d4962-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="d4962-198">El código de limpieza debe estar en un bloque Finally o Catch, no después de un Catch</span><span class="sxs-lookup"><span data-stu-id="d4962-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="d4962-199">El código de limpieza nunca debe seguir un bloqueo `catch`; debe estar en `finally` o en el propio bloque `catch`.</span><span class="sxs-lookup"><span data-stu-id="d4962-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="d4962-200">Esto debería ser una buena práctica normal.</span><span class="sxs-lookup"><span data-stu-id="d4962-200">This should be a normal good practice.</span></span> <span data-ttu-id="d4962-201">Normalmente es preferible un bloque `finally`, porque ejecuta el mismo código tanto cuando se produce una excepción como cuando se llega al final del bloque `try`.</span><span class="sxs-lookup"><span data-stu-id="d4962-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="d4962-202">Si se produce una excepción inesperada, por ejemplo <xref:System.Threading.ThreadAbortException>, el código de limpieza no se ejecutará.</span><span class="sxs-lookup"><span data-stu-id="d4962-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="d4962-203">Todos los recursos no administrados que limpiaría en `finally`, se deberían incluir en <xref:System.Runtime.InteropServices.SafeHandle> para evitar pérdidas.</span><span class="sxs-lookup"><span data-stu-id="d4962-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="d4962-204">Tenga en cuenta que se puede usar la palabra clave `using` de C# de manera eficaz para desechar objetos, incluidos los identificadores.</span><span class="sxs-lookup"><span data-stu-id="d4962-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="d4962-205">Aunque el reciclaje de <xref:System.AppDomain> puede limpiar los recursos en el subproceso de finalizador, sigue siendo importante colocar el código de limpieza en el lugar correcto.</span><span class="sxs-lookup"><span data-stu-id="d4962-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="d4962-206">Tenga en cuenta que si un subproceso recibe una excepción asincrónica sin mantener un bloqueo, el CLR intenta terminar el subproceso por sí mismo, sin necesidad de reciclar el <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="d4962-207">Asegurarse de que los recursos se limpian lo antes posible ayuda a que haya más recursos disponibles y a administrar mejor la duración.</span><span class="sxs-lookup"><span data-stu-id="d4962-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="d4962-208">Si no cierra explícitamente un identificador a un archivo en alguna ruta de acceso del código de error y después espera a que el finalizador de <xref:System.Runtime.InteropServices.SafeHandle> lo limpie, la próxima vez que ejecute el código se puede producir un error al intentar obtener acceso al mismo archivo si todavía no se ha ejecutado el finalizador.</span><span class="sxs-lookup"><span data-stu-id="d4962-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="d4962-209">Por este motivo, asegurarse de que el código de limpieza existe y funciona correctamente ayudará a recuperarse de errores de una forma más limpia y rápida, aunque no sea estrictamente necesario.</span><span class="sxs-lookup"><span data-stu-id="d4962-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-210">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-210">Code analysis rule</span></span>

<span data-ttu-id="d4962-211">El código de limpieza después de `catch` debe estar en un bloque `finally`.</span><span class="sxs-lookup"><span data-stu-id="d4962-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="d4962-212">Coloque las llamadas al método dispose en un bloque finally.</span><span class="sxs-lookup"><span data-stu-id="d4962-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="d4962-213">Los bloques `catch` deben terminar con throw o rethrow.</span><span class="sxs-lookup"><span data-stu-id="d4962-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="d4962-214">Aunque habrá excepciones, como el código que detecta si se puede establecer una conexión de red donde es posible que se obtenga cualquiera de un gran número de excepciones, el código que requiera la detección de un número de excepciones en circunstancias normales debe proporcionar una indicación de que el código se debe probar para ver si va a ser correcto.</span><span class="sxs-lookup"><span data-stu-id="d4962-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="d4962-215">El estado compartido mutable de todo el proceso entre dominios de aplicación se debe eliminar o utilizar una región de ejecución restringida</span><span class="sxs-lookup"><span data-stu-id="d4962-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="d4962-216">Como se describe en la introducción, puede ser muy difícil escribir código administrado que supervise el estado compartido de todo el proceso entre dominios de aplicación de una forma confiable.</span><span class="sxs-lookup"><span data-stu-id="d4962-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="d4962-217">El estado compartido de todo el proceso es cualquier tipo de estructura de datos compartida entre dominios de aplicación, ya sea en código Win32, dentro del CLR o en código administrado mediante la comunicación remota.</span><span class="sxs-lookup"><span data-stu-id="d4962-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="d4962-218">Cualquier estado compartido mutable es muy difícil de escribir correctamente en código administrado, y cualquier estado compartido estático solo puede hacerse con sumo cuidado.</span><span class="sxs-lookup"><span data-stu-id="d4962-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="d4962-219">Si tiene un estado compartido de todo el proceso o todo el equipo, busque alguna forma de eliminarlo o proteja el estado compartido con una región de ejecución restringida (CER).</span><span class="sxs-lookup"><span data-stu-id="d4962-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="d4962-220">Tenga en cuenta que cualquier biblioteca con estado compartido que no se identifique y corrija puede producir el bloqueo de un host, como SQL Server, que requiera que se limpie la descarga de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="d4962-221">Si el código usa un objeto COM, evite el uso compartido de ese objeto COM entre dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d4962-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="d4962-222">Los bloqueos no funcionan en todo el proceso o entre dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d4962-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="d4962-223">En el pasado, <xref:System.Threading.Monitor.Enter%2A> y la [instrucción lock](../../csharp/language-reference/keywords/lock-statement.md) se han usado para crear bloqueos de proceso globales.</span><span class="sxs-lookup"><span data-stu-id="d4962-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="d4962-224">Por ejemplo, esto se produce al bloquear en clases ágiles de <xref:System.AppDomain>, como instancias de <xref:System.Type> de ensamblados no compartidos, objetos <xref:System.Threading.Thread>, cadenas internadas y algunas cadenas compartidas entre dominios de aplicación mediante comunicación remota.</span><span class="sxs-lookup"><span data-stu-id="d4962-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="d4962-225">Estos bloqueos ya no son de todo el proceso.</span><span class="sxs-lookup"><span data-stu-id="d4962-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="d4962-226">Para identificar la presencia de un bloqueo de dominios entre aplicaciones de todo el proceso, determine si el código dentro del bloqueo usa algún recurso persistente externo, como un archivo en disco o, posiblemente, una base de datos.</span><span class="sxs-lookup"><span data-stu-id="d4962-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="d4962-227">Tenga en cuenta que tomar un bloqueo en un <xref:System.AppDomain> es posible que cause problemas si el código protegido usa un recurso externo, dado que ese código podría ejecutarse simultáneamente en varios dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d4962-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="d4962-228">Esto puede ser un problema al escribir en un archivo de registro o al enlazar a un socket para todo el proceso.</span><span class="sxs-lookup"><span data-stu-id="d4962-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="d4962-229">Estos cambios significan que no hay ninguna manera fácil, mediante código administrado, de obtener un bloqueo global del proceso que no sea usar una instancia de <xref:System.Threading.Mutex> o <xref:System.Threading.Semaphore> con nombre.</span><span class="sxs-lookup"><span data-stu-id="d4962-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="d4962-230">Cree código que no se ejecute simultáneamente en dos dominios de aplicación, o use las clases <xref:System.Threading.Mutex> o <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="d4962-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="d4962-231">Si no se puede cambiar el código existente, no use una exclusión mutua con nombre de Win32 para conseguir esta sincronización, dado que la ejecución en modo de fibra significa que no se puede garantizar que el mismo subproceso de sistema operativo vaya a adquirir y liberar una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="d4962-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="d4962-232">Debe usar la clase administrada <xref:System.Threading.Mutex>, <xref:System.Threading.ManualResetEvent> con nombre, <xref:System.Threading.AutoResetEvent> o <xref:System.Threading.Semaphore> para sincronizar el bloqueo de código de forma que el CLR lo sepa en lugar de sincronizar el bloqueo con código no administrado.</span><span class="sxs-lookup"><span data-stu-id="d4962-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="d4962-233">Evitar lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="d4962-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="d4962-234">Los objetos <xref:System.Type> públicos y privados en ensamblados compartidos con solo una copia del código que se comparte entre todos los dominios de aplicación también presentan problemas.</span><span class="sxs-lookup"><span data-stu-id="d4962-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="d4962-235">Para los ensamblados compartidos, solo hay una instancia de un <xref:System.Type> por proceso, lo que significa que varios dominios de aplicación comparten la misma instancia de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="d4962-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="d4962-236">Tomar un bloqueo en una instancia de <xref:System.Type> toma un bloqueo que afecta a todo el proceso, no solo al <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="d4962-237">Si <xref:System.AppDomain> toma un bloqueo en un objeto <xref:System.Type> y después ese subproceso se anula abruptamente, no liberará el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d4962-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="d4962-238">Después, este bloqueo, puede provocar el interbloqueo de otros dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d4962-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="d4962-239">Una buena manera de tomar bloqueos en métodos estáticos implica agregar un objeto de sincronización interno estático al código.</span><span class="sxs-lookup"><span data-stu-id="d4962-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="d4962-240">Esto se podría inicializar en el constructor de clase si existe, pero si no, se puede inicializar de esta forma:</span><span class="sxs-lookup"><span data-stu-id="d4962-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="d4962-241">Después, al tomar un bloqueo, use la propiedad `InternalSyncObject` para obtener un objeto para bloquear.</span><span class="sxs-lookup"><span data-stu-id="d4962-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="d4962-242">No es necesario usar la propiedad si el objeto de sincronización interno se ha inicializado en el constructor de la clase.</span><span class="sxs-lookup"><span data-stu-id="d4962-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="d4962-243">El código de inicialización de bloqueo de comprobación debe ser similar a este ejemplo:</span><span class="sxs-lookup"><span data-stu-id="d4962-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="d4962-244">Una nota acerca del bloqueo (this)</span><span class="sxs-lookup"><span data-stu-id="d4962-244">A note about lock(this)</span></span>

<span data-ttu-id="d4962-245">Normalmente resulta aceptable tomar un bloqueo en un objeto individual que es accesible públicamente.</span><span class="sxs-lookup"><span data-stu-id="d4962-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="d4962-246">Pero si es un objeto Singleton que es posible que provoque el interbloqueo de un subsistema completo, considere la posibilidad de usar el modelo de diseño anterior.</span><span class="sxs-lookup"><span data-stu-id="d4962-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="d4962-247">Por ejemplo, un bloqueo en el objeto <xref:System.Security.SecurityManager> podría causar un interbloqueo en el <xref:System.AppDomain> inutilizando todo el <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="d4962-248">Es recomendable no tomar un bloqueo en un objeto accesible públicamente de este tipo.</span><span class="sxs-lookup"><span data-stu-id="d4962-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="d4962-249">No obstante, un bloqueo en una colección o matriz concreta generalmente no debería suponer un problema.</span><span class="sxs-lookup"><span data-stu-id="d4962-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-250">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-250">Code analysis rule</span></span>

<span data-ttu-id="d4962-251">No tome bloqueos en tipos que es posible que se usen en dominios de aplicación o no tengan un sentido fuerte de identidad.</span><span class="sxs-lookup"><span data-stu-id="d4962-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="d4962-252">No llame a <xref:System.Threading.Monitor.Enter%2A> en un objeto <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread> o cualquier otro que se derive de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="d4962-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="d4962-253">Quitar GC. Llamadas KeepAlive</span><span class="sxs-lookup"><span data-stu-id="d4962-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="d4962-254">Una cantidad significativa del código existente no usa <xref:System.GC.KeepAlive%2A> cuando debe o lo usa cuando no es adecuado.</span><span class="sxs-lookup"><span data-stu-id="d4962-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="d4962-255">Después de convertir a <xref:System.Runtime.InteropServices.SafeHandle>, no es necesario que las clases llamen a <xref:System.GC.KeepAlive%2A>, suponiendo que no tienen un finalizador sino que se basan en <xref:System.Runtime.InteropServices.SafeHandle> para finalizar los identificadores de sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="d4962-256">Mientras que el costo de rendimiento de mantener una llamada a <xref:System.GC.KeepAlive%2A> puede ser insignificante, la percepción de que una llamada a <xref:System.GC.KeepAlive%2A> es necesaria o suficiente para solucionar un problema de duración que puede que ya no exista hace que el código sea más difícil de mantener.</span><span class="sxs-lookup"><span data-stu-id="d4962-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="d4962-257">Aun así, cuando se usan contenedores RCW de interoperabilidad COM, el código sigue necesitando <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4962-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-258">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-258">Code analysis rule</span></span>

<span data-ttu-id="d4962-259">Quite <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4962-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="d4962-260">Usar el atributo HostProtection</span><span class="sxs-lookup"><span data-stu-id="d4962-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="d4962-261">El <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) proporciona el uso de acciones de seguridad declarativa para determinar los requisitos de protección del host, lo que permite que el host evite que incluso el código de plena confianza llame a determinados métodos que no son apropiados para el host dado, como <xref:System.Environment.Exit%2A> o <xref:System.Windows.Forms.MessageBox.Show%2A> para SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4962-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="d4962-262">El HPA solo afecta a las aplicaciones no administradas que hospedan el CLR e implementan protección de host, como SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4962-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="d4962-263">Cuando se aplica, la acción de seguridad crea como resultado una petición de vínculo que se basa en los recursos de host que expone la clase o el método.</span><span class="sxs-lookup"><span data-stu-id="d4962-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="d4962-264">Si el código se ejecuta en una aplicación cliente o en un servidor que no está protegido por el host, el atributo "se evapora"; no se detecta y, por tanto, no se aplica.</span><span class="sxs-lookup"><span data-stu-id="d4962-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d4962-265">El propósito de este atributo es aplicar las directrices del modelo de programación específico del host, no el comportamiento de seguridad.</span><span class="sxs-lookup"><span data-stu-id="d4962-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="d4962-266">Aunque se usa una petición de vínculo para comprobar el cumplimiento de los requisitos del modelo de programación, el <xref:System.Security.Permissions.HostProtectionAttribute> no es un permiso de seguridad.</span><span class="sxs-lookup"><span data-stu-id="d4962-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="d4962-267">Si el host no tiene requisitos de modelo de programación, no se producen peticiones de vínculo.</span><span class="sxs-lookup"><span data-stu-id="d4962-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="d4962-268">Este atributo identifica lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="d4962-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="d4962-269">Métodos o clases que no se ajustan al modelo de programación del host, pero que son inofensivos.</span><span class="sxs-lookup"><span data-stu-id="d4962-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="d4962-270">Métodos o clases que no se ajustan al modelo de programación del host y que podrían desestabilizar el código de usuario administrado por el servidor.</span><span class="sxs-lookup"><span data-stu-id="d4962-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="d4962-271">Métodos o clases que no se ajustan al modelo de programación del host y que podrían desestabilizar el propio proceso de servidor.</span><span class="sxs-lookup"><span data-stu-id="d4962-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="d4962-272">Si va a crear una biblioteca de clases que va a ser llamada por aplicaciones que se pueden ejecutar en un entorno de host protegido, debe aplicar este atributo a los miembros que exponen categorías de recursos de <xref:System.Security.Permissions.HostProtectionResource>.</span><span class="sxs-lookup"><span data-stu-id="d4962-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="d4962-273">Los miembros de la biblioteca de clases .NET Framework con este atributo hacen que solo se compruebe el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="d4962-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="d4962-274">El miembro de biblioteca también debe provocar una comprobación de su llamador inmediato de la misma manera.</span><span class="sxs-lookup"><span data-stu-id="d4962-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="d4962-275">Encontrará más información sobre HPA en <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d4962-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-276">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-276">Code analysis rule</span></span>

<span data-ttu-id="d4962-277">Para SQL Server, todos los métodos que se usan para introducir la sincronización o subprocesos deben identificarse con el atributo HPA.</span><span class="sxs-lookup"><span data-stu-id="d4962-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="d4962-278">Esto incluye los métodos que comparten el estado, se sincronizan o administran procesos externos.</span><span class="sxs-lookup"><span data-stu-id="d4962-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="d4962-279">Los valores de <xref:System.Security.Permissions.HostProtectionResource> que afectan a SQL Server son <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> y <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="d4962-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="d4962-280">Sin embargo, cualquier método que expone cualquier <xref:System.Security.Permissions.HostProtectionResource> debe identificarse mediante un atributo HPA, no solo los recursos que afectan a SQL.</span><span class="sxs-lookup"><span data-stu-id="d4962-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="d4962-281">No bloquear indefinidamente en código no administrado</span><span class="sxs-lookup"><span data-stu-id="d4962-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="d4962-282">El bloqueo en código no administrado en lugar de en código administrado puede provocar un ataque por denegación de servicio porque el CLR no puede anular el subproceso.</span><span class="sxs-lookup"><span data-stu-id="d4962-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="d4962-283">Un subproceso bloqueado impide al CLR descargar <xref:System.AppDomain>, al menos sin tener que realizar algunas operaciones extremadamente no seguras.</span><span class="sxs-lookup"><span data-stu-id="d4962-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="d4962-284">El bloqueo mediante una primitiva de sincronización de Windows es un claro ejemplo de algo que no se puede permitir.</span><span class="sxs-lookup"><span data-stu-id="d4962-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="d4962-285">El bloqueo en una llamada a `ReadFile` en un socket debe evitarse si es posible; idealmente, la API de Windows debe proporcionar un mecanismo para una operación como esta para agotar el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d4962-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="d4962-286">Cualquier método que realice llamadas nativas debería usar idealmente una llamada de Win32 con un tiempo de espera razonable y finito.</span><span class="sxs-lookup"><span data-stu-id="d4962-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="d4962-287">Si se permite al usuario especificar el tiempo de espera, el usuario no debería poder especificar un tiempo de espera infinito sin algunos permisos de seguridad específicos.</span><span class="sxs-lookup"><span data-stu-id="d4962-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="d4962-288">Como norma, si un método se va a bloquear durante más de 10 segundos, se debe usar una versión que admita tiempos de espera o necesitará soporte adicional del CLR.</span><span class="sxs-lookup"><span data-stu-id="d4962-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="d4962-289">Estos son algunos ejemplos de API problemáticas.</span><span class="sxs-lookup"><span data-stu-id="d4962-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="d4962-290">Se pueden crear canalizaciones (anónimas y con nombre) con un tiempo de espera, pero el código debe garantizar que nunca llama a `CreateNamedPipe` ni `WaitNamedPipe` con NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="d4962-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="d4962-291">Además, puede haber un bloqueo inesperado incluso si se especifica un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d4962-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="d4962-292">La llamada a `WriteFile` en una canalización anónima se bloqueará hasta que se escriban todos los bytes, lo que significa que si el búfer contiene datos sin leer, la llamada a `WriteFile` se bloqueará hasta que el lector haya liberado espacio en el búfer de la canalización.</span><span class="sxs-lookup"><span data-stu-id="d4962-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="d4962-293">Los sockets siempre deberían usar alguna API que acepte un mecanismo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d4962-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-294">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-294">Code analysis rule</span></span>

<span data-ttu-id="d4962-295">Bloquear sin un tiempo de espera en código no administrado es un ataque por denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="d4962-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="d4962-296">No realice llamadas de invocación de plataforma a `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects` y `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="d4962-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="d4962-297">No use NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="d4962-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="d4962-298">Identificación de las características que dependen de STA</span><span class="sxs-lookup"><span data-stu-id="d4962-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="d4962-299">Identifique cualquier código que use contenedores uniproceso (STA) de COM.</span><span class="sxs-lookup"><span data-stu-id="d4962-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="d4962-300">Los STA están deshabilitados en el proceso de SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4962-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="d4962-301">Las características que dependen de `CoInitialize`, como los contadores de rendimiento o el Portapapeles, deben deshabilitarse en SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4962-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="d4962-302">Asegurarse de que los finalizadores no tienen problemas de sincronización</span><span class="sxs-lookup"><span data-stu-id="d4962-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="d4962-303">Es posible que en futuras versiones de .NET existan varios subprocesos de finalizador, lo que significa que los finalizadores para distintas instancias del mismo tipo se ejecutan simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="d4962-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="d4962-304">No es necesario que sean totalmente seguros para subprocesos; el recolector de elementos no utilizados garantiza que solo un subproceso ejecutará el finalizador de una instancia de objeto determinada.</span><span class="sxs-lookup"><span data-stu-id="d4962-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="d4962-305">No obstante, los finalizadores deben estar codificados para evitar interbloqueos y condiciones de carrera cuando se ejecutan simultáneamente en varias instancias de objeto distintas.</span><span class="sxs-lookup"><span data-stu-id="d4962-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="d4962-306">Cuando en un finalizador se usa un estado externo, como al escribir en un archivo de registro, los problemas de subprocesos se deben solucionar.</span><span class="sxs-lookup"><span data-stu-id="d4962-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="d4962-307">No confíe en la finalización para proporcionar seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d4962-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="d4962-308">No use almacenamiento local de subprocesos, administrado o nativo, para almacenar el estado en el subproceso del finalizador.</span><span class="sxs-lookup"><span data-stu-id="d4962-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-309">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-309">Code analysis rule</span></span>

<span data-ttu-id="d4962-310">Los finalizadores no deben presentar problemas de sincronización.</span><span class="sxs-lookup"><span data-stu-id="d4962-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="d4962-311">No use un estado mudable estático en un finalizador.</span><span class="sxs-lookup"><span data-stu-id="d4962-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="d4962-312">Evitar la memoria no administrada si es posible</span><span class="sxs-lookup"><span data-stu-id="d4962-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="d4962-313">La memoria no administrada puede tener pérdidas, al igual que un identificador del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d4962-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="d4962-314">Si es posible, intente usar memoria de la pila mediante [stackalloc](../../csharp/language-reference/operators/stackalloc.md) o un objeto administrado anclado, como la [instrucción fixed](../../csharp/language-reference/keywords/fixed-statement.md) o un <xref:System.Runtime.InteropServices.GCHandle> mediante un byte [].</span><span class="sxs-lookup"><span data-stu-id="d4962-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="d4962-315">El <xref:System.GC> acabará por limpiarlos.</span><span class="sxs-lookup"><span data-stu-id="d4962-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="d4962-316">Pero si tiene que asignar memoria no administrada, considere el uso de una clase derivada de <xref:System.Runtime.InteropServices.SafeHandle> para encapsular la asignación de memoria.</span><span class="sxs-lookup"><span data-stu-id="d4962-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="d4962-317">Tenga en cuenta que al menos hay un caso en el que <xref:System.Runtime.InteropServices.SafeHandle> no resulta adecuado.</span><span class="sxs-lookup"><span data-stu-id="d4962-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="d4962-318">Para las llamadas a métodos COM que asignan o liberan memoria, es común que un archivo DLL asigne memoria a través de `CoTaskMemAlloc` y después otro archivo DLL libere esa memoria con `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="d4962-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="d4962-319">Usar <xref:System.Runtime.InteropServices.SafeHandle> en estos casos no sería adecuado porque intentará unir la duración de la memoria no administrada a la duración del <xref:System.Runtime.InteropServices.SafeHandle> en lugar de permitir que el otro archivo DLL controle la duración de la memoria.</span><span class="sxs-lookup"><span data-stu-id="d4962-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="d4962-320">Revisar todos los usos de catch (excepción)</span><span class="sxs-lookup"><span data-stu-id="d4962-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="d4962-321">Los bloques catch que detectan todas las excepciones en lugar de una excepción concreta ahora también detectarán las excepciones asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="d4962-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="d4962-322">Examine todos los bloques catch(Exception) en busca de código devuelto o de liberación de recursos que no sea importante y que se haya podido pasar por alto, así como comportamientos potencialmente incorrectos dentro del propio bloque catch para controlar una excepción <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> u <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="d4962-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="d4962-323">Tenga en cuenta que es posible que este código registre o asuma que solo puede ver determinadas excepciones, o que cada vez que se produce una excepción se produzca un error por un único motivo concreto.</span><span class="sxs-lookup"><span data-stu-id="d4962-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="d4962-324">Es posible que tenga que actualizar estas suposiciones para incluir <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="d4962-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="d4962-325">Considere la posibilidad de cambiar todos los lugares en que se detectan todas las excepciones por la detección de un tipo concreto de excepción que espera que se vaya producir, como una excepción <xref:System.FormatException> de métodos de formato de cadena.</span><span class="sxs-lookup"><span data-stu-id="d4962-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="d4962-326">Esto impide que el bloque catch se ejecute con excepciones inesperadas y ayuda a garantizar que el código no oculta errores detectando excepciones inesperadas.</span><span class="sxs-lookup"><span data-stu-id="d4962-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="d4962-327">Como norma general, no controle nunca una excepción en código de biblioteca (el código que requiere que se detecte una excepción puede indicar un problema de diseño en el código al que se está llamando).</span><span class="sxs-lookup"><span data-stu-id="d4962-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="d4962-328">En algunos casos es posible que quiera detectar una excepción e iniciar un tipo de excepción diferente para proporcionar más datos.</span><span class="sxs-lookup"><span data-stu-id="d4962-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="d4962-329">En este caso, use las excepciones anidadas, almacenando la causa real del error en la propiedad <xref:System.Exception.InnerException%2A> de la nueva excepción.</span><span class="sxs-lookup"><span data-stu-id="d4962-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-330">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-330">Code analysis rule</span></span>

<span data-ttu-id="d4962-331">Revise todos los bloques catch en código administrado que detectan todos los objetos o todas las excepciones.</span><span class="sxs-lookup"><span data-stu-id="d4962-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="d4962-332">En C#, esto significa marcar `catch` {} y `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="d4962-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="d4962-333">Considere la posibilidad de hacer que el tipo de excepción sea muy específico, o bien revise el código para asegurarse de que no actúa de forma incorrecta si detecta un tipo de excepción inesperada.</span><span class="sxs-lookup"><span data-stu-id="d4962-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="d4962-334">No asuma que un subproceso administrado es un subproceso de Win32, es una fibra</span><span class="sxs-lookup"><span data-stu-id="d4962-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="d4962-335">El uso de almacenamiento local de subprocesos administrados sirve, pero no se puede usar el almacenamiento local de subprocesos no administrados ni suponer que el código se va a ejecutar de nuevo en el subproceso del sistema operativo actual.</span><span class="sxs-lookup"><span data-stu-id="d4962-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="d4962-336">No cambie ajustes como la configuración regional del subproceso.</span><span class="sxs-lookup"><span data-stu-id="d4962-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="d4962-337">No llame a `InitializeCriticalSection` o `CreateMutex` a través de la invocación de plataforma porque requieren que el subproceso del sistema operativo que entra en un bloqueo también salga del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d4962-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="d4962-338">Como este no es el caso cuando se usan fibras, las secciones críticas de Win32 y las exclusiones mutuas no se pueden usar directamente en SQL.</span><span class="sxs-lookup"><span data-stu-id="d4962-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="d4962-339">Tenga en cuenta que la clase administrada <xref:System.Threading.Mutex> no controla estas consideraciones de afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d4962-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="d4962-340">Puede usar sin ningún riesgo la mayor parte del estado en un objeto <xref:System.Threading.Thread> administrado, incluido el almacenamiento local de subprocesos administrados y la referencia cultural de la interfaz de usuario actual del subproceso.</span><span class="sxs-lookup"><span data-stu-id="d4962-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="d4962-341">También puede usar el <xref:System.ThreadStaticAttribute>, que hace que el valor de una variable estática existente solo sea accesible para el subproceso administrado actual (es otra manera de realizar almacenamiento local de fibras en el CLR).</span><span class="sxs-lookup"><span data-stu-id="d4962-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="d4962-342">Por motivos del modelo de programación, no se puede cambiar la referencia cultural actual de un subproceso cuando se ejecuta en SQL.</span><span class="sxs-lookup"><span data-stu-id="d4962-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-343">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-343">Code analysis rule</span></span>

<span data-ttu-id="d4962-344">SQL Server se ejecuta en modo de fibra; no use almacenamiento local de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d4962-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="d4962-345">Evite llamadas de invocación de plataforma a `TlsAlloc`, `TlsFree`, `TlsGetValue` y `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="d4962-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="d4962-346">Permitir que SQL Server controle la suplantación</span><span class="sxs-lookup"><span data-stu-id="d4962-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="d4962-347">Dado que la suplantación opera en el nivel de subproceso y SQL se puede ejecutar en modo de fibra, el código administrado no debe suplantar a los usuarios y no debería llamar a `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="d4962-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-348">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-348">Code analysis rule</span></span>

<span data-ttu-id="d4962-349">Permita que SQL Server controle la suplantación.</span><span class="sxs-lookup"><span data-stu-id="d4962-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="d4962-350">No use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx` ni `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="d4962-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="d4962-351">No llamar a Thread:: Suspend</span><span class="sxs-lookup"><span data-stu-id="d4962-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="d4962-352">La capacidad de suspender un subproceso parece una operación sencilla, pero puede producir interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="d4962-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="d4962-353">Si un subproceso que mantiene un bloqueo queda suspendido por un segundo subproceso y, después, el segundo subproceso intenta tomar el mismo bloqueo, se produce un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="d4962-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="d4962-354">En la actualidad, <xref:System.Threading.Thread.Suspend%2A> puede interferir con la seguridad, la carga de clases, la comunicación remota y la reflexión.</span><span class="sxs-lookup"><span data-stu-id="d4962-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d4962-355">Regla de análisis de código</span><span class="sxs-lookup"><span data-stu-id="d4962-355">Code analysis rule</span></span>

<span data-ttu-id="d4962-356">No llame a <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4962-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="d4962-357">Considere el uso de una primitiva de sincronización real en su lugar, como un <xref:System.Threading.Semaphore> o <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="d4962-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="d4962-358">Proteja las operaciones críticas con regiones de ejecución restringidas y contratos de confiabilidad</span><span class="sxs-lookup"><span data-stu-id="d4962-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="d4962-359">Al realizar una operación compleja que actualiza un estado compartido o que deba ser totalmente correcta o totalmente incorrecta de manera determinante, asegúrese de que está protegida por una región de ejecución restringida (CER).</span><span class="sxs-lookup"><span data-stu-id="d4962-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="d4962-360">Esto garantiza que el código se ejecuta en todos los casos, incluso en una anulación abrupta del subproceso o una descarga abrupta de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d4962-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="d4962-361">Una CER es un bloque `try/finally` concreto precedido inmediatamente por una llamada a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="d4962-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="d4962-362">Hacer esto indica al compilador Just-In-Time que prepare todo el código en el bloque finally antes de ejecutar el bloque `try`.</span><span class="sxs-lookup"><span data-stu-id="d4962-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="d4962-363">Esto garantiza que el código en el bloque finally se compila y se ejecuta en todos los casos.</span><span class="sxs-lookup"><span data-stu-id="d4962-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="d4962-364">No es raro que una CER tenga un bloque `try` vacío.</span><span class="sxs-lookup"><span data-stu-id="d4962-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="d4962-365">El uso de una CER protege frente a anulaciones de subprocesos asincrónicos y excepciones de memoria insuficiente.</span><span class="sxs-lookup"><span data-stu-id="d4962-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="d4962-366">Vea <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> para obtener una forma de CER que además administra desbordamientos de pila para código excesivamente profundo.</span><span class="sxs-lookup"><span data-stu-id="d4962-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="d4962-367">Consulte también</span><span class="sxs-lookup"><span data-stu-id="d4962-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="d4962-368">Programación en SQL Server y atributos de protección de host</span><span class="sxs-lookup"><span data-stu-id="d4962-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
