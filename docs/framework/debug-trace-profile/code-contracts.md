---
title: Contratos de código
description: Explore los contratos de código, que proporcionan una manera de especificar condiciones previas, condiciones posteriores y objetos invariables en el código de .NET.
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: 60f794373af75bd3f745c224e0a8c7a84192e4c4
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904148"
---
# <a name="code-contracts"></a><span data-ttu-id="de27b-103">Contratos de código</span><span class="sxs-lookup"><span data-stu-id="de27b-103">Code Contracts</span></span>

<span data-ttu-id="de27b-104">Los contratos de código proporcionan una manera de especificar condiciones previas, condiciones posteriores e invariantes de objeto en el código.</span><span class="sxs-lookup"><span data-stu-id="de27b-104">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="de27b-105">Las condiciones previas son requisitos que deben cumplirse al escribir un método o propiedad.</span><span class="sxs-lookup"><span data-stu-id="de27b-105">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="de27b-106">Las condiciones posteriores describen las expectativas en el momento en que se cierra el código del método o propiedad.</span><span class="sxs-lookup"><span data-stu-id="de27b-106">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="de27b-107">Las invariantes de objeto describen el estado esperado de una clase que está en buen estado.</span><span class="sxs-lookup"><span data-stu-id="de27b-107">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="de27b-108">Los contratos de código incluyen clases para marcar el código, un analizador estático para el análisis de tiempo de compilación y un analizador en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="de27b-108">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="de27b-109">Las clases para contratos de código pueden encontrarse en el espacio de nombres <xref:System.Diagnostics.Contracts>.</span><span class="sxs-lookup"><span data-stu-id="de27b-109">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="de27b-110">Algunas de las ventajas ofrecidas por los contratos de código son:</span><span class="sxs-lookup"><span data-stu-id="de27b-110">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="de27b-111">Pruebas mejoradas: los contratos de código proporcionan comprobación estática del contrato, comprobación en runtime y generación de documentación.</span><span class="sxs-lookup"><span data-stu-id="de27b-111">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="de27b-112">Herramientas de prueba automáticas: puede usar los contratos de código para generar pruebas unitarias más significativas eliminando los argumentos de prueba poco importantes que no satisfacen las condiciones previas.</span><span class="sxs-lookup"><span data-stu-id="de27b-112">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="de27b-113">Comprobación estática: el comprobador estático puede decidir si hay alguna infracción del contrato sin ejecutar el programa.</span><span class="sxs-lookup"><span data-stu-id="de27b-113">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="de27b-114">Se comprueban los contratos implícitos, como desreferencias null y límites de matriz, y los contratos explícitos.</span><span class="sxs-lookup"><span data-stu-id="de27b-114">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="de27b-115">Documentación de referencia: el generador de documentación aumenta los archivos de documentación XML existentes con información de contrato.</span><span class="sxs-lookup"><span data-stu-id="de27b-115">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="de27b-116">También hay hojas de estilo que se pueden usar con [Sandcastle](https://github.com/EWSoftware/SHFB) para que las páginas de documentación generadas tengan secciones de contrato.</span><span class="sxs-lookup"><span data-stu-id="de27b-116">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="de27b-117">Todos los lenguajes de .NET Framework pueden beneficiarse de inmediato de los contratos; no es necesario escribir un analizador o compilador especial.</span><span class="sxs-lookup"><span data-stu-id="de27b-117">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="de27b-118">Un complemento de Visual Studio le permite especificar el nivel de análisis de contrato de código que se realiza.</span><span class="sxs-lookup"><span data-stu-id="de27b-118">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="de27b-119">Los analizadores pueden confirmar si los contratos están correctamente formados (comprobación de tipos y resolución de nombres) y pueden generar un formulario compilado de los contratos en formato de Lenguaje Intermedio de Microsoft (MSIL).</span><span class="sxs-lookup"><span data-stu-id="de27b-119">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="de27b-120">La creación de contratos en Visual Studio le permite aprovechar el IntelliSense estándar proporcionado por la herramienta.</span><span class="sxs-lookup"><span data-stu-id="de27b-120">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="de27b-121">La mayoría de los métodos de la clase de contrato se compila condicionalmente; es decir, el compilador emite llamadas a estos métodos solo cuando se define un símbolo especial, CONTRACTS_FULL, mediante la directiva `#define`.</span><span class="sxs-lookup"><span data-stu-id="de27b-121">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="de27b-122">CONTRACTS_FULL le permite escribir contratos en su código sin usar directivas `#ifdef`; puede generar diferentes compilaciones, algunas con contratos y otras sin ellos.</span><span class="sxs-lookup"><span data-stu-id="de27b-122">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="de27b-123">Para obtener herramientas e instrucciones detalladas sobre el uso de contratos de código, vea [code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) en el sitio de Visual Studio Marketplace.</span><span class="sxs-lookup"><span data-stu-id="de27b-123">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="de27b-124">Preconditions</span><span class="sxs-lookup"><span data-stu-id="de27b-124">Preconditions</span></span>

<span data-ttu-id="de27b-125">El método <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> permite expresar condiciones previas.</span><span class="sxs-lookup"><span data-stu-id="de27b-125">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="de27b-126">Las condiciones previas especifican el estado cuando se invoca un método.</span><span class="sxs-lookup"><span data-stu-id="de27b-126">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="de27b-127">Generalmente se usan para especificar valores de parámetro válidos.</span><span class="sxs-lookup"><span data-stu-id="de27b-127">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="de27b-128">Todos los miembros que se mencionan en las condiciones previas deben ser al menos tan accesibles como el propio método; de lo contrario, es posible que la condición previa no sea entendida por todos los llamadores de un método.</span><span class="sxs-lookup"><span data-stu-id="de27b-128">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="de27b-129">La condición no debe tener efectos secundarios.</span><span class="sxs-lookup"><span data-stu-id="de27b-129">The condition must have no side-effects.</span></span> <span data-ttu-id="de27b-130">El analizador de runtime determina el comportamiento en tiempo de ejecución de las condiciones previas con errores.</span><span class="sxs-lookup"><span data-stu-id="de27b-130">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="de27b-131">Por ejemplo, la condición previa siguiente expresa que el parámetro `x` debe ser distinto de null.</span><span class="sxs-lookup"><span data-stu-id="de27b-131">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="de27b-132">Si el código debe producir una excepción determinada en caso de error de la condición previa, puede usar la sobrecarga genérica de <xref:System.Diagnostics.Contracts.Contract.Requires%2A> del modo siguiente.</span><span class="sxs-lookup"><span data-stu-id="de27b-132">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="de27b-133">La herencia requiere instrucciones</span><span class="sxs-lookup"><span data-stu-id="de27b-133">Legacy Requires Statements</span></span>

<span data-ttu-id="de27b-134">La mayor parte del código contiene alguna validación de parámetros en forma de código `if`-`then`-`throw`.</span><span class="sxs-lookup"><span data-stu-id="de27b-134">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="de27b-135">Las herramientas de contrato reconocen estas instrucciones como condiciones previas en los casos siguientes:</span><span class="sxs-lookup"><span data-stu-id="de27b-135">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="de27b-136">Las instrucciones aparecen antes que cualquier otra instrucción en un método.</span><span class="sxs-lookup"><span data-stu-id="de27b-136">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="de27b-137">El conjunto completo de tales instrucciones va seguido de una llamada de método <xref:System.Diagnostics.Contracts.Contract> explícita, como una llamada al método <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> o <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="de27b-137">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="de27b-138">Cuando las instrucciones `if`-`then`-`throw` aparecen en este formato, las herramientas las reconocen como instrucciones `requires` heredadas.</span><span class="sxs-lookup"><span data-stu-id="de27b-138">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="de27b-139">Si ningún otro contrato sigue la secuencia `if`-`then`-`throw`, finalice el código con el método <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de27b-139">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="de27b-140">Tenga en cuenta que la condición en la prueba anterior es una condición previa negada</span><span class="sxs-lookup"><span data-stu-id="de27b-140">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="de27b-141">(La condición previa real sería `x != null` ). Una condición previa negada está muy restringida: debe escribirse como se muestra en el ejemplo anterior. es decir, no debe contener `else` cláusulas y el cuerpo de la `then` cláusula debe ser una sola `throw` instrucción.</span><span class="sxs-lookup"><span data-stu-id="de27b-141">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="de27b-142">La prueba `if` está sujeta a reglas de pureza y de visibilidad (vea las [instrucciones de uso](#usage_guidelines)), pero la expresión `throw` solo está sujeta a reglas de pureza.</span><span class="sxs-lookup"><span data-stu-id="de27b-142">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="de27b-143">Sin embargo, el tipo de la excepción generada debe ser tan visible como el método en el que se produce el contrato.</span><span class="sxs-lookup"><span data-stu-id="de27b-143">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="de27b-144">Condiciones posteriores</span><span class="sxs-lookup"><span data-stu-id="de27b-144">Postconditions</span></span>

<span data-ttu-id="de27b-145">Las condiciones posteriores son contratos para el estado de un método cuando finaliza.</span><span class="sxs-lookup"><span data-stu-id="de27b-145">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="de27b-146">La condición posterior se comprueba justo antes de salir de un método.</span><span class="sxs-lookup"><span data-stu-id="de27b-146">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="de27b-147">El analizador de runtime determina el comportamiento en tiempo de ejecución de las condiciones posteriores con errores.</span><span class="sxs-lookup"><span data-stu-id="de27b-147">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="de27b-148">A diferencia de las condiciones previas, las condiciones posteriores pueden hacer referencia a miembros con menos visibilidad.</span><span class="sxs-lookup"><span data-stu-id="de27b-148">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="de27b-149">Es posible que algún cliente no sea capaz de entender o usar parte de la información expresada por una condición posterior mediante el estado privado, pero esto no afecta a la capacidad del cliente para usar el método correctamente.</span><span class="sxs-lookup"><span data-stu-id="de27b-149">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="de27b-150">Condiciones posteriores estándar</span><span class="sxs-lookup"><span data-stu-id="de27b-150">Standard Postconditions</span></span>

<span data-ttu-id="de27b-151">El método <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> permite expresar condiciones posteriores estándar.</span><span class="sxs-lookup"><span data-stu-id="de27b-151">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="de27b-152">Las condiciones posteriores expresan una condición que debe ser `true` tras la finalización normal del método.</span><span class="sxs-lookup"><span data-stu-id="de27b-152">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="de27b-153">Condiciones posteriores excepcionales</span><span class="sxs-lookup"><span data-stu-id="de27b-153">Exceptional Postconditions</span></span>

<span data-ttu-id="de27b-154">Las condiciones posteriores excepcionales son condiciones posteriores que deberían ser `true` cuando un método genera una determinada excepción.</span><span class="sxs-lookup"><span data-stu-id="de27b-154">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="de27b-155">Estas condiciones posteriores se pueden especificar mediante el método <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="de27b-155">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="de27b-156">El argumento es la condición que debe ser `true` cada vez que se genera una excepción que es un subtipo de `T`.</span><span class="sxs-lookup"><span data-stu-id="de27b-156">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="de27b-157">Hay algunos tipos de excepciones que son difíciles de usar en una condición posterior excepcional.</span><span class="sxs-lookup"><span data-stu-id="de27b-157">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="de27b-158">Por ejemplo, para usar el tipo <xref:System.Exception> para `T` es necesario que el método garantice la condición con independencia del tipo de excepción que se genera, incluso si es un desbordamiento de pila u otra excepción imposible de controlar.</span><span class="sxs-lookup"><span data-stu-id="de27b-158">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="de27b-159">Las condiciones posteriores excepcionales deben usarse solo para excepciones concretas que puedan producirse cuando se llama a un miembro, por ejemplo, cuando se produce un <xref:System.InvalidTimeZoneException> para una llamada al método <xref:System.TimeZoneInfo>.</span><span class="sxs-lookup"><span data-stu-id="de27b-159">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="de27b-160">Condiciones posteriores especiales</span><span class="sxs-lookup"><span data-stu-id="de27b-160">Special Postconditions</span></span>

<span data-ttu-id="de27b-161">Los métodos siguientes pueden usarse únicamente dentro de condiciones posteriores:</span><span class="sxs-lookup"><span data-stu-id="de27b-161">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="de27b-162">La referencia a valores devueltos del método en condiciones posteriores se realiza mediante la expresión `Contract.Result<T>()`, donde `T` se sustituye por el tipo de valor devuelto del método.</span><span class="sxs-lookup"><span data-stu-id="de27b-162">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="de27b-163">Cuando el compilador no puede inferir el tipo, debe proporcionarse explícitamente.</span><span class="sxs-lookup"><span data-stu-id="de27b-163">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="de27b-164">Por ejemplo, el compilador de C# no puede inferir tipos para los métodos que no toman ningún argumento, por lo que requiere la siguiente condición posterior: `Contract.Ensures(0 <Contract.Result<int>())`. Los métodos con un tipo de valor devuelto de `void` no puede hacer referencia a `Contract.Result<T>()` en sus condiciones posteriores.</span><span class="sxs-lookup"><span data-stu-id="de27b-164">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="de27b-165">Un valor preindicado en una condición posterior hace referencia al valor de una expresión en el inicio de un método o propiedad.</span><span class="sxs-lookup"><span data-stu-id="de27b-165">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="de27b-166">Se usa la expresión `Contract.OldValue<T>(e)`, donde `T` es el tipo de `e`.</span><span class="sxs-lookup"><span data-stu-id="de27b-166">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="de27b-167">Puede omitir el argumento de tipo genérico siempre que el compilador pueda deducir su tipo.</span><span class="sxs-lookup"><span data-stu-id="de27b-167">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="de27b-168">(Por ejemplo, el compilador de C# siempre infiere el tipo porque toma un argumento). Existen varias restricciones sobre lo que puede ocurrir en `e` y los contextos en los que puede aparecer una expresión antigua.</span><span class="sxs-lookup"><span data-stu-id="de27b-168">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="de27b-169">Una expresión antigua no puede contener otra expresión antigua.</span><span class="sxs-lookup"><span data-stu-id="de27b-169">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="de27b-170">Lo más importante es que una expresión antigua debe hacer referencia a un valor que existía en el estado de condición previa del método.</span><span class="sxs-lookup"><span data-stu-id="de27b-170">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="de27b-171">En otras palabras, debe ser una expresión que pueda evaluarse siempre que la condición previa del método sea `true`.</span><span class="sxs-lookup"><span data-stu-id="de27b-171">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="de27b-172">A continuación se muestran varias instancias de esa regla.</span><span class="sxs-lookup"><span data-stu-id="de27b-172">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="de27b-173">El valor debe existir en el estado de condición previa del método.</span><span class="sxs-lookup"><span data-stu-id="de27b-173">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="de27b-174">Para hacer referencia a un campo en un objeto, las condiciones previas deben garantizar que el objeto siempre es distinto de NULL.</span><span class="sxs-lookup"><span data-stu-id="de27b-174">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="de27b-175">No es posible hacer referencia al valor devuelto del método en una expresión antigua:</span><span class="sxs-lookup"><span data-stu-id="de27b-175">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="de27b-176">No es posible hacer referencia a parámetros `out` en una expresión antigua.</span><span class="sxs-lookup"><span data-stu-id="de27b-176">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="de27b-177">Una expresión antigua no puede depender de la variable dependiente de un cuantificador si el intervalo del cuantificador depende del valor devuelto del método:</span><span class="sxs-lookup"><span data-stu-id="de27b-177">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="de27b-178">Una expresión antigua no puede hacer referencia al parámetro del delegado anónimo en una llamada <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> o <xref:System.Diagnostics.Contracts.Contract.Exists%2A> a menos que se use como indizador o argumento para una llamada al método:</span><span class="sxs-lookup"><span data-stu-id="de27b-178">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="de27b-179">Una expresión antigua no se puede realizar en el cuerpo de un delegado anónimo si el valor de la expresión antigua depende de cualquiera de los parámetros del delegado anónimo, a menos que el delegado anónimo sea un argumento para el método <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> o <xref:System.Diagnostics.Contracts.Contract.Exists%2A>:</span><span class="sxs-lookup"><span data-stu-id="de27b-179">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="de27b-180">Los parámetros `Out` presentan un problema porque los contratos aparecen antes del cuerpo del método y la mayoría de los compiladores no permite referencias a parámetros `out` en condiciones posteriores.</span><span class="sxs-lookup"><span data-stu-id="de27b-180">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="de27b-181">Para resolver este problema, la clase <xref:System.Diagnostics.Contracts.Contract> proporciona el método <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>, lo que permite una condición posterior basada en un parámetro `out`.</span><span class="sxs-lookup"><span data-stu-id="de27b-181">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="de27b-182">Al igual que con el método <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, puede omitir el parámetro de tipo genérico siempre que el compilador pueda deducir su tipo.</span><span class="sxs-lookup"><span data-stu-id="de27b-182">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="de27b-183">El sistema de reescritura del contrato reemplaza la llamada de método por el valor del parámetro `out`.</span><span class="sxs-lookup"><span data-stu-id="de27b-183">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="de27b-184">El método <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> solo aparece en las condiciones posteriores.</span><span class="sxs-lookup"><span data-stu-id="de27b-184">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="de27b-185">El argumento para el método debe ser un parámetro `out` o un campo de un parámetro `out` de estructura.</span><span class="sxs-lookup"><span data-stu-id="de27b-185">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="de27b-186">Este último también es útil cuando se hace referencia a los campos de la condición posterior de un constructor de estructura.</span><span class="sxs-lookup"><span data-stu-id="de27b-186">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="de27b-187">Actualmente, las herramientas de análisis de contrato de código no comprueban si los parámetros `out` se inicializan correctamente y desechan su mención en la condición posterior.</span><span class="sxs-lookup"><span data-stu-id="de27b-187">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="de27b-188">Por lo tanto, en el ejemplo anterior, si la línea después del contrato hubiera usado el valor de `x` en lugar de asignarle un entero, un compilador no emitiría el error correcto.</span><span class="sxs-lookup"><span data-stu-id="de27b-188">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="de27b-189">Pero en una compilación donde el símbolo de preprocesador CONTRACTS_FULL (por ejemplo, una compilación de versión) no está definido, el compilador emite un error.</span><span class="sxs-lookup"><span data-stu-id="de27b-189">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="de27b-190">Invariables</span><span class="sxs-lookup"><span data-stu-id="de27b-190">Invariants</span></span>

<span data-ttu-id="de27b-191">Las invariantes de objetos son condiciones que deben cumplirse para cada instancia de una clase siempre que ese objeto sea visible para un cliente.</span><span class="sxs-lookup"><span data-stu-id="de27b-191">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="de27b-192">Expresan las condiciones en las que el objeto se considera correcto.</span><span class="sxs-lookup"><span data-stu-id="de27b-192">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="de27b-193">Los métodos invariantes se identifican por estar marcados con el atributo <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>.</span><span class="sxs-lookup"><span data-stu-id="de27b-193">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="de27b-194">Los métodos invariantes no deben contener ningún código salvo una secuencia de llamadas al método <xref:System.Diagnostics.Contracts.Contract.Invariant%2A>, cada uno de los cuales especifica una invariante individual, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="de27b-194">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="de27b-195">Las invariantes se definen condicionalmente mediante el símbolo de preprocesador CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="de27b-195">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="de27b-196">Durante la comprobación en tiempo de ejecución, las invariantes se comprueban al final de cada método público.</span><span class="sxs-lookup"><span data-stu-id="de27b-196">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="de27b-197">Si una invariante menciona un método público en la misma clase, se deshabilita la comprobación de invariante que normalmente se produciría normalmente al final de ese método público.</span><span class="sxs-lookup"><span data-stu-id="de27b-197">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="de27b-198">En su lugar, la comprobación se produce solo al final de la llamada de método más externo a esa clase.</span><span class="sxs-lookup"><span data-stu-id="de27b-198">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="de27b-199">Esto también ocurre si la clase se vuelve a escribir debido a una llamada a un método en otra clase.</span><span class="sxs-lookup"><span data-stu-id="de27b-199">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="de27b-200">No se comprueban las invariables para un finalizador de objeto y una <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación de.</span><span class="sxs-lookup"><span data-stu-id="de27b-200">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="de27b-201">Instrucciones de uso</span><span class="sxs-lookup"><span data-stu-id="de27b-201">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="de27b-202">Clasificación de contratos</span><span class="sxs-lookup"><span data-stu-id="de27b-202">Contract Ordering</span></span>

<span data-ttu-id="de27b-203">En la tabla siguiente se muestra el orden de los elementos que debe usarse al escribir contratos de método.</span><span class="sxs-lookup"><span data-stu-id="de27b-203">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="de27b-204">Condiciones previas públicas compatibles con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="de27b-204">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="de27b-205">Todas las condiciones previas públicas.</span><span class="sxs-lookup"><span data-stu-id="de27b-205">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="de27b-206">Todas las condiciones posteriores públicas (normales).</span><span class="sxs-lookup"><span data-stu-id="de27b-206">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="de27b-207">Todas las condiciones posteriores públicas excepcionales.</span><span class="sxs-lookup"><span data-stu-id="de27b-207">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="de27b-208">Todas las condiciones posteriores privadas/internas (normales).</span><span class="sxs-lookup"><span data-stu-id="de27b-208">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="de27b-209">Todas las condiciones posteriores privadas/internas excepcionales.</span><span class="sxs-lookup"><span data-stu-id="de27b-209">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="de27b-210">Si usa condiciones previas de estilo `if`-`then`-`throw` sin ningún otro contrato, coloque una llamada a <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> para indicar que todas las comprobaciones if anteriores son requisitos previos.</span><span class="sxs-lookup"><span data-stu-id="de27b-210">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="de27b-211">Pureza</span><span class="sxs-lookup"><span data-stu-id="de27b-211">Purity</span></span>

<span data-ttu-id="de27b-212">Todos los métodos que se llaman dentro de un contrato deben ser puros, es decir, no deben actualizar ningún estado preexistente.</span><span class="sxs-lookup"><span data-stu-id="de27b-212">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="de27b-213">Un método puro puede modificar objetos que se han creado después de la entrada en el método puro.</span><span class="sxs-lookup"><span data-stu-id="de27b-213">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="de27b-214">Las herramientas de contratos de código asumen que los siguientes elementos de código son puros:</span><span class="sxs-lookup"><span data-stu-id="de27b-214">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="de27b-215">Métodos marcados con <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="de27b-215">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="de27b-216">Tipos marcados con <xref:System.Diagnostics.Contracts.PureAttribute> (el atributo se aplica a todos los métodos del tipo).</span><span class="sxs-lookup"><span data-stu-id="de27b-216">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="de27b-217">Descriptores de acceso get de propiedad.</span><span class="sxs-lookup"><span data-stu-id="de27b-217">Property get accessors.</span></span>

- <span data-ttu-id="de27b-218">Operadores (métodos estáticos cuyo nombre empieza por "op" y que tienen uno o dos parámetros y un tipo de valor devuelto distinto de void).</span><span class="sxs-lookup"><span data-stu-id="de27b-218">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="de27b-219">Cualquier método cuyo nombre completo empieza por "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path" o "System.Type".</span><span class="sxs-lookup"><span data-stu-id="de27b-219">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="de27b-220">Cualquier delegado invocado, siempre que el propio tipo delegado se atribuya con <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="de27b-220">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="de27b-221">Los tipos de delegado <xref:System.Predicate%601?displayProperty=nameWithType> y <xref:System.Comparison%601?displayProperty=nameWithType> se consideran puros.</span><span class="sxs-lookup"><span data-stu-id="de27b-221">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="de27b-222">Visibilidad</span><span class="sxs-lookup"><span data-stu-id="de27b-222">Visibility</span></span>

<span data-ttu-id="de27b-223">Todos los miembros mencionados en un contrato deben ser al menos tan visibles como el método en que aparecen.</span><span class="sxs-lookup"><span data-stu-id="de27b-223">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="de27b-224">Por ejemplo, un campo privado no se puede mencionar en una condición previa para un método público; los clientes no pueden validar el contrato antes de llamar al método.</span><span class="sxs-lookup"><span data-stu-id="de27b-224">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="de27b-225">Sin embargo, si el campo está marcado con <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, está exento de estas reglas.</span><span class="sxs-lookup"><span data-stu-id="de27b-225">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="de27b-226">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="de27b-226">Example</span></span>

<span data-ttu-id="de27b-227">En el siguiente ejemplo se muestra el uso de contratos de código.</span><span class="sxs-lookup"><span data-stu-id="de27b-227">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
