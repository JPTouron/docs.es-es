---
title: Copiar y fijar
description: Revise cómo el serializador de interoperabilidad puede copiar o anclar los datos que se están serializando. Copie los datos y coloque una copia de una ubicación de memoria en otra.
ms.date: 03/30/2017
helpviewer_keywords:
- pinning, interop marshaling
- copying, interop marshaling
- interop marshaling, copying
- interop marshaling, pinning
ms.assetid: 0059f576-e460-4e70-b257-668870e420b8
ms.openlocfilehash: b7931813cd5254375eda81515f388c85c78fa284
ms.sourcegitcommit: e02d17b2cf9c1258dadda4810a5e6072a0089aee
ms.contentlocale: es-ES
ms.lasthandoff: 07/01/2020
ms.locfileid: "85618784"
---
# <a name="copying-and-pinning"></a><span data-ttu-id="a18e0-104">Copiar y fijar</span><span class="sxs-lookup"><span data-stu-id="a18e0-104">Copying and Pinning</span></span>

<span data-ttu-id="a18e0-105">Al serializar datos, el serializador de interoperabilidad puede copiar o anclar los datos que se van a serializar.</span><span class="sxs-lookup"><span data-stu-id="a18e0-105">When marshaling data, the interop marshaler can copy or pin the data being marshaled.</span></span> <span data-ttu-id="a18e0-106">Copiar los datos coloca una copia de datos desde una ubicación de memoria en otra.</span><span class="sxs-lookup"><span data-stu-id="a18e0-106">Copying the data places a copy of data from one memory location in another memory location.</span></span> <span data-ttu-id="a18e0-107">En la siguiente ilustración se muestran las diferencias entre copiar un tipo de valor y copiar un tipo pasado por referencia de memoria administrada a memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-107">The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.</span></span>

![Diagrama que muestra cómo se copian los tipos de referencia y valor.](./media/copying-and-pinning/interop-marshal-copy.gif)

<span data-ttu-id="a18e0-109">Los argumentos de método pasados por valor se serializan en código no administrado como valores de la pila.</span><span class="sxs-lookup"><span data-stu-id="a18e0-109">Method arguments passed by value are marshaled to unmanaged code as values on the stack.</span></span> <span data-ttu-id="a18e0-110">El proceso de copia es directo.</span><span class="sxs-lookup"><span data-stu-id="a18e0-110">The copying process is direct.</span></span> <span data-ttu-id="a18e0-111">Los argumentos que se pasan por referencia se pasan como punteros en la pila.</span><span class="sxs-lookup"><span data-stu-id="a18e0-111">Arguments passed by reference are passed as pointers on the stack.</span></span> <span data-ttu-id="a18e0-112">Los tipos de referencia también se pasan por valor y por referencia.</span><span class="sxs-lookup"><span data-stu-id="a18e0-112">Reference types are also passed by value and by reference.</span></span> <span data-ttu-id="a18e0-113">Como se muestra en la siguiente ilustración, los tipos de referencia pasados por valor se copian o se anclan:</span><span class="sxs-lookup"><span data-stu-id="a18e0-113">As the following illustration shows, reference types passed by value are either copied or pinned:</span></span>

![Diagrama que muestra los tipos de referencia pasados por valor y por referencia.](./media/copying-and-pinning/interop-marshal-reference-pin.gif)

<span data-ttu-id="a18e0-115">Anclar bloquea temporalmente los datos en su ubicación de memoria actual, lo que evita que el recolector de elementos no utilizados de Common Language Runtime los reubique.</span><span class="sxs-lookup"><span data-stu-id="a18e0-115">Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector.</span></span> <span data-ttu-id="a18e0-116">El serializador ancla los datos para reducir la sobrecarga de la copia y mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a18e0-116">The marshaler pins data to reduce the overhead of copying and enhance performance.</span></span> <span data-ttu-id="a18e0-117">El tipo de los datos determina si se copian o se anclan durante el proceso de serialización.</span><span class="sxs-lookup"><span data-stu-id="a18e0-117">The type of the data determines whether it is copied or pinned during the marshaling process.</span></span>  <span data-ttu-id="a18e0-118">El anclaje se realiza automáticamente durante la serialización para objetos como <xref:System.String>, pero también se puede anclar manualmente la memoria mediante la clase <xref:System.Runtime.InteropServices.GCHandle>.</span><span class="sxs-lookup"><span data-stu-id="a18e0-118">Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class.</span></span>

## <a name="formatted-blittable-classes"></a><span data-ttu-id="a18e0-119">Clases que pueden transferirse en bloque de bits con formato</span><span class="sxs-lookup"><span data-stu-id="a18e0-119">Formatted Blittable Classes</span></span>

<span data-ttu-id="a18e0-120">Las clases [que pueden transferirse en bloque de bits](blittable-and-non-blittable-types.md) con formato tienen una distribución (con formato) y representación común de datos fijas tanto en la memoria administrada como no administrada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-120">Formatted [blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory.</span></span> <span data-ttu-id="a18e0-121">Cuando estos tipos requieren serialización, se pasa directamente un puntero al objeto en el montón al destinatario de la llamada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-121">When these types require marshaling, a pointer to the object in the heap is passed to the callee directly.</span></span> <span data-ttu-id="a18e0-122">El destinatario de la llamada puede cambiar el contenido de la ubicación de memoria a la que hace referencia el puntero.</span><span class="sxs-lookup"><span data-stu-id="a18e0-122">The callee can change the contents of the memory location being referenced by the pointer.</span></span>

> [!NOTE]
> <span data-ttu-id="a18e0-123">El destinatario puede cambiar el contenido de la memoria si el parámetro está marcado como Out o In/Out. En cambio, el destinatario debe evitar cambiar el contenido cuando el parámetro se establece para serializarse como In, que es el valor predeterminado para tipos que pueden transferirse en bloque de bits.</span><span class="sxs-lookup"><span data-stu-id="a18e0-123">The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types.</span></span> <span data-ttu-id="a18e0-124">Modificar un objeto In genera problemas cuando se exporta la misma clase a una biblioteca de tipos y se usa para realizar llamadas entre contenedores.</span><span class="sxs-lookup"><span data-stu-id="a18e0-124">Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.</span></span>

## <a name="formatted-non-blittable-classes"></a><span data-ttu-id="a18e0-125">Clases que no pueden transferirse en bloque de bits con formato</span><span class="sxs-lookup"><span data-stu-id="a18e0-125">Formatted Non-Blittable Classes</span></span>

<span data-ttu-id="a18e0-126">Las clases [que no pueden transferirse en bloque de bits](blittable-and-non-blittable-types.md) con formato tienen una distribución fija (con formato) pero la representación de datos es diferente en la memoria administrada y la no administrada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-126">Formatted [non-blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory.</span></span> <span data-ttu-id="a18e0-127">Los datos pueden requerir transformación en las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="a18e0-127">The data can require transformation under the following conditions:</span></span>

- <span data-ttu-id="a18e0-128">Si una clase que no puede transferirse en bloque de bits se serializa por valor, el destinatario de la llamada recibe un puntero a una copia de la estructura de datos.</span><span class="sxs-lookup"><span data-stu-id="a18e0-128">If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="a18e0-129">Si una clase que no puede transferirse en bloque de bits se serializa por referencia, el destinatario de la llamada recibe un puntero a un puntero a una copia de la estructura de datos.</span><span class="sxs-lookup"><span data-stu-id="a18e0-129">If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="a18e0-130">Si se establece el atributo <xref:System.Runtime.InteropServices.InAttribute>, esta copia siempre se inicializa con el estado de la instancia, y se serializa según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="a18e0-130">If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.</span></span>

- <span data-ttu-id="a18e0-131">Si se establece el atributo <xref:System.Runtime.InteropServices.OutAttribute>, el estado siempre se copia de vuelta en la instancia, y se serializa según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="a18e0-131">If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.</span></span>

- <span data-ttu-id="a18e0-132">Si se establecen **InAttribute** y **OutAttribute**, se requieren ambas copias.</span><span class="sxs-lookup"><span data-stu-id="a18e0-132">If both **InAttribute** and **OutAttribute** are set, both copies are required.</span></span> <span data-ttu-id="a18e0-133">Si se omite uno de los atributos, el serializador puede optimizar mediante la eliminación de cualquiera de las copias.</span><span class="sxs-lookup"><span data-stu-id="a18e0-133">If either attribute is omitted, the marshaler can optimize by eliminating either copy.</span></span>

## <a name="reference-types"></a><span data-ttu-id="a18e0-134">Tipos de referencia</span><span class="sxs-lookup"><span data-stu-id="a18e0-134">Reference Types</span></span>

<span data-ttu-id="a18e0-135">Los tipos de referencia se pueden pasar por valor o por referencia.</span><span class="sxs-lookup"><span data-stu-id="a18e0-135">Reference types can be passed by value or by reference.</span></span> <span data-ttu-id="a18e0-136">Cuando se pasan por valor, se pasa un puntero al tipo en la pila.</span><span class="sxs-lookup"><span data-stu-id="a18e0-136">When they are passed by value, a pointer to the type is passed on the stack.</span></span> <span data-ttu-id="a18e0-137">Cuando se pasan por referencia, se pasa un puntero a un puntero al tipo en la pila.</span><span class="sxs-lookup"><span data-stu-id="a18e0-137">When passed by reference, a pointer to a pointer to the type is passed on the stack.</span></span>

<span data-ttu-id="a18e0-138">Los tipos de referencia tienen el siguiente comportamiento condicional:</span><span class="sxs-lookup"><span data-stu-id="a18e0-138">Reference types have the following conditional behavior:</span></span>

- <span data-ttu-id="a18e0-139">Si un tipo de referencia se pasa por valor y tiene miembros de tipos que no pueden transferirse en bloque de bits, los tipos se convierten dos veces:</span><span class="sxs-lookup"><span data-stu-id="a18e0-139">If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:</span></span>

  - <span data-ttu-id="a18e0-140">Cuando se pasa un argumento al lado no administrado.</span><span class="sxs-lookup"><span data-stu-id="a18e0-140">When an argument is passed to the unmanaged side.</span></span>

  - <span data-ttu-id="a18e0-141">En la devolución de la llamada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-141">On return from the call.</span></span>

  <span data-ttu-id="a18e0-142">Para evitar copias y conversiones innecesarias, estos tipos se serializan como parámetros In.</span><span class="sxs-lookup"><span data-stu-id="a18e0-142">To avoid unnecessarily copying and conversion, these types are marshaled as In parameters.</span></span> <span data-ttu-id="a18e0-143">Debe aplicar explícitamente los atributos **InAttribute** y **OutAttribute** a un argumento para que el autor de la llamada vea los cambios realizados por el destinatario.</span><span class="sxs-lookup"><span data-stu-id="a18e0-143">You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee.</span></span>

- <span data-ttu-id="a18e0-144">Si un tipo de referencia se pasa por valor y solo tiene miembros de tipos que pueden transferirse en bloque de bits, se puede anclar durante la serialización y el autor de la llamada verá cualquier cambio realizado en los miembros del tipo por el destinatario.</span><span class="sxs-lookup"><span data-stu-id="a18e0-144">If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller.</span></span> <span data-ttu-id="a18e0-145">Aplique **InAttribute** y **OutAttribute** explícitamente si quiere este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="a18e0-145">Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior.</span></span> <span data-ttu-id="a18e0-146">Sin estos atributos direccionales, el serializador de interoperabilidad no exporta información direccional a la biblioteca de tipos (se exporta como In, que es el valor predeterminado) y esto puede causar problemas con la serialización COM entre contenedores.</span><span class="sxs-lookup"><span data-stu-id="a18e0-146">Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.</span></span>

- <span data-ttu-id="a18e0-147">Si un tipo de referencia se pasa por referencia, se serializará como In/Out de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-147">If a reference type is passed by reference, it will be marshaled as In/Out by default.</span></span>

## <a name="systemstring-and-systemtextstringbuilder"></a><span data-ttu-id="a18e0-148">System.String y System.Text.StringBuilder</span><span class="sxs-lookup"><span data-stu-id="a18e0-148">System.String and System.Text.StringBuilder</span></span>

<span data-ttu-id="a18e0-149">Cuando los datos se serializan en código no administrado por valor o por referencia, el serializador normalmente copia los datos en un búfer secundario (y posiblemente convierte los juegos de caracteres durante la copia) y pasa una referencia al búfer al destinatario de la llamada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-149">When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee.</span></span> <span data-ttu-id="a18e0-150">A menos que la referencia sea un **BSTR** asignado con **SysAllocString**, la referencia siempre se asigna con **CoTaskMemAlloc**.</span><span class="sxs-lookup"><span data-stu-id="a18e0-150">Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**.</span></span>

<span data-ttu-id="a18e0-151">Como una optimización cuando se serializa por valor cualquier tipo de cadena (por ejemplo, una cadena de caracteres Unicode), el serializador pasa al destinatario de la llamada un puntero directo a las cadenas administradas en el búfer interno de Unicode en lugar de copiarlo en un búfer nuevo.</span><span class="sxs-lookup"><span data-stu-id="a18e0-151">As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.</span></span>

> [!CAUTION]
> <span data-ttu-id="a18e0-152">Cuando se pasa una cadena por valor, el destinatario nunca debe modificar la referencia que pasa el serializador.</span><span class="sxs-lookup"><span data-stu-id="a18e0-152">When a string is passed by value, the callee must never alter the reference passed by the marshaler.</span></span> <span data-ttu-id="a18e0-153">Esto puede dañar el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="a18e0-153">Doing so can corrupt the managed heap.</span></span>

<span data-ttu-id="a18e0-154">Cuando se pasa <xref:System.String?displayProperty=nameWithType> por referencia, el serializador copia el contenido de la cadena en un búfer secundario antes de realizar la llamada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-154">When a <xref:System.String?displayProperty=nameWithType> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call.</span></span> <span data-ttu-id="a18e0-155">Después, copia el contenido del búfer en una nueva cadena en la devolución de la llamada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-155">It then copies the contents of the buffer into a new string on return from the call.</span></span> <span data-ttu-id="a18e0-156">Esta técnica garantiza que la cadena administrada inmutable permanece sin modificar.</span><span class="sxs-lookup"><span data-stu-id="a18e0-156">This technique ensures that the immutable managed string remains unaltered.</span></span>

<span data-ttu-id="a18e0-157">Cuando se pasa <xref:System.Text.StringBuilder?displayProperty=nameWithType> por valor, el serializador pasa una referencia al búfer interno de **StringBuilder** directamente al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-157">When a <xref:System.Text.StringBuilder?displayProperty=nameWithType> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller.</span></span> <span data-ttu-id="a18e0-158">El autor de la llamada y el destinatario deben acordar el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="a18e0-158">The caller and callee must agree on the size of the buffer.</span></span> <span data-ttu-id="a18e0-159">El autor de la llamada es responsable de crear un **StringBuilder** de la longitud adecuada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-159">The caller is responsible for creating a **StringBuilder** of adequate length.</span></span> <span data-ttu-id="a18e0-160">El destinatario debe tomar las precauciones necesarias para asegurarse de que el búfer no se desborda.</span><span class="sxs-lookup"><span data-stu-id="a18e0-160">The callee must take the necessary precautions to ensure that the buffer is not overrun.</span></span> <span data-ttu-id="a18e0-161">**StringBuilder** es una excepción a la regla de que los tipos de referencia que se pasan por valor se pasan como parámetros In de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a18e0-161">**StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default.</span></span> <span data-ttu-id="a18e0-162">Siempre se pasa como In/Out.</span><span class="sxs-lookup"><span data-stu-id="a18e0-162">It is always passed as In/Out.</span></span>

## <a name="see-also"></a><span data-ttu-id="a18e0-163">Vea también</span><span class="sxs-lookup"><span data-stu-id="a18e0-163">See also</span></span>

- [<span data-ttu-id="a18e0-164">Comportamiento predeterminado del cálculo de referencias</span><span class="sxs-lookup"><span data-stu-id="a18e0-164">Default Marshaling Behavior</span></span>](default-marshaling-behavior.md)
- <span data-ttu-id="a18e0-165">[Atributos direccionales](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="a18e0-165">[Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span></span>
- [<span data-ttu-id="a18e0-166">Serialización de interoperabilidad</span><span class="sxs-lookup"><span data-stu-id="a18e0-166">Interop Marshaling</span></span>](interop-marshaling.md)
