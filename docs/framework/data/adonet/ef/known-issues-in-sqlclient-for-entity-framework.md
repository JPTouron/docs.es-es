---
title: Problemas conocidos en SqlClient para Entity Framework
ms.date: 03/30/2017
ms.assetid: 48fe4912-4d0f-46b6-be96-3a42c54780f6
ms.openlocfilehash: 707c749e4dff5d1bbc8d372632aae502092db060
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/24/2020
ms.locfileid: "91198111"
---
# <a name="known-issues-in-sqlclient-for-entity-framework"></a><span data-ttu-id="369f2-102">Problemas conocidos en SqlClient para Entity Framework</span><span class="sxs-lookup"><span data-stu-id="369f2-102">Known Issues in SqlClient for Entity Framework</span></span>

<span data-ttu-id="369f2-103">En esta sección se describen problemas conocidos relacionados con el proveedor de datos .NET Framework para SQL Server (SqlClient).</span><span class="sxs-lookup"><span data-stu-id="369f2-103">This section describes known issues related to the .NET Framework Data Provider for SQL Server (SqlClient).</span></span>  
  
## <a name="trailing-spaces-in-string-functions"></a><span data-ttu-id="369f2-104">Espacios finales en funciones de cadena</span><span class="sxs-lookup"><span data-stu-id="369f2-104">Trailing Spaces in String Functions</span></span>  

 <span data-ttu-id="369f2-105">SQL Server omite los espacios finales en los valores de cadena.</span><span class="sxs-lookup"><span data-stu-id="369f2-105">SQL Server ignores trailing spaces in string values.</span></span> <span data-ttu-id="369f2-106">Por consiguiente, al pasar espacios finales en una cadena, se pueden producir resultados imprevisibles, incluso errores.</span><span class="sxs-lookup"><span data-stu-id="369f2-106">Therefore, passing trailing spaces in the string can lead to unpredictable results, even failures.</span></span>  
  
 <span data-ttu-id="369f2-107">Si tiene que tener espacios finales en la cadena, considere la posibilidad de anexar un carácter de espacio en blanco al final, de modo que SQL Server no recorte la cadena.</span><span class="sxs-lookup"><span data-stu-id="369f2-107">If you have to have trailing spaces in your string, you should consider appending a white space character at the end, so that SQL Server does not trim the string.</span></span> <span data-ttu-id="369f2-108">Si no se requieren los espacios finales, se deberían recortar antes de pasarse a la canalización de la consulta.</span><span class="sxs-lookup"><span data-stu-id="369f2-108">If the trailing spaces are not required, they should be trimmed before they are passed down the query pipeline.</span></span>  
  
## <a name="right-function"></a><span data-ttu-id="369f2-109">Función RIGHT</span><span class="sxs-lookup"><span data-stu-id="369f2-109">RIGHT Function</span></span>  

 <span data-ttu-id="369f2-110">Si se pasa un valor no `null` como primer argumento y se pasa 0 como segundo argumento a la función `RIGHT(nvarchar(max)`, 0`)` o `RIGHT(varchar(max)`, 0`)`, se devolverá un valor `NULL` en lugar de una cadena `empty`.</span><span class="sxs-lookup"><span data-stu-id="369f2-110">If a non-`null` value is passed as a first argument and 0 is passed as a second argument to `RIGHT(nvarchar(max)`, 0`)` or `RIGHT(varchar(max)`, 0`)`, a `NULL` value will be returned instead of an `empty` string.</span></span>  
  
## <a name="cross-and-outer-apply-operators"></a><span data-ttu-id="369f2-111">Operadores CROSS APPLY y OUTER APPLY</span><span class="sxs-lookup"><span data-stu-id="369f2-111">CROSS and OUTER APPLY Operators</span></span>  

 <span data-ttu-id="369f2-112">Los operadores CROSS APPLY y OUTER APPLY se introdujeron en SQL Server 2005.</span><span class="sxs-lookup"><span data-stu-id="369f2-112">CROSS and OUTER APPLY operators were introduced in SQL Server 2005.</span></span> <span data-ttu-id="369f2-113">En algunos casos, la canalización de la consulta podría generar una instrucción de Transact-SQL que contenga los operadores CROSS APPLY y/o OUTER APPLY.</span><span class="sxs-lookup"><span data-stu-id="369f2-113">In some cases the query pipeline might produce a Transact-SQL statement that contains CROSS APPLY and/or OUTER APPLY operators.</span></span> <span data-ttu-id="369f2-114">Dado que algunos proveedores de back-end, incluidas las versiones de SQL Server anteriores a SQL Server 2005, no admiten estos operadores, tales consultas no se pueden ejecutar en estos proveedores de back-end.</span><span class="sxs-lookup"><span data-stu-id="369f2-114">Because some backend providers, including versions of SQL Server earlier than SQL Server 2005, do not support these operators, such queries cannot be executed on these backend providers.</span></span>  
  
 <span data-ttu-id="369f2-115">A continuación se ilustran escenarios típicos que podrían conducir a la presencia de los operadores CROSS APPLY y/o OUTER APPLY en la consulta de salida:</span><span class="sxs-lookup"><span data-stu-id="369f2-115">The following are some typical scenarios that might lead to the presence of CROSS APPLY and/or OUTER APPLY operators in the output query:</span></span>  
  
- <span data-ttu-id="369f2-116">Una subconsulta correlacionada con paginación.</span><span class="sxs-lookup"><span data-stu-id="369f2-116">A correlated subquery with paging.</span></span>  
  
- <span data-ttu-id="369f2-117">Un `AnyElement` sobre una subconsulta correlacionada o sobre una colección generada mediante navegación.</span><span class="sxs-lookup"><span data-stu-id="369f2-117">An `AnyElement` over a correlated sub-query, or over a collection produced by navigation.</span></span>  
  
- <span data-ttu-id="369f2-118">Consultas de LINQ que utilizan métodos de agrupación que aceptan un selector de elemento.</span><span class="sxs-lookup"><span data-stu-id="369f2-118">LINQ queries that use grouping methods that accept an element selector.</span></span>  
  
- <span data-ttu-id="369f2-119">Una consulta en la que se especifica explícitamente un operador CROSS APPLY u OUTER APPLY</span><span class="sxs-lookup"><span data-stu-id="369f2-119">A query in which a CROSS APPLY or an OUTER APPLY is explicitly specified</span></span>  
  
- <span data-ttu-id="369f2-120">Una consulta que tiene una construcción DEREF sobre una construcción REF.</span><span class="sxs-lookup"><span data-stu-id="369f2-120">A query that has a DEREF construct over a REF construct.</span></span>  
  
## <a name="skip-operator"></a><span data-ttu-id="369f2-121">Operador SKIP</span><span class="sxs-lookup"><span data-stu-id="369f2-121">SKIP Operator</span></span>  

 <span data-ttu-id="369f2-122">Si usa SQL Server 2000, el uso de SKIP con ORDER BY en columnas que no son de clave puede devolver resultados incorrectos.</span><span class="sxs-lookup"><span data-stu-id="369f2-122">If you are using SQL Server 2000, using SKIP with ORDER BY on non-key columns might return incorrect results.</span></span> <span data-ttu-id="369f2-123">Se puede omitir un número superior al número especificado de filas si la columna sin clave tiene datos duplicados en ella.</span><span class="sxs-lookup"><span data-stu-id="369f2-123">More than the specified number of rows might be skipped if the non-key column has duplicate data in it.</span></span> <span data-ttu-id="369f2-124">Esto se debe a la forma en que se traduce SKIP para SQL Server 2000.</span><span class="sxs-lookup"><span data-stu-id="369f2-124">This is due to how SKIP is translated for SQL Server 2000.</span></span> <span data-ttu-id="369f2-125">Por ejemplo, en la consulta siguiente, se pueden omitir más de cinco filas si `E.NonKeyColumn` tiene valores duplicados:</span><span class="sxs-lookup"><span data-stu-id="369f2-125">For example, in the following query, more than five rows might be skipped if `E.NonKeyColumn` has duplicate values:</span></span>  
  
```sql  
SELECT [E] FROM Container.EntitySet AS [E] ORDER BY [E].[NonKeyColumn] DESC SKIP 5L  
```  
  
## <a name="targeting-the-correct-sql-server-version"></a><span data-ttu-id="369f2-126">Cuál es la versión correcta de SQL Server</span><span class="sxs-lookup"><span data-stu-id="369f2-126">Targeting the Correct SQL Server Version</span></span>  

 <span data-ttu-id="369f2-127">La Entity Framework tiene como destino la consulta Transact-SQL basada en la versión SQL Server que se especifica en el `ProviderManifestToken` atributo del elemento Schema en el archivo de modelo de almacenamiento (. SSDL).</span><span class="sxs-lookup"><span data-stu-id="369f2-127">The Entity Framework targets the Transact-SQL query based on the SQL Server version that is specified in the `ProviderManifestToken` attribute of the Schema element in the storage model (.ssdl) file.</span></span> <span data-ttu-id="369f2-128">Esta versión podría diferir de la versión de SQL Server real al que está conectado.</span><span class="sxs-lookup"><span data-stu-id="369f2-128">This version might differ from the version of the actual SQL Server you are connected to.</span></span> <span data-ttu-id="369f2-129">Por ejemplo, si utiliza SQL Server 2005, pero el `ProviderManifestToken` atributo está establecido en 2008, la consulta Transact-SQL generada podría no ejecutarse en el servidor.</span><span class="sxs-lookup"><span data-stu-id="369f2-129">For example, if you are using SQL Server 2005, but your `ProviderManifestToken` attribute is set to 2008, the generated Transact-SQL query might not execute on the server.</span></span> <span data-ttu-id="369f2-130">Por ejemplo, una consulta que use los nuevos tipos de fecha y hora que se incluyeron en SQL Server 2008 no se ejecutará en las versiones anteriores de SQL Server.</span><span class="sxs-lookup"><span data-stu-id="369f2-130">For example, a query that uses the new date time types that were introduced in SQL Server 2008 will not execute on earlier versions of the SQL Server.</span></span> <span data-ttu-id="369f2-131">Si utiliza SQL Server 2005, pero el `ProviderManifestToken` atributo está establecido en 2000, la consulta Transact-SQL generada podría estar menos optimizada, o podría obtener una excepción que indica que no se admite la consulta.</span><span class="sxs-lookup"><span data-stu-id="369f2-131">If you are using SQL Server 2005, but your `ProviderManifestToken` attribute is set to 2000, the generated Transact-SQL query might be less optimized, or you might get an exception that says that the query is not supported.</span></span> <span data-ttu-id="369f2-132">Para obtener más información, vea la sección Operadores CROSS APPLY y OUTER APPLY, anteriormente en este tema.</span><span class="sxs-lookup"><span data-stu-id="369f2-132">For more information, see the CROSS and OUTER APPLY Operators section, earlier in this topic.</span></span>  
  
 <span data-ttu-id="369f2-133">Ciertos comportamientos de las bases de datos dependen del nivel de compatibilidad establecida en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="369f2-133">Certain database behaviors depend on the compatibility level set to the database.</span></span> <span data-ttu-id="369f2-134">Si el `ProviderManifestToken` atributo se establece en 2005 y la versión SQL Server es 2005, pero el nivel de compatibilidad de una base de datos se establece en "80" (SQL Server 2000), el valor de Transact-SQL generado será SQL Server 2005, pero es posible que no se ejecute según lo esperado debido a la configuración del nivel de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="369f2-134">If your `ProviderManifestToken` attribute is set to 2005 and your SQL Server version is 2005, but the compatibility level of a database is set to "80" (SQL Server 2000), the generated Transact-SQL will be targeting SQL Server 2005, but might not execute as expected due to the compatibility level setting.</span></span> <span data-ttu-id="369f2-135">Por ejemplo, podría perder la información de los pedidos si un nombre de columna de la lista ORDER BY coincide con un nombre de columna en el selector.</span><span class="sxs-lookup"><span data-stu-id="369f2-135">For example, you might lose ordering information if a column name in the ORDER BY list matches a column name in the selector.</span></span>  
  
## <a name="nested-queries-in-projection"></a><span data-ttu-id="369f2-136">Consultas anidadas en proyección</span><span class="sxs-lookup"><span data-stu-id="369f2-136">Nested Queries in Projection</span></span>  

 <span data-ttu-id="369f2-137">Las consultas anidadas en una cláusula de proyección se podrían traducir en consultas de producto cartesiano en el servidor.</span><span class="sxs-lookup"><span data-stu-id="369f2-137">Nested queries in a projection clause might get translated into Cartesian product queries on the server.</span></span> <span data-ttu-id="369f2-138">En algunos servidores back-end, incluido SQL Server, esto puede hacer que la tabla TempDB sea bastante grande.</span><span class="sxs-lookup"><span data-stu-id="369f2-138">On some back-end servers, including SQL Server, this can cause the TempDB table to get quite large.</span></span> <span data-ttu-id="369f2-139">Esto puede hacer que disminuya el rendimiento del servidor.</span><span class="sxs-lookup"><span data-stu-id="369f2-139">This can decrease server performance.</span></span>  
  
 <span data-ttu-id="369f2-140">El siguiente es un ejemplo de una consulta anidada en una cláusula de proyección:</span><span class="sxs-lookup"><span data-stu-id="369f2-140">The following is an example of a nested query in a projection clause:</span></span>  
  
```sql  
SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2 FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1 FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
```  
  
## <a name="server-generated-guid-identity-values"></a><span data-ttu-id="369f2-141">Valores de identidad de GUID generados por el servidor</span><span class="sxs-lookup"><span data-stu-id="369f2-141">Server Generated GUID Identity Values</span></span>  

 <span data-ttu-id="369f2-142">El Entity Framework admite valores de identidad de tipo GUID generados por el servidor, pero el proveedor debe admitir que se devuelva el valor de identidad generado por el servidor después de insertar una fila.</span><span class="sxs-lookup"><span data-stu-id="369f2-142">The Entity Framework supports server-generated GUID type identity values, but the provider must support returning the server-generated identity value after a row was inserted.</span></span> <span data-ttu-id="369f2-143">A partir de SQL Server 2005, puede devolver el tipo GUID generado por el servidor en una base de datos SQL Server mediante la [cláusula OUTPUT](/sql/t-sql/queries/output-clause-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="369f2-143">Starting with SQL Server 2005, you can return the server-generated GUID type in a SQL Server database through the [OUTPUT clause](/sql/t-sql/queries/output-clause-transact-sql).</span></span>
  
## <a name="see-also"></a><span data-ttu-id="369f2-144">Consulte también</span><span class="sxs-lookup"><span data-stu-id="369f2-144">See also</span></span>

- [<span data-ttu-id="369f2-145">SqlClient para Entity Framework</span><span class="sxs-lookup"><span data-stu-id="369f2-145">SqlClient for the Entity Framework</span></span>](sqlclient-for-the-entity-framework.md)
- [<span data-ttu-id="369f2-146">Problemas conocidos y consideraciones en LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="369f2-146">Known Issues and Considerations in LINQ to Entities</span></span>](./language-reference/known-issues-and-considerations-in-linq-to-entities.md)
