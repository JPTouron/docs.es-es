---
title: Rellenar un conjunto de datos desde un objeto DataAdapter
description: Obtenga información sobre cómo rellenar un conjunto de datos desde un DataAdapter en ADO.NET, que proporciona un modelo de programación relacional coherente independiente del origen de datos.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3fa0ac7d-e266-4954-bfac-3fbe2f913153
ms.openlocfilehash: ac84af884238b166266d4206802878c1e21169fd
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/24/2020
ms.locfileid: "91177415"
---
# <a name="populating-a-dataset-from-a-dataadapter"></a><span data-ttu-id="d3e13-103">Rellenar un conjunto de datos desde un objeto DataAdapter</span><span class="sxs-lookup"><span data-stu-id="d3e13-103">Populating a DataSet from a DataAdapter</span></span>

<span data-ttu-id="d3e13-104">ADO.NET <xref:System.Data.DataSet> es una representación residente en memoria de los datos que proporciona un modelo de programación relacional coherente independiente del origen de datos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-104">The ADO.NET <xref:System.Data.DataSet> is a memory-resident representation of data that provides a consistent relational programming model independent of the data source.</span></span> <span data-ttu-id="d3e13-105">`DataSet` representa un conjunto completo de datos que incluye tablas, restricciones y relaciones entre las tablas.</span><span class="sxs-lookup"><span data-stu-id="d3e13-105">The `DataSet` represents a complete set of data that includes tables, constraints, and relationships among the tables.</span></span> <span data-ttu-id="d3e13-106">Dado que `DataSet` es independiente del origen de datos, `DataSet` puede incluir datos locales de la aplicación y datos de otros muchos orígenes.</span><span class="sxs-lookup"><span data-stu-id="d3e13-106">Because the `DataSet` is independent of the data source, a `DataSet` can include data local to the application, and data from multiple data sources.</span></span> <span data-ttu-id="d3e13-107">La interacción con los orígenes de datos existentes se controla mediante el `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-107">Interaction with existing data sources is controlled through the `DataAdapter`.</span></span>  
  
 <span data-ttu-id="d3e13-108">La propiedad `SelectCommand` de `DataAdapter` es un objeto `Command` que recupera datos del origen de datos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-108">The `SelectCommand` property of the `DataAdapter` is a `Command` object that retrieves data from the data source.</span></span> <span data-ttu-id="d3e13-109">Las propiedades `InsertCommand`, `UpdateCommand`y `DeleteCommand` de `DataAdapter` son objetos `Command` que permiten administrar las actualizaciones de los datos en el origen de datos para reflejar las modificaciones efectuadas en los datos de `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-109">The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties of the `DataAdapter` are `Command` objects that manage updates to the data in the data source according to modifications made to the data in the `DataSet`.</span></span> <span data-ttu-id="d3e13-110">Estas propiedades se describen con más detalle en [Actualizar orígenes de datos con DataAdapters](updating-data-sources-with-dataadapters.md).</span><span class="sxs-lookup"><span data-stu-id="d3e13-110">These properties are covered in more detail in [Updating Data Sources with DataAdapters](updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="d3e13-111">El método `Fill` de `DataAdapter` se usa para rellenar un objeto `DataSet` con los resultados del elemento `SelectCommand` de `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-111">The `Fill` method of the `DataAdapter` is used to populate a `DataSet` with the results of the `SelectCommand` of the `DataAdapter`.</span></span> <span data-ttu-id="d3e13-112">`Fill` toma como argumentos un elemento `DataSet` que se debe rellenar y un objeto `DataTable` o el nombre del objeto `DataTable` que se debe rellenar con las filas que devuelve `SelectCommand`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-112">`Fill` takes as its arguments a `DataSet` to be populated, and a `DataTable` object, or the name of the `DataTable` to be filled with the rows returned from the `SelectCommand`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d3e13-113">El uso de `DataAdapter` para recuperar la totalidad de una tabla lleva tiempo, en especial si la tabla incluye un gran número de filas.</span><span class="sxs-lookup"><span data-stu-id="d3e13-113">Using the `DataAdapter` to retrieve all of a table takes time, especially if there are many rows in the table.</span></span> <span data-ttu-id="d3e13-114">Esto se debe a que el acceso a la base de datos, la localización y el procesamiento de los datos, y la posterior transferencia de los mismos al cliente son procesos largos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-114">This is because accessing the database, locating and processing the data, and then transferring the data to the client is time-consuming.</span></span> <span data-ttu-id="d3e13-115">La extracción de la tabla completa al cliente también bloquea todas las filas en el servidor.</span><span class="sxs-lookup"><span data-stu-id="d3e13-115">Pulling all of the table to the client also locks all of the rows on the server.</span></span> <span data-ttu-id="d3e13-116">Para mejorar el rendimiento, puede usar la cláusula `WHERE` para reducir en gran medida el número de filas que se devuelven al cliente.</span><span class="sxs-lookup"><span data-stu-id="d3e13-116">To improve performance, you can use the `WHERE` clause to greatly reduce the number of rows returned to the client.</span></span> <span data-ttu-id="d3e13-117">También puede reducir la cantidad de datos que se devuelven al cliente si enumera de forma explícita las columnas necesarias en la instrucción `SELECT` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-117">You can also reduce the amount of data returned to the client by only explicitly listing required columns in the `SELECT` statement.</span></span> <span data-ttu-id="d3e13-118">Otra solución consiste en recuperar las filas por lotes (por ejemplo varios cientos de filas de una vez) y recuperar solo el siguiente lote cuando el cliente haya finalizado con el lote actual.</span><span class="sxs-lookup"><span data-stu-id="d3e13-118">Another good workaround is to retrieve the rows in batches (such as several hundred rows at a time) and only retrieve the next batch when the client is finished with the current batch.</span></span>  
  
 <span data-ttu-id="d3e13-119">El método `Fill` utiliza el objeto `DataReader` de forma implícita para devolver los nombres y tipos de columna que se usan para crear las tablas de `DataSet`, y los datos para rellenar las filas de las tablas en `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-119">The `Fill` method uses the `DataReader` object implicitly to return the column names and types that are used to create the tables in the `DataSet`, and the data to populate the rows of the tables in the `DataSet`.</span></span> <span data-ttu-id="d3e13-120">Las tablas y columnas solo se crean cuando no existen; en caso contrario, `Fill` utiliza el esquema existente de `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-120">Tables and columns are only created if they do not already exist; otherwise `Fill` uses the existing `DataSet` schema.</span></span> <span data-ttu-id="d3e13-121">Los tipos de columna se crean como tipos de .NET Framework de acuerdo con las tablas de las [asignaciones de tipos de datos en ADO.net](data-type-mappings-in-ado-net.md).</span><span class="sxs-lookup"><span data-stu-id="d3e13-121">Column types are created as .NET Framework types according to the tables in [Data Type Mappings in ADO.NET](data-type-mappings-in-ado-net.md).</span></span> <span data-ttu-id="d3e13-122">Las claves principales no se crean a menos que existan en el origen de datos y `DataAdapter` **.**`MissingSchemaAction`</span><span class="sxs-lookup"><span data-stu-id="d3e13-122">Primary keys are not created unless they exist in the data source and `DataAdapter`**.**`MissingSchemaAction`</span></span> <span data-ttu-id="d3e13-123">está establecido en `MissingSchemaAction` **.** `AddWithKey` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-123">is set to `MissingSchemaAction`**.**`AddWithKey`.</span></span> <span data-ttu-id="d3e13-124">Si el método `Fill` encuentra que una tabla tiene una clave principal, sobrescribe los datos de `DataSet` con los del origen de datos en las filas donde los valores de columna de clave principal coinciden con los de la fila que devuelve el origen de datos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-124">If `Fill` finds that a primary key exists for a table, it will overwrite data in the `DataSet` with data from the data source for rows where the primary key column values match those of the row returned from the data source.</span></span> <span data-ttu-id="d3e13-125">Si no se detecta ninguna clave principal, los datos se agregan a las tablas de `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-125">If no primary key is found, the data is appended to the tables in the `DataSet`.</span></span> <span data-ttu-id="d3e13-126">`Fill` utiliza las asignaciones que pueden existir al rellenar `DataSet` (vea las [asignaciones DataTable y DataColumn de DataAdapter](dataadapter-datatable-and-datacolumn-mappings.md)).</span><span class="sxs-lookup"><span data-stu-id="d3e13-126">`Fill` uses any mappings that may exist when you populate the `DataSet` (see [DataAdapter DataTable and DataColumn Mappings](dataadapter-datatable-and-datacolumn-mappings.md)).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d3e13-127">Si `SelectCommand` devuelve los resultados de OUTER JOIN, `DataAdapter` no establece un valor `PrimaryKey` para el objeto `DataTable`resultante.</span><span class="sxs-lookup"><span data-stu-id="d3e13-127">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a `PrimaryKey` value for the resulting `DataTable`.</span></span> <span data-ttu-id="d3e13-128">Debe definir `PrimaryKey` para asegurarse de que las filas duplicadas se resuelven correctamente.</span><span class="sxs-lookup"><span data-stu-id="d3e13-128">You must define the `PrimaryKey` yourself to make sure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="d3e13-129">Para obtener más información, vea [definir claves principales](./dataset-datatable-dataview/defining-primary-keys.md).</span><span class="sxs-lookup"><span data-stu-id="d3e13-129">For more information, see [Defining Primary Keys](./dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="d3e13-130">En el ejemplo de código siguiente se crea una instancia de <xref:System.Data.SqlClient.SqlDataAdapter> que utiliza un objeto <xref:System.Data.SqlClient.SqlConnection> a la base de datos `Northwind` de Microsoft SQL Server y se rellena un objeto <xref:System.Data.DataTable> en un `DataSet` con la lista de clientes.</span><span class="sxs-lookup"><span data-stu-id="d3e13-130">The following code example creates an instance of a <xref:System.Data.SqlClient.SqlDataAdapter> that uses a <xref:System.Data.SqlClient.SqlConnection> to the Microsoft SQL Server `Northwind` database and populates a <xref:System.Data.DataTable> in a `DataSet` with the list of customers.</span></span> <span data-ttu-id="d3e13-131">La instrucción SQL y los argumentos <xref:System.Data.SqlClient.SqlConnection> pasados al constructor <xref:System.Data.SqlClient.SqlDataAdapter> se utilizan para crear la propiedad <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> del <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="d3e13-131">The SQL statement and <xref:System.Data.SqlClient.SqlConnection> arguments passed to the <xref:System.Data.SqlClient.SqlDataAdapter> constructor are used to create the <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter>.</span></span>  
  
## <a name="example"></a><span data-ttu-id="d3e13-132">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="d3e13-132">Example</span></span>  
  
```vb  
' Assumes that connection is a valid SqlConnection object.  
Dim queryString As String = _  
  "SELECT CustomerID, CompanyName FROM dbo.Customers"  
Dim adapter As SqlDataAdapter = New SqlDataAdapter( _  
  queryString, connection)  
  
Dim customers As DataSet = New DataSet  
adapter.Fill(customers, "Customers")  
```  
  
```csharp  
// Assumes that connection is a valid SqlConnection object.  
string queryString =
  "SELECT CustomerID, CompanyName FROM dbo.Customers";  
SqlDataAdapter adapter = new SqlDataAdapter(queryString, connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
```  
  
> [!NOTE]
> <span data-ttu-id="d3e13-133">El código que se muestra en este ejemplo no abre ni cierra explícitamente el objeto `Connection`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-133">The code shown in this example does not explicitly open and close the `Connection`.</span></span> <span data-ttu-id="d3e13-134">El método `Fill` abre de forma implícita el objeto `Connection` que `DataAdapter` utiliza cuando encuentra que la conexión no está abierta todavía.</span><span class="sxs-lookup"><span data-stu-id="d3e13-134">The `Fill` method implicitly opens the `Connection` that the `DataAdapter` is using if it finds that the connection is not already open.</span></span> <span data-ttu-id="d3e13-135">Si el método `Fill` ha abierto la conexión, también la cierra cuando el método `Fill` deja de utilizarla.</span><span class="sxs-lookup"><span data-stu-id="d3e13-135">If `Fill` opened the connection, it also closes the connection when `Fill` is finished.</span></span> <span data-ttu-id="d3e13-136">Este hecho simplifica el código cuando se trabaja con una operación única, como `Fill` o `Update`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-136">This can simplify your code when you deal with a single operation such as a `Fill` or an `Update`.</span></span> <span data-ttu-id="d3e13-137">Sin embargo, en el caso de que se estén realizando varias operaciones que necesiten tener abierta una conexión, se puede mejorar el rendimiento de la aplicación llamando explícitamente al método `Open` de `Connection`, realizando las operaciones en el origen de datos y, finalmente, llamando al método `Close` de `Connection`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-137">However, if you are performing multiple operations that require an open connection, you can improve the performance of your application by explicitly calling the `Open` method of the `Connection`, performing the operations against the data source, and then calling the `Close` method of the `Connection`.</span></span> <span data-ttu-id="d3e13-138">Es conveniente mantener abiertas las conexiones con el origen de datos el menor tiempo posible para liberar recursos, de manera que estén disponibles para otras aplicaciones cliente.</span><span class="sxs-lookup"><span data-stu-id="d3e13-138">You should try to keep connections to the data source open as briefly as possible to free resources for use by other client applications.</span></span>  
  
## <a name="multiple-result-sets"></a><span data-ttu-id="d3e13-139">Varios conjuntos de resultados</span><span class="sxs-lookup"><span data-stu-id="d3e13-139">Multiple Result Sets</span></span>  

 <span data-ttu-id="d3e13-140">Si `DataAdapter` encuentra varios conjuntos de resultados, crea varias tablas en `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-140">If the `DataAdapter` encounters multiple result sets, it creates multiple tables in the `DataSet`.</span></span> <span data-ttu-id="d3e13-141">Las tablas reciben de forma predeterminada el nombre secuencial Table*N*, comenzando por "Table" que representa Table0.</span><span class="sxs-lookup"><span data-stu-id="d3e13-141">The tables are given an incremental default name of Table*N*, starting with "Table" for Table0.</span></span> <span data-ttu-id="d3e13-142">Si se pasa un nombre de tabla como argumento al método `Fill` , las tablas reciben de forma predeterminada el nombre secuencial TableName*N*, comenzando por "TableName" que representa TableName0.</span><span class="sxs-lookup"><span data-stu-id="d3e13-142">If a table name is passed as an argument to the `Fill` method, the tables are given an incremental default name of TableName*N*, starting with "TableName" for TableName0.</span></span>  
  
## <a name="populating-a-dataset-from-multiple-dataadapters"></a><span data-ttu-id="d3e13-143">Llenar un DataSet desde múltiples DataAdapter</span><span class="sxs-lookup"><span data-stu-id="d3e13-143">Populating a DataSet from Multiple DataAdapters</span></span>  

 <span data-ttu-id="d3e13-144">`DataAdapter`Se puede usar cualquier número de objetos con `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-144">Any number of `DataAdapter` objects can be used with a `DataSet`.</span></span> <span data-ttu-id="d3e13-145">Cada `DataAdapter` se puede usar para rellenar uno o varios objetos `DataTable` y resolver de nuevo las actualizaciones en el origen de datos correspondiente.</span><span class="sxs-lookup"><span data-stu-id="d3e13-145">Each `DataAdapter` can be used to fill one or more `DataTable` objects and resolve updates back to the relevant data source.</span></span> <span data-ttu-id="d3e13-146">Se pueden agregar objetos`DataRelation` y `Constraint` a `DataSet` localmente, lo que permite relacionar datos procedentes de varios orígenes distintos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-146">`DataRelation` and `Constraint` objects can be added to the `DataSet` locally, which enables you to relate data from dissimilar data sources.</span></span> <span data-ttu-id="d3e13-147">Por ejemplo, un `DataSet` puede contener datos de una base de datos de Microsoft SQL Server, una base de datos de IBM DB2 expuesta mediante OLE DB y un origen de datos que genera secuencias XML.</span><span class="sxs-lookup"><span data-stu-id="d3e13-147">For example, a `DataSet` can contain data from a Microsoft SQL Server database, an IBM DB2 database exposed through OLE DB, and a data source that streams XML.</span></span> <span data-ttu-id="d3e13-148">La comunicación con cada origen de datos se puede controlar usando uno o varios objetos `DataAdapter` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-148">One or more `DataAdapter` objects can handle communication to each data source.</span></span>  
  
### <a name="example"></a><span data-ttu-id="d3e13-149">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="d3e13-149">Example</span></span>  

 <span data-ttu-id="d3e13-150">En el ejemplo de código siguiente se rellena una lista de clientes a partir de la base de datos `Northwind` almacenada en Microsoft SQL Server, y una lista de pedidos a partir de la base de datos `Northwind` almacenada en Microsoft Access 2000.</span><span class="sxs-lookup"><span data-stu-id="d3e13-150">The following code example populates a list of customers from the `Northwind` database on Microsoft SQL Server, and a list of orders from the `Northwind` database stored in Microsoft Access 2000.</span></span> <span data-ttu-id="d3e13-151">Las tablas rellenas se relacionan entre sí mediante `DataRelation`, con lo que se puede mostrar una lista de clientes con los pedidos que ha realizado cada uno.</span><span class="sxs-lookup"><span data-stu-id="d3e13-151">The filled tables are related with a `DataRelation`, and the list of customers is then displayed with the orders for that customer.</span></span> <span data-ttu-id="d3e13-152">Para obtener más información acerca de los `DataRelation` objetos, vea [Agregar DataRelations](./dataset-datatable-dataview/adding-datarelations.md) y [navegar por DataRelations](./dataset-datatable-dataview/navigating-datarelations.md).</span><span class="sxs-lookup"><span data-stu-id="d3e13-152">For more information about `DataRelation` objects, see [Adding DataRelations](./dataset-datatable-dataview/adding-datarelations.md) and [Navigating DataRelations](./dataset-datatable-dataview/navigating-datarelations.md).</span></span>  
  
```vb  
' Assumes that customerConnection is a valid SqlConnection object.  
' Assumes that orderConnection is a valid OleDbConnection object.  
Dim custAdapter As SqlDataAdapter = New SqlDataAdapter( _  
  "SELECT * FROM dbo.Customers", customerConnection)  
  
Dim ordAdapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SELECT * FROM Orders", orderConnection)  
  
Dim customerOrders As DataSet = New DataSet()  
custAdapter.Fill(customerOrders, "Customers")  
ordAdapter.Fill(customerOrders, "Orders")  
  
Dim relation As DataRelation = _  
  customerOrders.Relations.Add("CustOrders", _  
  customerOrders.Tables("Customers").Columns("CustomerID"), _
  customerOrders.Tables("Orders").Columns("CustomerID"))  
  
Dim pRow, cRow As DataRow  
For Each pRow In customerOrders.Tables("Customers").Rows  
  Console.WriteLine(pRow("CustomerID").ToString())  
  
  For Each cRow In pRow.GetChildRows(relation)  
    Console.WriteLine(vbTab & cRow("OrderID").ToString())  
  Next  
Next  
```  
  
```csharp  
// Assumes that customerConnection is a valid SqlConnection object.  
// Assumes that orderConnection is a valid OleDbConnection object.  
SqlDataAdapter custAdapter = new SqlDataAdapter(  
  "SELECT * FROM dbo.Customers", customerConnection);  
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(  
  "SELECT * FROM Orders", orderConnection);  
  
DataSet customerOrders = new DataSet();  
  
custAdapter.Fill(customerOrders, "Customers");  
ordAdapter.Fill(customerOrders, "Orders");  
  
DataRelation relation = customerOrders.Relations.Add("CustOrders",  
  customerOrders.Tables["Customers"].Columns["CustomerID"],  
  customerOrders.Tables["Orders"].Columns["CustomerID"]);  
  
foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)  
{  
  Console.WriteLine(pRow["CustomerID"]);  
   foreach (DataRow cRow in pRow.GetChildRows(relation))  
    Console.WriteLine("\t" + cRow["OrderID"]);  
}  
```  
  
## <a name="sql-server-decimal-type"></a><span data-ttu-id="d3e13-153">Tipo decimal de SQL Server</span><span class="sxs-lookup"><span data-stu-id="d3e13-153">SQL Server Decimal Type</span></span>  

 <span data-ttu-id="d3e13-154">De forma predeterminada, `DataSet` almacena los datos mediante .NET Framework tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-154">By default, the `DataSet` stores data by using .NET Framework data types.</span></span> <span data-ttu-id="d3e13-155">En la mayor parte de las aplicaciones, estos tipos proporcionan una representación adecuada de la información del origen de datos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-155">For most applications, these provide a convenient representation of data source information.</span></span> <span data-ttu-id="d3e13-156">Sin embargo, esa representación puede ocasionar problemas cuando el tipo de datos del origen de datos es decimal o numérico de SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d3e13-156">However, this representation may cause a problem when the data type in the data source is a SQL Server decimal or numeric data type.</span></span> <span data-ttu-id="d3e13-157">El `decimal` tipo de datos .NET Framework permite un máximo de 28 dígitos significativos, mientras que el `decimal` tipo de datos SQL Server permite 38 dígitos significativos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-157">The .NET Framework `decimal` data type allows a maximum of 28 significant digits, whereas the SQL Server `decimal` data type allows 38 significant digits.</span></span> <span data-ttu-id="d3e13-158">Si `SqlDataAdapter` determina durante una operación `Fill` que la precisión de un campo `decimal` de SQL Server es superior a 28 caracteres, la fila actual no se agrega a `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-158">If the `SqlDataAdapter` determines during a `Fill` operation that the precision of a SQL Server `decimal` field is larger than 28 characters, the current row is not added to the `DataTable`.</span></span> <span data-ttu-id="d3e13-159">En su lugar, se produce el evento `FillError` que permite determinar si se va a producir o no una pérdida de precisión y tomar las medidas adecuadas.</span><span class="sxs-lookup"><span data-stu-id="d3e13-159">Instead the `FillError` event occurs, which enables you to determine whether a loss of precision will occur, and respond appropriately.</span></span> <span data-ttu-id="d3e13-160">Para obtener más información sobre el `FillError` evento, vea [controlar eventos DataAdapter](handling-dataadapter-events.md).</span><span class="sxs-lookup"><span data-stu-id="d3e13-160">For more information about the `FillError` event, see [Handling DataAdapter Events](handling-dataadapter-events.md).</span></span> <span data-ttu-id="d3e13-161">Para obtener el valor `decimal` de SQL Server, también se puede utilizar un objeto <xref:System.Data.SqlClient.SqlDataReader> y llamar al método <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> .</span><span class="sxs-lookup"><span data-stu-id="d3e13-161">To get the SQL Server `decimal` value, you can also use a <xref:System.Data.SqlClient.SqlDataReader> object and call the <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> method.</span></span>  
  
 <span data-ttu-id="d3e13-162">ADO.NET 2,0 presentó compatibilidad mejorada con <xref:System.Data.SqlTypes> en `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-162">ADO.NET 2.0 introduced enhanced support for <xref:System.Data.SqlTypes> in the `DataSet`.</span></span> <span data-ttu-id="d3e13-163">Para obtener más información, consulta [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="d3e13-163">For more information, see [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span></span>  
  
## <a name="ole-db-chapters"></a><span data-ttu-id="d3e13-164">Capítulos de OLE DB</span><span class="sxs-lookup"><span data-stu-id="d3e13-164">OLE DB Chapters</span></span>  

 <span data-ttu-id="d3e13-165">Se pueden usar conjuntos jerárquicos de filas, o capítulos (tipo `DBTYPE_HCHAPTER`de OLE DB y tipo `adChapter`de ADO), para rellenar el contenido de `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-165">Hierarchical rowsets, or chapters (OLE DB type `DBTYPE_HCHAPTER`, ADO type `adChapter`) can be used to fill the contents of a `DataSet`.</span></span> <span data-ttu-id="d3e13-166">Cuando <xref:System.Data.OleDb.OleDbDataAdapter> encuentra una columna que tiene un capítulo durante una operación `Fill` , se crea un objeto `DataTable` para dicha columna y la tabla se rellena con las columnas y filas del capítulo.</span><span class="sxs-lookup"><span data-stu-id="d3e13-166">When the <xref:System.Data.OleDb.OleDbDataAdapter> encounters a chaptered column during a `Fill` operation, a `DataTable` is created for the chaptered column, and that table is filled with the columns and rows from the chapter.</span></span> <span data-ttu-id="d3e13-167">Para asignar un nombre a la tabla creada para la columna con capítulo se usa tanto el nombre de la tabla primaria como el de la columna con capítulo. El formato del nombre es "*nombreDeTablaPrimariaNombreDeColumnaConCapítulo*".</span><span class="sxs-lookup"><span data-stu-id="d3e13-167">The table created for the chaptered column is named by using both the parent table name and the chaptered column name in the form "*ParentTableNameChapteredColumnName*".</span></span> <span data-ttu-id="d3e13-168">Si ya existe una tabla en `DataSet` que tenga el nombre de la columna con capítulo, la tabla actual se rellena con los datos del capítulo.</span><span class="sxs-lookup"><span data-stu-id="d3e13-168">If a table already exists in the `DataSet` that matches the name of the chaptered column, the current table is filled with the chapter data.</span></span> <span data-ttu-id="d3e13-169">Si ninguna de las columnas de la tabla existente coincide con una de las columnas del capítulo, se agrega una nueva columna a la tabla.</span><span class="sxs-lookup"><span data-stu-id="d3e13-169">If there is no column in an existing table that matches a column found in the chapter, a new column is added.</span></span>  
  
 <span data-ttu-id="d3e13-170">Antes de que las tablas de `DataSet` se rellenen con los datos de las columnas con capítulos, se crea una relación entre las tablas primaria y secundaria del conjunto jerárquico de filas; para ello, se agrega una columna de tipo entero a las tablas primaria y secundaria, se establece el valor de incremento automático para la columna de la tabla primaria y se crea un objeto `DataRelation` usando las columnas agregadas de ambas tablas.</span><span class="sxs-lookup"><span data-stu-id="d3e13-170">Before the tables in the `DataSet` are filled with the data in the chaptered columns, a relation is created between the parent and child tables of the hierarchical rowset by adding an integer column to both the parent and child table, setting the parent column to auto-increment, and creating a `DataRelation` using the added columns from both tables.</span></span> <span data-ttu-id="d3e13-171">Para asignar un nombre a la relación se utilizan los nombres de la tabla primaria y de la columna con capítulo. El formato es "*nombreDeTablaPrimariaNombreDeColumnaConCapítulo*".</span><span class="sxs-lookup"><span data-stu-id="d3e13-171">The added relation is named by using the parent table and chapter column names in the form "*ParentTableNameChapterColumnName*".</span></span>  
  
 <span data-ttu-id="d3e13-172">Tenga en cuenta que la columna relacionada solo existe en `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="d3e13-172">Note that the related column only exists in the `DataSet`.</span></span> <span data-ttu-id="d3e13-173">Las operaciones de relleno que se realicen posteriormente desde el origen de datos pueden provocar que se agreguen nuevas filas a las tablas en lugar de que se introduzcan los cambios en las filas existentes.</span><span class="sxs-lookup"><span data-stu-id="d3e13-173">Subsequent fills from the data source can cause new rows to be added to the tables instead of changes being merged into existing rows.</span></span>  
  
 <span data-ttu-id="d3e13-174">Tenga en cuenta además que, si se utiliza una sobrecarga de `DataAdapter.Fill` que acepte un objeto `DataTable`, solo se rellanará esa tabla.</span><span class="sxs-lookup"><span data-stu-id="d3e13-174">Note also that, if you use the `DataAdapter.Fill` overload that takes a `DataTable`, only that table will be filled.</span></span> <span data-ttu-id="d3e13-175">En este caso también se agrega a la tabla una columna de tipo entero y con incremento automático, aunque no se crea ni rellena ninguna tabla secundaria, ni se crea ninguna relación.</span><span class="sxs-lookup"><span data-stu-id="d3e13-175">An auto-incrementing integer column will still be added to the table, but no child table will be created or filled, and no relation will be created.</span></span>  
  
 <span data-ttu-id="d3e13-176">En el ejemplo siguiente se utiliza el proveedor MSDataShape para generar un capítulo con la columna de pedidos realizados por cada uno de los clientes de una lista.</span><span class="sxs-lookup"><span data-stu-id="d3e13-176">The following example uses the MSDataShape Provider to generate a chapter column of orders for each customer in a list of customers.</span></span> <span data-ttu-id="d3e13-177">A continuación, se rellena un `DataSet` con los datos.</span><span class="sxs-lookup"><span data-stu-id="d3e13-177">A `DataSet` is then filled with the data.</span></span>  
  
```vb  
Using connection As OleDbConnection = New OleDbConnection( _  
  "Provider=MSDataShape;Data Provider=SQLOLEDB;" & _  
  "Data Source=(local);Integrated " & _  
  "Security=SSPI;Initial Catalog=northwind")  
  
Dim adapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SHAPE {SELECT CustomerID, CompanyName FROM Customers} " & _  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " & _  
  "RELATE CustomerID TO CustomerID)", connection)  
  
Dim customers As DataSet = New DataSet()  
  
adapter.Fill(customers, "Customers")  
End Using  
```  
  
```csharp  
using (OleDbConnection connection = new OleDbConnection("Provider=MSDataShape;Data Provider=SQLOLEDB;" +  
  "Data Source=(local);Integrated Security=SSPI;Initial Catalog=northwind"))  
{  
OleDbDataAdapter adapter = new OleDbDataAdapter("SHAPE {SELECT CustomerID, CompanyName FROM Customers} " +  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " +  
  "RELATE CustomerID TO CustomerID)", connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
}  
```  
  
 <span data-ttu-id="d3e13-178">Una vez completada la operación `Fill` , `DataSet` contiene dos tablas: `Customers` y `CustomersOrders`, donde `CustomersOrders` representa la columna con capítulo.</span><span class="sxs-lookup"><span data-stu-id="d3e13-178">When the `Fill` operation is complete, the `DataSet` contains two tables: `Customers` and `CustomersOrders`, where `CustomersOrders` represents the chaptered column.</span></span> <span data-ttu-id="d3e13-179">Se agrega una columna adicional denominada `Orders` a la tabla `Customers` , y una columna adicional denominada `CustomersOrders` a la tabla `CustomersOrders` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-179">An additional column named `Orders` is added to the `Customers` table, and an additional column named `CustomersOrders` is added to the `CustomersOrders` table.</span></span> <span data-ttu-id="d3e13-180">Se establece el valor de incremento automático para la columna `Orders` de la tabla `Customers` .</span><span class="sxs-lookup"><span data-stu-id="d3e13-180">The `Orders` column in the `Customers` table is set to auto-increment.</span></span> <span data-ttu-id="d3e13-181">Se crea también una relación `DataRelation`, `CustomersOrders`, utilizando las columnas que se han agregado a las tablas, siendo `Customers` la tabla primaria.</span><span class="sxs-lookup"><span data-stu-id="d3e13-181">A `DataRelation`, `CustomersOrders`, is created by using the columns that were added to the tables with `Customers` as the parent table.</span></span> <span data-ttu-id="d3e13-182">Las siguientes tablas muestran algunos ejemplos de los resultados.</span><span class="sxs-lookup"><span data-stu-id="d3e13-182">The following tables show some sample results.</span></span>  
  
### <a name="tablename-customers"></a><span data-ttu-id="d3e13-183">Nombre de tabla: Customers</span><span class="sxs-lookup"><span data-stu-id="d3e13-183">TableName: Customers</span></span>  
  
|<span data-ttu-id="d3e13-184">Identificador de cliente</span><span class="sxs-lookup"><span data-stu-id="d3e13-184">CustomerID</span></span>|<span data-ttu-id="d3e13-185">CompanyName</span><span class="sxs-lookup"><span data-stu-id="d3e13-185">CompanyName</span></span>|<span data-ttu-id="d3e13-186">Orders (Pedidos)</span><span class="sxs-lookup"><span data-stu-id="d3e13-186">Orders</span></span>|  
|----------------|-----------------|------------|  
|<span data-ttu-id="d3e13-187">ALFKI</span><span class="sxs-lookup"><span data-stu-id="d3e13-187">ALFKI</span></span>|<span data-ttu-id="d3e13-188">Alfreds Futterkiste</span><span class="sxs-lookup"><span data-stu-id="d3e13-188">Alfreds Futterkiste</span></span>|<span data-ttu-id="d3e13-189">0</span><span class="sxs-lookup"><span data-stu-id="d3e13-189">0</span></span>|  
|<span data-ttu-id="d3e13-190">ANATR</span><span class="sxs-lookup"><span data-stu-id="d3e13-190">ANATR</span></span>|<span data-ttu-id="d3e13-191">Ana Trujillo Emparedados y helados</span><span class="sxs-lookup"><span data-stu-id="d3e13-191">Ana Trujillo Emparedados y helados</span></span>|<span data-ttu-id="d3e13-192">1</span><span class="sxs-lookup"><span data-stu-id="d3e13-192">1</span></span>|  
  
### <a name="tablename-customersorders"></a><span data-ttu-id="d3e13-193">Nombre de tabla: CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="d3e13-193">TableName: CustomersOrders</span></span>  
  
|<span data-ttu-id="d3e13-194">Identificador de cliente</span><span class="sxs-lookup"><span data-stu-id="d3e13-194">CustomerID</span></span>|<span data-ttu-id="d3e13-195">OrderID</span><span class="sxs-lookup"><span data-stu-id="d3e13-195">OrderID</span></span>|<span data-ttu-id="d3e13-196">CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="d3e13-196">CustomersOrders</span></span>|  
|----------------|-------------|---------------------|  
|<span data-ttu-id="d3e13-197">ALFKI</span><span class="sxs-lookup"><span data-stu-id="d3e13-197">ALFKI</span></span>|<span data-ttu-id="d3e13-198">10643</span><span class="sxs-lookup"><span data-stu-id="d3e13-198">10643</span></span>|<span data-ttu-id="d3e13-199">0</span><span class="sxs-lookup"><span data-stu-id="d3e13-199">0</span></span>|  
|<span data-ttu-id="d3e13-200">ALFKI</span><span class="sxs-lookup"><span data-stu-id="d3e13-200">ALFKI</span></span>|<span data-ttu-id="d3e13-201">10692</span><span class="sxs-lookup"><span data-stu-id="d3e13-201">10692</span></span>|<span data-ttu-id="d3e13-202">0</span><span class="sxs-lookup"><span data-stu-id="d3e13-202">0</span></span>|  
|<span data-ttu-id="d3e13-203">ANATR</span><span class="sxs-lookup"><span data-stu-id="d3e13-203">ANATR</span></span>|<span data-ttu-id="d3e13-204">10308</span><span class="sxs-lookup"><span data-stu-id="d3e13-204">10308</span></span>|<span data-ttu-id="d3e13-205">1</span><span class="sxs-lookup"><span data-stu-id="d3e13-205">1</span></span>|  
|<span data-ttu-id="d3e13-206">ANATR</span><span class="sxs-lookup"><span data-stu-id="d3e13-206">ANATR</span></span>|<span data-ttu-id="d3e13-207">10625</span><span class="sxs-lookup"><span data-stu-id="d3e13-207">10625</span></span>|<span data-ttu-id="d3e13-208">1</span><span class="sxs-lookup"><span data-stu-id="d3e13-208">1</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="d3e13-209">Consulte también</span><span class="sxs-lookup"><span data-stu-id="d3e13-209">See also</span></span>

- [<span data-ttu-id="d3e13-210">Objetos DataAdapter y DataReader</span><span class="sxs-lookup"><span data-stu-id="d3e13-210">DataAdapters and DataReaders</span></span>](dataadapters-and-datareaders.md)
- [<span data-ttu-id="d3e13-211">Asignaciones de tipos de datos en ADO.NET</span><span class="sxs-lookup"><span data-stu-id="d3e13-211">Data Type Mappings in ADO.NET</span></span>](data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="d3e13-212">Modificar datos con un objeto DbDataAdapter</span><span class="sxs-lookup"><span data-stu-id="d3e13-212">Modifying Data with a DbDataAdapter</span></span>](modifying-data-with-a-dbdataadapter.md)
- [<span data-ttu-id="d3e13-213">Conjuntos de resultados activos múltiples (MARS)</span><span class="sxs-lookup"><span data-stu-id="d3e13-213">Multiple Active Result Sets (MARS)</span></span>](./sql/multiple-active-result-sets-mars.md)
- [<span data-ttu-id="d3e13-214">Información general de ADO.NET</span><span class="sxs-lookup"><span data-stu-id="d3e13-214">ADO.NET Overview</span></span>](ado-net-overview.md)
