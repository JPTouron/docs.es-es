---
title: Utilización de la clase XmlSerializer
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 2ef2d0eefb571f64040fabd16fd65fdfde7a626d
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/09/2020
ms.locfileid: "84600210"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="02c6a-102">Utilización de la clase XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="02c6a-102">Using the XmlSerializer Class</span></span>

<span data-ttu-id="02c6a-103">Windows Communication Foundation (WCF) puede usar dos tecnologías de serialización diferentes para convertir los datos de la aplicación en XML que se transmite entre clientes y servicios, un proceso denominado serialización.</span><span class="sxs-lookup"><span data-stu-id="02c6a-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="02c6a-104">DataContractSerializer como predeterminado</span><span class="sxs-lookup"><span data-stu-id="02c6a-104">DataContractSerializer as the Default</span></span>

<span data-ttu-id="02c6a-105">De forma predeterminada, WCF usa la <xref:System.Runtime.Serialization.DataContractSerializer> clase para serializar los tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="02c6a-106">Este serializador admite los tipos siguientes:</span><span class="sxs-lookup"><span data-stu-id="02c6a-106">This serializer supports the following types:</span></span>

- <span data-ttu-id="02c6a-107">Tipos primitivos (por ejemplo, enteros, cadenas y matrices de bytes), así como algunos tipos especiales, como <xref:System.Xml.XmlElement> y <xref:System.DateTime>, que se tratan como primitivos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="02c6a-108">Tipos de contrato de datos (los tipos marcados con el atributo <xref:System.Runtime.Serialization.DataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="02c6a-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="02c6a-109">Los tipos marcados con el atributo <xref:System.SerializableAttribute>, incluidos los tipos que implementan la interfaz <xref:System.Runtime.Serialization.ISerializable>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="02c6a-110">Los tipos que implementan la interfaz <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="02c6a-111">Muchos tipos de colección comunes, que incluyen muchos tipos de colección genéricos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-111">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="02c6a-112">Muchos tipos de .NET Framework se encuentran en las dos últimas categorías y, por tanto, son serializables.</span><span class="sxs-lookup"><span data-stu-id="02c6a-112">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="02c6a-113">Las matrices de tipos serializables también son serializables.</span><span class="sxs-lookup"><span data-stu-id="02c6a-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="02c6a-114">Para obtener una lista completa, consulte [especificar transferencia de datos en contratos de servicio](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="02c6a-114">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="02c6a-115"><xref:System.Runtime.Serialization.DataContractSerializer>, Que se usa junto con los tipos de contrato de datos, es la manera recomendada de escribir nuevos servicios WCF.</span><span class="sxs-lookup"><span data-stu-id="02c6a-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="02c6a-116">Para obtener más información, consulte [uso de contratos de datos](using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="02c6a-116">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="02c6a-117">Cuándo utilizar la clase XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="02c6a-117">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="02c6a-118">WCF también admite la <xref:System.Xml.Serialization.XmlSerializer> clase.</span><span class="sxs-lookup"><span data-stu-id="02c6a-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="02c6a-119">La <xref:System.Xml.Serialization.XmlSerializer> clase no es única para WCF.</span><span class="sxs-lookup"><span data-stu-id="02c6a-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="02c6a-120">Es el mismo motor de serialización que usan los servicios Web de ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="02c6a-120">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="02c6a-121">La clase <xref:System.Xml.Serialization.XmlSerializer> admite un conjunto mucho más estrecho de tipos que la clase <xref:System.Runtime.Serialization.DataContractSerializer>, pero permite mucho más control sobre el XML resultante y admite mucho más de la norma del lenguaje de definición de esquemas XML (XSD).</span><span class="sxs-lookup"><span data-stu-id="02c6a-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="02c6a-122">Tampoco necesita ningún atributo declarativo en los tipos serializables.</span><span class="sxs-lookup"><span data-stu-id="02c6a-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="02c6a-123">Para obtener más información, vea el tema sobre serialización XML en la documentación de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="02c6a-123">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="02c6a-124">La clase <xref:System.Xml.Serialization.XmlSerializer> no admite tipos de contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="02c6a-125">Al usar SvcUtil. exe o la característica **Agregar referencia de servicio** de Visual Studio para generar el código de cliente para un servicio de terceros, o para obtener acceso a un esquema de terceros, se selecciona automáticamente un serializador adecuado.</span><span class="sxs-lookup"><span data-stu-id="02c6a-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="02c6a-126">Si el esquema no es compatible con <xref:System.Runtime.Serialization.DataContractSerializer>, se selecciona el <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="02c6a-127">Intercambio manual a XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="02c6a-127">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="02c6a-128">En algunas ocasiones, puede ser necesario intercambiar manualmente a <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="02c6a-129">Esto sucede, por ejemplo, en los casos siguientes:</span><span class="sxs-lookup"><span data-stu-id="02c6a-129">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="02c6a-130">Al migrar una aplicación de los servicios Web de ASP.NET a WCF, es posible que desee reutilizar los <xref:System.Xml.Serialization.XmlSerializer> tipos existentes compatibles con, en lugar de crear nuevos tipos de contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-130">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="02c6a-131">Cuando es importante el control preciso sobre el XML que aparece en los mensajes, pero no hay disponible un documento de lenguaje de descripción de servicios Web (WSDL), por ejemplo, al crear un servicio con tipos que tienen que cumplir un cierto esquema normalizado, publicado, no compatible con DataContractSerializer.</span><span class="sxs-lookup"><span data-stu-id="02c6a-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="02c6a-132">Al crear servicios que siguen la norma de Codificación SOAP heredada.</span><span class="sxs-lookup"><span data-stu-id="02c6a-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="02c6a-133">En éstos y otros casos, puede intercambiar manualmente a la clase <xref:System.Xml.Serialization.XmlSerializer> aplicando el atributo `XmlSerializerFormatAttribute` a su servicio, tal y como se muestra en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="02c6a-134">Consideraciones sobre la seguridad</span><span class="sxs-lookup"><span data-stu-id="02c6a-134">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="02c6a-135">Es importante tener el cuidado al intercambiar los motores de serialización.</span><span class="sxs-lookup"><span data-stu-id="02c6a-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="02c6a-136">El mismo tipo puede serializar de maneras diferentes, dependiendo del serializador que se utiliza.</span><span class="sxs-lookup"><span data-stu-id="02c6a-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="02c6a-137">Si por error utiliza un serializador erróneo, podría estar divulgando información de un tipo que no tenía intención de divulgar.</span><span class="sxs-lookup"><span data-stu-id="02c6a-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="02c6a-138">Por ejemplo, la clase <xref:System.Runtime.Serialization.DataContractSerializer> sólo serializa los miembros marcados con el atributo <xref:System.Runtime.Serialization.DataMemberAttribute> al serializar los tipos de contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="02c6a-139">La clase <xref:System.Xml.Serialization.XmlSerializer> serializa cualquier miembro público.</span><span class="sxs-lookup"><span data-stu-id="02c6a-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="02c6a-140">Vea el tipo del código siguiente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-140">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="02c6a-141">Si el tipo se utiliza inadvertidamente en un contrato de servicios donde está seleccionada la clase <xref:System.Xml.Serialization.XmlSerializer>, se serializa el miembro `creditCardNumber` que probablemente no corresponde.</span><span class="sxs-lookup"><span data-stu-id="02c6a-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="02c6a-142">Aunque la clase <xref:System.Runtime.Serialization.DataContractSerializer> es el valor predeterminado, puede seleccionarlo explícitamente para su servicio (aunque esto no se debería exigir nunca) aplicando el atributo <xref:System.ServiceModel.DataContractFormatAttribute> al tipo de contrato de servicios.</span><span class="sxs-lookup"><span data-stu-id="02c6a-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="02c6a-143">El serializador utilizado para el servicio es una parte integrante del contrato y no se puede cambiar seleccionando un enlace diferente o cambiando otra configuración.</span><span class="sxs-lookup"><span data-stu-id="02c6a-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="02c6a-144">Otras consideraciones de seguridad importantes se aplican a la clase <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="02c6a-145">En primer lugar, se recomienda encarecidamente que todas las aplicaciones WCF que utilicen la <xref:System.Xml.Serialization.XmlSerializer> clase estén firmadas con una clave que esté protegida contra la divulgación.</span><span class="sxs-lookup"><span data-stu-id="02c6a-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="02c6a-146">Esta recomendación se aplica cuando se realiza un modificador manual a <xref:System.Xml.Serialization.XmlSerializer> y cuando se lleva a cabo un modificador automático (mediante Svcutil.exe, Agregar referencia de servicio o una herramienta similar).</span><span class="sxs-lookup"><span data-stu-id="02c6a-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="02c6a-147">Esto se debe a que el <xref:System.Xml.Serialization.XmlSerializer> motor de serialización admite la carga de *ensamblados de serialización generados previamente* siempre y cuando estén firmados con la misma clave que la aplicación.</span><span class="sxs-lookup"><span data-stu-id="02c6a-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="02c6a-148">Una aplicación sin firma está totalmente desprotegida frente a la posibilidad de que un ensamblado malintencionado que coincida con el nombre esperado del ensamblado de serialización previamente generado se sitúe en la carpeta de aplicaciones o en la caché global de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="02c6a-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="02c6a-149">Por supuesto, antes de nada, un atacante debe tener acceso de escritura a una de estas dos ubicaciones para intentar realizar dicha acción.</span><span class="sxs-lookup"><span data-stu-id="02c6a-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="02c6a-150">Otra amenaza que existe siempre que usted utiliza <xref:System.Xml.Serialization.XmlSerializer> está relacionada con el acceso de escritura a la carpeta temporal del sistema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="02c6a-151">El <xref:System.Xml.Serialization.XmlSerializer> motor de serialización crea y utiliza *ensamblados de serialización* temporales en esta carpeta.</span><span class="sxs-lookup"><span data-stu-id="02c6a-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="02c6a-152">Debería ser consciente de que cualquier proceso con acceso de escritura a la carpeta temporal puede sobrescribir estos ensamblados de serialización con código malintencionado.</span><span class="sxs-lookup"><span data-stu-id="02c6a-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="02c6a-153">Reglas para la compatibilidad de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="02c6a-153">Rules for XmlSerializer support</span></span>

<span data-ttu-id="02c6a-154">No puede aplicar directamente <xref:System.Xml.Serialization.XmlSerializer>- los atributos compatibles a los parámetros de operación de contrato o valores devueltos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="02c6a-155">Sin embargo, se pueden aplicar a los mensajes con tipo (partes del cuerpo del contrato de mensaje), como se muestra en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="02c6a-156">Cuando se aplica a los miembros de mensaje con tipo, estos atributos invalidan propiedades que están en conflicto en los atributos de mensaje con tipo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="02c6a-157">Por ejemplo en el siguiente código, `ElementName` invalida `Name`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="02c6a-158">No se admite el atributo <xref:System.ServiceModel.MessageHeaderArrayAttribute> al utilizar <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="02c6a-159">En este caso, <xref:System.Xml.Serialization.XmlSerializer> inicia la siguiente excepción, que se libera antes de WCF: "un elemento declarado en el nivel superior de un esquema no puede tener `maxOccurs` > 1.</span><span class="sxs-lookup"><span data-stu-id="02c6a-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="02c6a-160">Debe proporcionar un elemento contenedor para 'más' usando `XmlArray` o `XmlArrayItem` en lugar de `XmlElementAttribute`, o usando el estilo de parámetro Wrapped".</span><span class="sxs-lookup"><span data-stu-id="02c6a-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="02c6a-161">Si recibe esta excepción, investigue si se aplica esta situación.</span><span class="sxs-lookup"><span data-stu-id="02c6a-161">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="02c6a-162">WCF no admite los <xref:System.Xml.Serialization.SoapIncludeAttribute> atributos y <xref:System.Xml.Serialization.XmlIncludeAttribute> en contratos de mensajes y contratos de operación; Utilice <xref:System.Runtime.Serialization.KnownTypeAttribute> en su lugar el atributo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="02c6a-163">Tipos que implementan la interfaz IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="02c6a-163">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="02c6a-164">`IXmlSerializable`admite totalmente los tipos que implementan la interfaz `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="02c6a-165">El atributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> siempre se debería aplicar a estos tipos para controlar su esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="02c6a-166">Si está serializando tipos polimórficos, debe aplicar el <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> al tipo para asegurarse de que se serializa el tipo correcto.</span><span class="sxs-lookup"><span data-stu-id="02c6a-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="02c6a-167">Existen tres variedades de tipos que implementan `IXmlSerializable`: tipos que representan el contenido arbitrario, tipos que representan un elemento único, y los tipos <xref:System.Data.DataSet> heredados.</span><span class="sxs-lookup"><span data-stu-id="02c6a-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="02c6a-168">Los tipos de contenido utilizan un método de proveedor de esquema especificado por el atributo `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="02c6a-169">El método no devuelve `null` y la propiedad <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> en el atributo se deja como su valor predeterminado de `false`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="02c6a-170">Éste es el uso más común de los tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-170">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="02c6a-171">Se utilizan los tipos de elemento cuando un tipo `IXmlSerializable` debe controlar su propio nombre del elemento raíz.</span><span class="sxs-lookup"><span data-stu-id="02c6a-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="02c6a-172">Para marcar un tipo como un tipo de elemento, establezca la propiedad <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> del atributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> en `true` o devuelva `null` a partir del método de proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="02c6a-173">Tener un método de proveedor de esquema es opcional para los tipos de elemento. Puede especificar `null` en lugar del nombre del método en `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="02c6a-174">Sin embargo, si `IsAny` es `true` y se especifica un método de proveedor de esquema, el método debe devolver `null`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="02c6a-175">Los tipos <xref:System.Data.DataSet> heredados son `IXmlSerializable` escribe que no se marca con el atributo `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="02c6a-176">En su lugar, confían en el método <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> para la generación del esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="02c6a-177">Este patrón se utiliza para el tipo `DataSet` y su conjunto de datos con tipo deriva una clase en versiones anteriores de .NET Framework, pero ahora es obsoleto y sólo se admite por razones heredadas.</span><span class="sxs-lookup"><span data-stu-id="02c6a-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="02c6a-178">No confíe en este patrón y aplique siempre `XmlSchemaProviderAttribute` a sus tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="02c6a-179">Tipos de contenido de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="02c6a-179">IXmlSerializable Content Types</span></span>

<span data-ttu-id="02c6a-180">Al serializar un miembro de datos de un tipo que implementa `IXmlSerializable`, y es un tipo de contenido como el que se ha definido previamente, el serializador escribe el elemento contenedor para el miembro de datos y pasará el control al método <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="02c6a-181">La implementación <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> puede escribir cualquier XML, incluso agregar los atributos al elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="02c6a-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="02c6a-182">Una vez realizado `WriteXml`, el serializador cierra el elemento.</span><span class="sxs-lookup"><span data-stu-id="02c6a-182">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="02c6a-183">Al deserializar un miembro de datos de un tipo que implementa `IXmlSerializable`, y es un tipo de contenido como el que se ha definido previamente, el deserializador sitúa el lector de XML en el elemento contenedor para el miembro de datos y pasa el control al método <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="02c6a-184">El método debe leer todo el elemento, también las etiquetas de cierre e inicio.</span><span class="sxs-lookup"><span data-stu-id="02c6a-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="02c6a-185">Asegúrese de que su código `ReadXml` controla el caso donde el elemento está vacío.</span><span class="sxs-lookup"><span data-stu-id="02c6a-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="02c6a-186">Además, su implementación `ReadXml` no debería confiar en el elemento contenedor denominado de una manera determinada.</span><span class="sxs-lookup"><span data-stu-id="02c6a-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="02c6a-187">El serializador elige el nombre y este puede variar.</span><span class="sxs-lookup"><span data-stu-id="02c6a-187">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="02c6a-188">Se permite asignar polimórficamente tipos de contenido `IXmlSerializable`, por ejemplo, a los miembros de datos de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="02c6a-189">También se permite que las instancias de tipo sean nulo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="02c6a-190">Finalmente, es posible utilizar los tipos `IXmlSerializable` con preservación de gráfico de objetos habilitado y con <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="02c6a-191">Todas estas características requieren que el serializador de WCF adjunte determinados atributos en el elemento contenedor ("nil" y "tipo" en el espacio de nombres de la instancia del esquema XML y "ID", "ref", "type" y "Assembly" en un espacio de nombres específico de WCF).</span><span class="sxs-lookup"><span data-stu-id="02c6a-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="02c6a-192">Atributos que hay que omitir al Implementar ReadXml</span><span class="sxs-lookup"><span data-stu-id="02c6a-192">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="02c6a-193">Antes de pasar el control al código `ReadXml`, el deserializador examina el elemento XML, detecta estos atributos XML especiales y actúa sobre ellos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="02c6a-194">Por ejemplo, si "nil" es `true`, se deserializa un valor null y no se llama a `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="02c6a-195">Si se detecta polimorfismo, el contenido del elemento se deserializa como si fuera un tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="02c6a-196">Se llama a la implementación del tipo asignado polimórficamente `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="02c6a-197">En cualquier caso, una implementación de `ReadXml` debería omitir estos atributos especiales ya que están controlados por el deserializador.</span><span class="sxs-lookup"><span data-stu-id="02c6a-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="02c6a-198">Consideraciones del esquema para los tipos de contenido de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="02c6a-198">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="02c6a-199">Al exportar el esquema y un tipo de contenido `IXmlSerializable`, se llama al método de proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="02c6a-200"><xref:System.Xml.Schema.XmlSchemaSet> se pasa al método de proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="02c6a-201">El método puede agregar cualquier esquema válido al conjunto de esquemas.</span><span class="sxs-lookup"><span data-stu-id="02c6a-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="02c6a-202">El conjunto de esquemas contiene el esquema conocido en el momento de la exportación del esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="02c6a-203">Cuando el método de proveedor de esquema debe agregar un elemento al conjunto de esquemas, debe determinar si en el esquema ya existe un <xref:System.Xml.Schema.XmlSchema> con el espacio de nombres adecuado.</span><span class="sxs-lookup"><span data-stu-id="02c6a-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="02c6a-204">Si ya existe, el método de proveedor de esquema debe agregar el nuevo elemento al `XmlSchema` existente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="02c6a-205">De lo contrario, debe crear una nueva instancia `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="02c6a-206">Esto es importante si se utilizan las matrices de los tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="02c6a-207">Por ejemplo, si tiene un tipo `IXmlSerializable` que se exporta como tipo "A" en el espacio de nombres "B", es posible que cuando al llamar al método de proveedor de esquema, el conjunto de esquemas ya contenga el esquema para que "B" incluya el tipo "ArrayOfA."</span><span class="sxs-lookup"><span data-stu-id="02c6a-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="02c6a-208">Además de agregar los tipos a <xref:System.Xml.Schema.XmlSchemaSet>, el método de proveedor de esquema para los tipos de contenido debe devolver un valor no nulo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="02c6a-209">Puede devolver un <xref:System.Xml.XmlQualifiedName> que especifique el nombre del tipo de esquema que se utilizará para el tipo `IXmlSerializable` concreto.</span><span class="sxs-lookup"><span data-stu-id="02c6a-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="02c6a-210">Este nombre completo también actúa como el nombre de contrato de datos y el espacio de nombres del tipo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="02c6a-211">Se permite devolver un tipo que no existe en el esquema establecido inmediatamente cuando vuelve el método del proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="02c6a-212">No obstante, se espera que en el momento de exportar todos los tipos relacionados (se llama al método <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> para todos los tipos relevantes en el <xref:System.Runtime.Serialization.XsdDataContractExporter>, y se tiene acceso a la propiedad <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>), el tipo existirá en el conjunto de esquemas.</span><span class="sxs-lookup"><span data-stu-id="02c6a-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="02c6a-213">Teniendo acceso a la propiedad `Schemas` antes de que se hayan realizado todas las llamadas `Export` pertinentes puede producir <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="02c6a-214">Para obtener más información sobre el proceso de exportación, vea [exportar esquemas de clases](exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="02c6a-214">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="02c6a-215">El método de proveedor de esquema también puede devolver el <xref:System.Xml.Schema.XmlSchemaType> que se va a utilizar.</span><span class="sxs-lookup"><span data-stu-id="02c6a-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="02c6a-216">El tipo puede o no ser anónimo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="02c6a-217">Si es anónimo, el esquema para el tipo `IXmlSerializable` se exporta como tipo anónimo cada vez que el tipo `IXmlSerializable` se utiliza como un miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="02c6a-218">El tipo `IXmlSerializable` aún tiene un nombre de contrato de datos y un espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="02c6a-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="02c6a-219">(Esto se determina como se describe en [nombres de contrato de datos](data-contract-names.md) , salvo que el <xref:System.Runtime.Serialization.DataContractAttribute> atributo no se puede usar para personalizar el nombre). Si no es anónimo, debe ser uno de los tipos de `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="02c6a-219">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="02c6a-220">Este caso es equivalente a la devolución del `XmlQualifiedName` del tipo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="02c6a-221">Además, se exporta una declaración de elemento global para el tipo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="02c6a-222">Si el tipo no tiene el atributo <xref:System.Xml.Serialization.XmlRootAttribute> aplicado, el elemento tiene el mismo nombre y espacio de nombres que el contrato de datos, y su propiedad "nillable" será `true`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="02c6a-223">La única excepción a esto es el espacio de nombres del esquema ( `http://www.w3.org/2001/XMLSchema` ): Si el contrato de datos del tipo está en este espacio de nombres, el elemento global correspondiente se encuentra en el espacio de nombres en blanco porque está prohibido agregar nuevos elementos al espacio de nombres del esquema.</span><span class="sxs-lookup"><span data-stu-id="02c6a-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="02c6a-224">Si el tipo tiene el atributo `XmlRootAttribute` aplicado, la declaración del elemento global se exporta mediante las siguientes propiedades: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> y <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="02c6a-225">Los valores predeterminados con `XmlRootAttribute` aplicados son el nombre de contrato de datos, un espacio de nombres en blanco y "nillable" como `true`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="02c6a-226">Las mismas reglas de la declaración de elemento globales se aplican a los tipos de conjunto de datos heredados.</span><span class="sxs-lookup"><span data-stu-id="02c6a-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="02c6a-227">Tenga en cuenta que `XmlRootAttribute` no puede invalidar declaraciones de elemento globales agregadas a través de código personalizado, o agregadas a `XmlSchemaSet` mediante el método de proveedor de esquema o a través de `GetSchema` para los tipos de conjunto de datos heredados.</span><span class="sxs-lookup"><span data-stu-id="02c6a-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="02c6a-228">Tipos de elemento de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="02c6a-228">IXmlSerializable Element Types</span></span>

<span data-ttu-id="02c6a-229">Los tipos de elemento `IXmlSerializable` hacen que la propiedad `IsAny` se establezca en `true` o hacen que su método de proveedor de esquema se vuelva `null`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="02c6a-230">Serializar y deserializar un tipo de elemento es muy similar a serializar y deserializar un tipo de contenido.</span><span class="sxs-lookup"><span data-stu-id="02c6a-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="02c6a-231">Sin embargo, hay algunas diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="02c6a-231">However, there are some important differences:</span></span>

- <span data-ttu-id="02c6a-232">Se espera que la implementación `WriteXml` escriba exactamente un elemento (qué podría contener, por supuesto, varios elementos secundarios).</span><span class="sxs-lookup"><span data-stu-id="02c6a-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="02c6a-233">No debería estar escribiendo los atributos fuera de este elemento único, varios elementos del mismo nivel o contenido mixto.</span><span class="sxs-lookup"><span data-stu-id="02c6a-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="02c6a-234">El elemento puede estar vacío.</span><span class="sxs-lookup"><span data-stu-id="02c6a-234">The element may be empty.</span></span>

- <span data-ttu-id="02c6a-235">La implementación `ReadXml` no debería leer el elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="02c6a-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="02c6a-236">Se espera que lea el un elemento que `WriteXml` genera.</span><span class="sxs-lookup"><span data-stu-id="02c6a-236">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="02c6a-237">Al serializar de manera regular un tipo de elemento (por ejemplo, como un miembro de datos en un contrato de datos), el serializador producirá un elemento contenedor antes de llamar a `WriteXml`, como en los tipos de contenido.</span><span class="sxs-lookup"><span data-stu-id="02c6a-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="02c6a-238">No obstante, al serializar un tipo de elemento en el nivel superior, normalmente, el serializador no produce un elemento contenedor alrededor del elemento que `WriteXml` escribe, salvo que se especifiquen explícitamente un nombre de raíz y un espacio de nombres al construir el serializador en los constructores `DataContractSerializer` o `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="02c6a-239">Para obtener más información, vea [serialización y deserialización](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="02c6a-239">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="02c6a-240">Cuando se serializa un tipo de elemento en el nivel superior sin especificar el nombre de raíz y el espacio de nombres en el momento de la construcción, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> y <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> no hacen prácticamente nada, y <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> llama a `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="02c6a-241">En este modo, el objeto que se serializa no puede ser `null` y no se puede asignar polimórficamente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="02c6a-242">Además, la preservación del gráfico de objetos puede se puede habilitar y no se puede utilizar `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="02c6a-243">Al deserializar un tipo de elemento en el nivel superior sin especificar el nombre y el espacio de nombres raíz en el momento de la construcción, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> devuelve `true` si encuentra el inicio de cualquier elemento.</span><span class="sxs-lookup"><span data-stu-id="02c6a-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="02c6a-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> con el parámetro `verifyObjectName` establecido en `true` se comporta igual que `IsStartObject` antes realmente de leer el objeto realmente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="02c6a-245">`ReadObject` después pasa el control al método `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-245">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="02c6a-246">El esquema exportado para los tipos de elemento es igual que para el tipo `XmlElement` tal y como se ha descrito en una sección anterior, excepto que el método de proveedor de esquema puede agregar un esquema adicional a <xref:System.Xml.Schema.XmlSchemaSet> como con los tipos de contenido.</span><span class="sxs-lookup"><span data-stu-id="02c6a-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="02c6a-247">No se permite utilizar el atributo `XmlRootAttribute` con tipos de elemento y las declaraciones de elemento globales nunca se emiten para estos tipos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="02c6a-248">Diferencias respecto a XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="02c6a-248">Differences from the XmlSerializer</span></span>

<span data-ttu-id="02c6a-249">`IXmlSerializable` entiende también la interfaz `XmlSchemaProviderAttribute` y `XmlRootAttribute` y los atributos <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="02c6a-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="02c6a-250">Sin embargo, hay algunas diferencias en cómo se tratan estos en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="02c6a-251">Las principales diferencias se resumen en la lista siguiente:</span><span class="sxs-lookup"><span data-stu-id="02c6a-251">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="02c6a-252">El método de proveedor de esquema debe ser público para ser utilizable en `XmlSerializer`, pero no tiene que ser público para ser utilizable en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="02c6a-253">Se llama al método de proveedor de esquema cuando `IsAny` es `true` en el modelo del contrato de datos pero no con `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="02c6a-254">Cuando el atributo `XmlRootAttribute` no está presente para contenido o tipos de conjunto de datos heredados, `XmlSerializer` exporta una declaración de elemento global en el espacio de nombres en blanco.</span><span class="sxs-lookup"><span data-stu-id="02c6a-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="02c6a-255">En el modelo del contrato de datos, el espacio de nombres utilizado es normalmente el espacio de nombres de contrato de datos, tal y como se ha descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="02c6a-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="02c6a-256">Tenga en cuenta estas diferencias cuando cree tipos que se utilizan con ambas tecnologías de serialización.</span><span class="sxs-lookup"><span data-stu-id="02c6a-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="02c6a-257">Importar el esquema de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="02c6a-257">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="02c6a-258">Al importar un esquema generado a partir de los tipos `IXmlSerializable`, existen pocas posibilidades:</span><span class="sxs-lookup"><span data-stu-id="02c6a-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="02c6a-259">El esquema generado puede ser un esquema de contrato de datos válido, tal como se describe en [referencia de esquema de contrato de datos](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="02c6a-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="02c6a-260">En este caso, el esquema puede importarse como de costumbre y se generarán los tipos de contrato de datos normales.</span><span class="sxs-lookup"><span data-stu-id="02c6a-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="02c6a-261">El esquema generado no puede ser un esquema de contrato de datos válido.</span><span class="sxs-lookup"><span data-stu-id="02c6a-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="02c6a-262">Por ejemplo, su método de proveedor de esquema puede generar un esquema que incluye atributos XML que no se admiten en el modelo de contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="02c6a-263">En este caso, puede importar el esquema como tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="02c6a-264">Este modo de importación no está activado de forma predeterminada, pero se puede habilitar fácilmente; por ejemplo, con el `/importXmlTypes` modificador de la línea de comandos para la [herramienta de utilidad de metadatos de ServiceModel (SvcUtil. exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="02c6a-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="02c6a-265">Esto se describe en detalle en el [esquema de importación para generar clases](importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="02c6a-265">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="02c6a-266">Tenga en cuenta que debe trabajar directamente con XML para sus instancias de tipo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="02c6a-267">También puede considerar la utilización de una tecnología de serialización diferente que admita una gama más amplia de esquemas. Vea el tema acerca de la utilización del `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="02c6a-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="02c6a-268">Puede desear volver a usar sus tipos `IXmlSerializable` existentes en el proxy en lugar de generar nuevos.</span><span class="sxs-lookup"><span data-stu-id="02c6a-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="02c6a-269">En este caso, la característica de tipos a la cual s se hace referencia descrita en el tema Esquema de Importación para generar Tipos se puede utilizar para indicar el tipo que se reutilizará.</span><span class="sxs-lookup"><span data-stu-id="02c6a-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="02c6a-270">Esto se corresponde con el uso del modificador `/reference` en svcutil.exe, que especifica el ensamblado que contiene los tipos que se van a volver a usar.</span><span class="sxs-lookup"><span data-stu-id="02c6a-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="02c6a-271">Comportamiento heredado de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="02c6a-271">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="02c6a-272">En .NET Framework 4.0.0 y versiones anteriores, XmlSerializer generaba ensamblados temporales de serialización escribiendo código de C# en un archivo.</span><span class="sxs-lookup"><span data-stu-id="02c6a-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="02c6a-273">El archivo se compiló en un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="02c6a-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="02c6a-274">Este comportamiento tenía algunas consecuencias no deseadas como la reducción del tiempo de inicio para el serializador.</span><span class="sxs-lookup"><span data-stu-id="02c6a-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="02c6a-275">En .NET Framework 4.0.5, este comportamiento se cambió para generar los ensamblados sin que sea necesario el uso del compilador.</span><span class="sxs-lookup"><span data-stu-id="02c6a-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="02c6a-276">Algunos desarrolladores quizás deseen ver el código de C# generado.</span><span class="sxs-lookup"><span data-stu-id="02c6a-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="02c6a-277">Puede especificar usar este comportamiento heredado mediante la siguiente configuración:</span><span class="sxs-lookup"><span data-stu-id="02c6a-277">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="02c6a-278">Si surgen problemas de compatibilidad, como la `XmlSerializer` no serialización de una clase derivada con una invalidación nueva no pública, puede volver al `XMLSerializer` comportamiento heredado mediante la siguiente configuración:</span><span class="sxs-lookup"><span data-stu-id="02c6a-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="02c6a-279">Como alternativa a la configuración anterior, puede usar la configuración siguiente en un equipo que ejecute .NET Framework 4,5 o una versión posterior:</span><span class="sxs-lookup"><span data-stu-id="02c6a-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="02c6a-280">El `<xmlSerializer useLegacySerializerGeneration="true"/>` modificador solo funciona en un equipo que ejecute .NET Framework 4,5 o una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="02c6a-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="02c6a-281">El `appSettings` enfoque anterior funciona en todas las versiones .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="02c6a-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="02c6a-282">Vea también</span><span class="sxs-lookup"><span data-stu-id="02c6a-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="02c6a-283">Especificación de transferencia de datos en contratos de servicio</span><span class="sxs-lookup"><span data-stu-id="02c6a-283">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="02c6a-284">Utilización de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="02c6a-284">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="02c6a-285">Procedimiento para mejorar el tiempo de inicio de las aplicaciones cliente WCF mediante XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="02c6a-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
