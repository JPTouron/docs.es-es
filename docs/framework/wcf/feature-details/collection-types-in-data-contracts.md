---
title: Tipos de colección en contratos de datos
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: a10b7c5295407cfbb36446581a4b75670e37bc6a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/09/2020
ms.locfileid: "84579754"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="8d6ed-102">Tipos de colección en contratos de datos</span><span class="sxs-lookup"><span data-stu-id="8d6ed-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="8d6ed-103">Una *colección* es una lista de elementos de un determinado tipo.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="8d6ed-104">En el .NET Framework, estas listas se pueden representar utilizando matrices o una variedad de otros tipos (lista genérica, genérica <xref:System.ComponentModel.BindingList%601> , <xref:System.Collections.Specialized.StringCollection> o <xref:System.Collections.ArrayList> ).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="8d6ed-105">Por ejemplo, una colección puede albergar una lista de direcciones para un determinado cliente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="8d6ed-106">Estas colecciones se denominan *colecciones de lista*, con independencia de cual sea su tipo real.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="8d6ed-107">Existe una forma especial de colección que representa una asociación entre un elemento (la "clave") y otro (el "valor").</span><span class="sxs-lookup"><span data-stu-id="8d6ed-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="8d6ed-108">En el .NET Framework, se representan mediante tipos como <xref:System.Collections.Hashtable> y el Diccionario genérico.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="8d6ed-109">Por ejemplo, una colección de asociaciones puede asignar una ciudad ("clave") a su población ("valor").</span><span class="sxs-lookup"><span data-stu-id="8d6ed-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="8d6ed-110">Estas colecciones se denominan *colecciones de diccionario*, con independencia de cual sea su tipo real.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="8d6ed-111">Las colecciones reciben un tratamiento especial en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="8d6ed-112">Los tipos que implementan la interfaz <xref:System.Collections.IEnumerable> , incluyendo las matrices y las colecciones genéricas, se reconocen como colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="8d6ed-113">De entre ellos, los tipos que implementan <xref:System.Collections.IDictionary> o las interfaces <xref:System.Collections.Generic.IDictionary%602> genéricas son colecciones de diccionarios; todos los otros son colecciones de listas.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="8d6ed-114">Los requisitos adicionales en los tipos de colección, como tener un método llamado `Add` y un constructor sin parámetros, se describen en detalle en las secciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="8d6ed-115">Esto garantiza que los tipos de colección se puedan tanto serializar como deserializar.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="8d6ed-116">Esto significa que algunas colecciones no se admiten directamente, como el genérico <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (porque no tiene ningún constructor sin parámetros).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="8d6ed-117">Sin embargo, para información sobre cómo burlar estas restricciones, vea la sección "Utilizar tipos de interfaz de colección y colecciones de solo lectura" a continuación de este tema.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="8d6ed-118">Los tipos contenidos en las colecciones deben ser tipos de contrato de datos o, de lo contrario, se deben poder serializar.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="8d6ed-119">Para obtener más información, vea [tipos admitidos por el serializador de contrato de datos](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-119">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="8d6ed-120">Para obtener más información acerca de qué es y qué no se considera una colección válida, así como sobre cómo se serializan las colecciones, vea la información sobre la serialización de colecciones en la sección "reglas avanzadas de colección" de este tema.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="8d6ed-121">Colecciones intercambiables</span><span class="sxs-lookup"><span data-stu-id="8d6ed-121">Interchangeable Collections</span></span>

<span data-ttu-id="8d6ed-122">Se considera que todas las colecciones de listas del mismo tipo tienen el mismo contrato de datos (a menos que se personalicen utilizando el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , como se aborda más adelante en este tema).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="8d6ed-123">Así, por ejemplo, los contratos de datos siguientes son equivalentes.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="8d6ed-124">Ambos contratos de datos generan XML similar al código siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="8d6ed-125">La intercambiabilidad de colecciones permite utilizar, por ejemplo, un tipo de colección optimizado para rendimiento en el servidor y un tipo de colección diseñado para estar enlazado a los componentes de la interfaz de usuario en el cliente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="8d6ed-126">De manera similar a las colecciones de listas, se considera que todas las colecciones de diccionarios que tienen la misma clave y tipos de valor tienen el mismo contrato de datos (a menos que se personalicen utilizando el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="8d6ed-127">Solo el tipo de contrato de datos importa en lo relativo a la equivalencia de colección, no los tipos .NET.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="8d6ed-128">Es decir, una colección de Type1 se considera equivalente a una colección de Type2 si Type1 y Type2 tienen contratos de datos equivalentes.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="8d6ed-129">Se considera que las colecciones no genéricas tienen el mismo contrato de datos que las colecciones genéricas de tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="8d6ed-130">(Por ejemplo, los contratos de datos para <xref:System.Collections.ArrayList> y la <xref:System.Collections.Generic.List%601> genérica de `Object` son los mismos.)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="8d6ed-131">Utilizar tipos de interfaz de colección y colecciones de solo lectura</span><span class="sxs-lookup"><span data-stu-id="8d6ed-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="8d6ed-132">Los tipos de interfaz de colección (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, <xref:System.Collections.Generic.IDictionary%602>genérico, o interfaces derivadas de estas interfaces) también se considera que tienen contratos de datos de colección, equivalentes a los contratos de datos de colección para los tipos de colección reales.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="8d6ed-133">Por lo tanto, es posible declarar el tipo que se está serializando como un tipo de interfaz de colección y los resultados son los mismos que si se hubiese utilizado un tipo de colección real.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="8d6ed-134">Por ejemplo, los contratos de datos siguientes son equivalentes.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="8d6ed-135">Durante la serialización, cuando el tipo declarado es una interfaz, el tipo de instancia real que se usa puede ser cualquier tipo que implemente esa interfaz.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="8d6ed-136">Las restricciones descritas anteriormente (con un constructor sin parámetros y un `Add` método) no se aplican.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="8d6ed-137">Por ejemplo, puede establecer direcciones en Customer2 en una instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> genérica de dirección, aunque no pueda declarar directamente un miembro de datos de tipo <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>genérica.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="8d6ed-138">Durante la deserialización, cuando el tipo declarado es una interfaz, el motor de serialización elige un tipo que implemente la interfaz declarada y se crea una instancia del tipo.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="8d6ed-139">El mecanismo de tipos conocidos (descrito en [tipos conocidos de contratos de datos](data-contract-known-types.md)) no tiene ningún efecto aquí; la elección de tipo está integrada en WCF.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-139">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="8d6ed-140">Personalizar tipos de colección</span><span class="sxs-lookup"><span data-stu-id="8d6ed-140">Customizing Collection Types</span></span>

<span data-ttu-id="8d6ed-141">Puede personalizar tipos de colección utilizando el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , que tiene varios usos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="8d6ed-142">Observe que al personalizar los tipos de colección se pone en peligro la posibilidad de intercambio de colecciones, por lo que normalmente se recomienda evitar aplicar este atributo siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="8d6ed-143">Para obtener más información acerca de este problema, consulte la sección "reglas avanzadas de colección" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="8d6ed-144">Denominación de contrato de datos de colección</span><span class="sxs-lookup"><span data-stu-id="8d6ed-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="8d6ed-145">Las reglas para denominar los tipos de colección son similares a las existentes para denominar los tipos de contrato de datos normales, como se describe en [Data Contract Names](data-contract-names.md), aunque existen algunas diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="8d6ed-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="8d6ed-146">El atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> se utiliza para personalizar el nombre, en lugar del atributo <xref:System.Runtime.Serialization.DataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="8d6ed-147">El atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> también tiene propiedades `Name` y `Namespace` .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="8d6ed-148">Cuando no se aplica el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , el nombre predeterminado y el espacio de nombres para los tipos de colección dependen de los nombres y espacios de nombres de tipos contenidos dentro de la colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="8d6ed-149">No se ven afectados por el nombre ni el espacio de nombres del propio tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="8d6ed-150">Para obtener un ejemplo, vea los tipos siguientes.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="8d6ed-151">El nombre del contrato de datos de ambos tipos es "ArrayOfstring" y no "CustomerList1" o "StringList1".</span><span class="sxs-lookup"><span data-stu-id="8d6ed-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="8d6ed-152">Esto significa que la serialización de uno de estos tipos en el nivel raíz aporta XML similar al código siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="8d6ed-153">Esta regla de nomenclatura se eligió para garantizar que un tipo no personalizado que represente una lista de cadenas tenga el mismo contrato de datos y la misma representación XML.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="8d6ed-154">Esto posibilita la intercambiabilidad de colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="8d6ed-155">En este ejemplo, CustomerList1 y StringList1 son completamente intercambiables.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="8d6ed-156">Sin embargo, cuando se aplica el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , la colección se vuelve un contrato de datos de colección personalizado, aunque no se haya establecido ninguna propiedad en el atributo.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="8d6ed-157">El nombre y espacio de nombres del contrato de datos de colección dependen del propio tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="8d6ed-158">Para ver un ejemplo, vea el tipo siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="8d6ed-159">Al serializar, el XML resultante es similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="8d6ed-160">Tenga en cuenta que ha dejado de ser equivalente a la representación XML de los tipos no personalizados.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="8d6ed-161">Puede utilizar las propiedades `Name` y `Namespace` para personalizar más la denominación.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="8d6ed-162">Vea la siguiente clase.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="8d6ed-163">El XML resultante es similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="8d6ed-164">Para obtener más información, vea la sección "reglas avanzadas de colección" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="8d6ed-165">Personalizar el nombre de elementos repetidos en colecciones de listas</span><span class="sxs-lookup"><span data-stu-id="8d6ed-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="8d6ed-166">Las colecciones de listas contienen entradas repetidas.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-166">List collections contain repeating entries.</span></span> <span data-ttu-id="8d6ed-167">Normalmente, cada entrada repetida se representa como un elemento denominado según el nombre del contrato de datos del tipo contenido en la colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="8d6ed-168">En los ejemplos `CustomerList` , las colecciones contenían cadenas.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="8d6ed-169">El nombre del contrato de datos para el tipo primitivo de cadena es "String", por lo que el elemento repetido era " \<string> ".</span><span class="sxs-lookup"><span data-stu-id="8d6ed-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="8d6ed-170">Sin embargo, utilizando la propiedad <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> en el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , se puede personalizar este nombre de elementos repetidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="8d6ed-171">Para ver un ejemplo, vea el tipo siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="8d6ed-172">El XML resultante es similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="8d6ed-173">El espacio de nombres del elemento repetido es siempre igual al espacio de nombres del contrato de datos de la colección, que se puede personalizar mediante la propiedad `Namespace` , como se comentaba anteriormente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="8d6ed-174">Personalizar las colecciones de diccionarios</span><span class="sxs-lookup"><span data-stu-id="8d6ed-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="8d6ed-175">Las colecciones de diccionarios son esencialmente listas de entradas, donde cada entrada tiene una clave seguida de un valor.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="8d6ed-176">Al igual que sucede con las listas normales, puede cambiar el nombre de elemento que corresponde al elemento repetido mediante la propiedad <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="8d6ed-177">Además, puede cambiar los nombres de elemento que representan la clave y el valor utilizando las propiedades <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> y <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="8d6ed-178">Los espacios de nombres para estos elementos son los mismos que el espacio de nombres del contrato de datos de colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="8d6ed-179">Para ver un ejemplo, vea el tipo siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="8d6ed-180">Al serializar, el XML resultante es similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="8d6ed-181">Para obtener más información acerca de las colecciones de diccionario, vea la sección "reglas avanzadas de colección" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="8d6ed-182">Colecciones y tipos conocidos</span><span class="sxs-lookup"><span data-stu-id="8d6ed-182">Collections and Known Types</span></span>

<span data-ttu-id="8d6ed-183">No necesita agregar tipos de colección a los tipos conocidos al utilizarlos polimórficamente en lugar de otras colecciones o interfaces de colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="8d6ed-184">Por ejemplo, si declara un miembro de datos de tipo <xref:System.Collections.IEnumerable> y lo utiliza para enviar una instancia de <xref:System.Collections.ArrayList>, no necesita agregar <xref:System.Collections.ArrayList> a los tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="8d6ed-185">Si se usan colecciones polimórficamente en lugar de tipos de no colección, deben agregarse a tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="8d6ed-186">Por ejemplo, si declara un miembro de datos de tipo `Object` y lo usa para enviar una instancia de <xref:System.Collections.ArrayList>, necesita agregar <xref:System.Collections.ArrayList> a los tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="8d6ed-187">Esto no le permite serializar polimórficamente cualquier colección equivalente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="8d6ed-188">Por ejemplo, el hecho de agregar <xref:System.Collections.ArrayList> a la lista de tipos conocidos en el ejemplo anterior no le permite asignar la clase `Array of Object` , aunque tenga un contrato de datos equivalente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="8d6ed-189">Este comportamiento no es diferente al de los tipos conocidos normales en la serialización de tipos de no colección, pero es especialmente importante tenerlo claro en el caso de las colecciones, porque es muy frecuente que las colecciones sean equivalentes.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="8d6ed-190">Durante la serialización, solo un tipo puede ser conocido en un ámbito dado para un contrato de datos determinado, y todas las colecciones equivalentes tienen los mismos contratos de datos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="8d6ed-191">Esto significa que, en el ejemplo anterior, no se puede agregar <xref:System.Collections.ArrayList> y `Array of Object` a tipos conocidos en el mismo ámbito.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="8d6ed-192">De nuevo, esto equivale al comportamiento de tipos conocidos para los tipos de no colección, pero es especialmente importante entenderlo para las colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="8d6ed-193">Los tipos conocidos también se pueden requerir para el contenido de colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="8d6ed-194">Por ejemplo, si <xref:System.Collections.ArrayList> realmente contiene instancias de `Type1` y `Type2`, estos dos tipos se deberían agregar a los tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="8d6ed-195">El ejemplo siguiente muestra un gráfico de objeto correctamente construido utilizando colecciones y tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="8d6ed-196">(El ejemplo está un poco retocado, porque en una aplicación real normalmente no se definirían los miembros de datos siguientes como `Object`y, por consiguiente, no tendría problemas con los tipos conocidos o de polimorfismo.)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="8d6ed-197">Durante la deserialización, si el tipo declarado es un tipo de colección, se crea la instancia del tipo declarado independientemente del tipo que realmente se envió.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="8d6ed-198">Si el tipo declarado es una interfaz de colección, el deserializador escoge un tipo a partir del cual se va a crear una instancia independientemente de los tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="8d6ed-199">También durante la deserialización, si el tipo declarado no es un tipo de colección pero se está enviando un tipo de colección, se seleccionará un tipo de colección coincidente de la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="8d6ed-200">Es posible agregar los tipos de interfaz de colección a la lista de tipos conocidos durante la deserialización.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="8d6ed-201">En este caso, el motor de la deserialización escoge de nuevo un tipo a partir del cual se va a crear una instancia.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="8d6ed-202">Colecciones y la clase NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="8d6ed-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="8d6ed-203">Cuando se usa la clase <xref:System.Runtime.Serialization.NetDataContractSerializer> , los tipos de colección no personalizados (sin el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ) que no son matrices pierden su significado especial.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="8d6ed-204">La clase <xref:System.SerializableAttribute> todavía puede serializar los tipos de colección no personalizados marcados con el atributo <xref:System.Runtime.Serialization.NetDataContractSerializer> de conformidad con el atributo <xref:System.SerializableAttribute> o las reglas de interfaz <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="8d6ed-205">Los tipos de colección personalizados, las interfaces de colección y las matrices todavía se tratan como colecciones, incluso cuando la clase <xref:System.Runtime.Serialization.NetDataContractSerializer> está en uso.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="8d6ed-206">Colecciones y esquema</span><span class="sxs-lookup"><span data-stu-id="8d6ed-206">Collections and Schema</span></span>

<span data-ttu-id="8d6ed-207">Todas las colecciones equivalentes tienen la misma representación en lenguaje de definición de esquemas XML (XSD).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="8d6ed-208">Como consecuencia, normalmente no se obtiene el mismo tipo de colección en el código de cliente generado y en el servidor.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="8d6ed-209">Por ejemplo, el servidor puede utilizar un contrato de datos con una <xref:System.Collections.Generic.List%601> genérica de miembro de datos entero, pero en el código de cliente generado el mismo miembro de datos se puede convertir en una matriz de enteros.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="8d6ed-210">Las colecciones de diccionario se marcan con una anotación de esquema específica de WCF que indica que son diccionarios; de lo contrario, no se distinguen de las listas simples que contienen entradas con una clave y un valor.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="8d6ed-211">Para una descripción exacta de cómo se representan las colecciones en el esquema del contrato de datos, consulte [Data Contract Schema Reference](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="8d6ed-212">De forma predeterminada, no se generan tipos para las colecciones no personalizadas en el código importado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="8d6ed-213">Los miembros de datos de tipos de colección de listas se importan como matrices, y los miembros de datos de tipos de colección de diccionarios se importan como diccionario genérico.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="8d6ed-214">Sin embargo, para las colecciones personalizadas, se generan tipos separados, marcados con el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="8d6ed-215">(Un tipo de colección personalizado en el esquema es aquél que no utiliza el espacio de nombres predeterminado, el nombre, el nombre de elemento de repetición o los nombres de elementos de clave y valor). Estos tipos son tipos vacíos que derivan de genéricos <xref:System.Collections.Generic.List%601> para tipos de lista y Diccionario genérico para tipos de diccionario.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="8d6ed-216">Por ejemplo, puede tener los tipos siguientes en el servidor.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="8d6ed-217">Cuando el esquema se exporta y se vuelve a importar, el código de cliente generado es similar al siguiente (para facilitar la lectura, se muestran los campos en lugar de las propiedades).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="8d6ed-218">Puede desear utilizar unos tipos en el código generado que sean diferentes a los predeterminados.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="8d6ed-219">Por ejemplo, puede desear utilizar <xref:System.ComponentModel.BindingList%601> genérica en lugar de las matrices normales para sus miembros de datos para que sea más fácil enlazarlos a los componentes de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="8d6ed-220">Para elegir los tipos de colección a generar, pase una lista de tipos de colección que desee utilizar en la propiedad <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> del objeto <xref:System.Runtime.Serialization.ImportOptions> al importar el esquema.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="8d6ed-221">Estos tipos se denominan *tipos de colección de referencia*.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="8d6ed-222">Cuando se hace referencia a tipos genéricos, deben ser genéricos totalmente abiertos o genéricos totalmente cerrados.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="8d6ed-223">Al usar la herramienta Svcutil.exe, la referencia se puede realizar mediante el uso del modificador de la línea de comandos **/collectionType** (forma corta: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="8d6ed-224">Tenga en cuenta que también debe especificar el ensamblado para los tipos de colección a los que se hace referencia mediante el uso del modificador **/reference** (forma corta: **/r**).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="8d6ed-225">Si el tipo es genérico, debe ir seguido de una comilla atrás y el número de parámetros genéricos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="8d6ed-226">La comilla ( \` ) no se debe confundir con el carácter de comilla simple (').</span><span class="sxs-lookup"><span data-stu-id="8d6ed-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="8d6ed-227">Puede especificar varios tipos de colección de referencia mediante el uso del modificador **/collectionType** más de una vez.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="8d6ed-228">Por ejemplo, para que todas las listas se importen como de tipo <xref:System.Collections.Generic.List%601>genérico.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="8d6ed-229">Al importar una colección, se escanea esta lista de tipos de colección de referencia y se utiliza la colección más coincidente (si se encuentra una), ya sea como un tipo de miembro de datos (para las colecciones no personalizadas) o como un tipo base del que derivar (para las colecciones personalizadas).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="8d6ed-230">Los diccionarios solo se confrontan con los diccionarios, mientras las listas se confrontan con las listas.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="8d6ed-231">Por ejemplo, si agrega la <xref:System.ComponentModel.BindingList%601> genérica y <xref:System.Collections.Hashtable> a la lista de tipos de referencia, el código de cliente generado para el ejemplo anterior es similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="8d6ed-232">Puede especificar los tipos de interfaz de colección como parte de sus tipos de colección de referencia, pero no puede especificar tipos de colección no válidos (como aquellos sin método `Add` o constructor público).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="8d6ed-233">Se considera que un tipo genérico cerrado es el que más coincide.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="8d6ed-234">(Los tipos no genéricos se consideran equivalentes a los genéricos cerrados de `Object`.)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="8d6ed-235">Por ejemplo, si los tipos <xref:System.Collections.Generic.List%601> genéricos de <xref:System.DateTime>, <xref:System.ComponentModel.BindingList%601> genérico (abrir genérico), y <xref:System.Collections.ArrayList> son los tipos de colección de referencia, se genera lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="8d6ed-236">Para las colecciones de lista, solo se admiten los casos de la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="8d6ed-237">Tipo de referencia</span><span class="sxs-lookup"><span data-stu-id="8d6ed-237">Referenced type</span></span>|<span data-ttu-id="8d6ed-238">Interfaz implementada por el tipo de referencia</span><span class="sxs-lookup"><span data-stu-id="8d6ed-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="8d6ed-239">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="8d6ed-239">Example</span></span>|<span data-ttu-id="8d6ed-240">Tipo tratado como:</span><span class="sxs-lookup"><span data-stu-id="8d6ed-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="8d6ed-241">No genérico o genérico cerrado (cualquier número de parámetros)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="8d6ed-242">No genérico</span><span class="sxs-lookup"><span data-stu-id="8d6ed-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="8d6ed-243">o bien</span><span class="sxs-lookup"><span data-stu-id="8d6ed-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="8d6ed-244">donde T= `int`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-244">where T= `int`</span></span>|<span data-ttu-id="8d6ed-245">Genérico cerrado de `Object` (por ejemplo, `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="8d6ed-246">No genérico o genérico cerrado (cualquier número de parámetros que no necesariamente coincide con el tipo de colección)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="8d6ed-247">Genérico cerrado</span><span class="sxs-lookup"><span data-stu-id="8d6ed-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="8d6ed-248">o bien</span><span class="sxs-lookup"><span data-stu-id="8d6ed-248">or</span></span><br /><br /> <span data-ttu-id="8d6ed-249">`MyType<T> : IList<string>` donde T=`int`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="8d6ed-250">Genérico cerrado (por ejemplo, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="8d6ed-251">Genérico cerrado con cualquier número de parámetros</span><span class="sxs-lookup"><span data-stu-id="8d6ed-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="8d6ed-252">Abrir genérico utilizando cualquiera de los parámetros del tipo</span><span class="sxs-lookup"><span data-stu-id="8d6ed-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="8d6ed-253">donde T=`int`, U=`string`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="8d6ed-254">Genérico cerrado (por ejemplo, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="8d6ed-255">Genérico abierto con un parámetro</span><span class="sxs-lookup"><span data-stu-id="8d6ed-255">Open generic with one parameter</span></span>|<span data-ttu-id="8d6ed-256">Abrir genérico utilizando el parámetro del tipo</span><span class="sxs-lookup"><span data-stu-id="8d6ed-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="8d6ed-257">`MyType<T> : IList<T>`, T está abierto</span><span class="sxs-lookup"><span data-stu-id="8d6ed-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="8d6ed-258">Genérico abierto (por ejemplo, `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="8d6ed-259">Si un tipo implementa más de una interfaz de colección de listas, se aplican las restricciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="8d6ed-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="8d6ed-260">Si el tipo implementa varias veces <xref:System.Collections.Generic.IEnumerable%601> genérica (o sus interfaces derivadas) para los diferentes tipos, el tipo no se considera un tipo de colección de referencia válido y se ignora.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="8d6ed-261">Esto es verdad aun cuando algunas implementaciones no sean válidas o utilicen genéricos abiertos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="8d6ed-262">Por ejemplo, un tipo que implementa <xref:System.Collections.Generic.IEnumerable%601> genérica de `int` y <xref:System.Collections.Generic.IEnumerable%601> genérica de T nunca se utilizaría como una colección de referencia de `int` o cualquier otro tipo, independientemente de si el tipo tiene un método `Add` que acepta `int` o un método `Add` que acepta un parámetro de tipo T, o ambos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="8d6ed-263">Si el tipo implementa una interfaz de colección genérica así como <xref:System.Collections.IList>, el tipo nunca se usa como un tipo de colección de referencia a menos que la interfaz de colección genérica sea cerrada genérica de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="8d6ed-264">Para las colecciones de diccionario, solo se admiten los casos de la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="8d6ed-265">Tipo de referencia</span><span class="sxs-lookup"><span data-stu-id="8d6ed-265">Referenced type</span></span>|<span data-ttu-id="8d6ed-266">Interfaz implementada por el tipo de referencia</span><span class="sxs-lookup"><span data-stu-id="8d6ed-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="8d6ed-267">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="8d6ed-267">Example</span></span>|<span data-ttu-id="8d6ed-268">Tipo tratado como</span><span class="sxs-lookup"><span data-stu-id="8d6ed-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="8d6ed-269">No genérico o genérico cerrado (cualquier número de parámetros)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="8d6ed-270">o bien</span><span class="sxs-lookup"><span data-stu-id="8d6ed-270">or</span></span><br /><br /> <span data-ttu-id="8d6ed-271">`MyType<T> : IDictionary` donde T=`int`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="8d6ed-272">Genérico cerrado `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="8d6ed-273">Genérico cerrado (cualquier número de parámetros)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="8d6ed-274"><xref:System.Collections.Generic.IDictionary%602>, cerrado</span><span class="sxs-lookup"><span data-stu-id="8d6ed-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="8d6ed-275">`MyType<T> : IDictionary<string, bool>` donde T=`int`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="8d6ed-276">Genérico cerrado (por ejemplo, `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="8d6ed-277">Genérico cerrado (cualquier número de parámetros)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="8d6ed-278"><xref:System.Collections.Generic.IDictionary%602>genérico, o clave o valor está cerrado, el otro está abierto y utiliza uno de los parámetros de tipo</span><span class="sxs-lookup"><span data-stu-id="8d6ed-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="8d6ed-279">`MyType<T,U,V> : IDictionary<string,V>` donde T=`int`, U=`float`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="8d6ed-280">o bien</span><span class="sxs-lookup"><span data-stu-id="8d6ed-280">or</span></span><br /><br /> <span data-ttu-id="8d6ed-281">`MyType<Z> : IDictionary<Z,bool>` donde Z=`string`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="8d6ed-282">Genérico cerrado (por ejemplo, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="8d6ed-283">Genérico cerrado (cualquier número de parámetros)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="8d6ed-284"><xref:System.Collections.Generic.IDictionary%602>genérico, tanto clave como valor están abiertos y cada uno utiliza uno de los parámetros del tipo</span><span class="sxs-lookup"><span data-stu-id="8d6ed-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="8d6ed-285">`MyType<T,U,V> : IDictionary<V,U>` donde T=`int`, U=`bool`, V=`string`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="8d6ed-286">Genérico cerrado (por ejemplo, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="8d6ed-287">Genérico abierto (dos parámetros)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-287">Open generic (two parameters)</span></span>|<span data-ttu-id="8d6ed-288"><xref:System.Collections.Generic.IDictionary%602>genérico, abrir, utiliza los dos parámetros genéricos del tipo en el orden que aparecen</span><span class="sxs-lookup"><span data-stu-id="8d6ed-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="8d6ed-289">`MyType<K,V> : IDictionary<K,V>`, tanto K como V están abiertos</span><span class="sxs-lookup"><span data-stu-id="8d6ed-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="8d6ed-290">Genérico abierto (por ejemplo, `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="8d6ed-291">Si el tipo implementa tanto <xref:System.Collections.IDictionary> y <xref:System.Collections.Generic.IDictionary%602>genérica, solo se considera <xref:System.Collections.Generic.IDictionary%602> genérica.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="8d6ed-292">No permite hacer referencia a los tipos genéricos parciales.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="8d6ed-293">No se permiten los duplicados; por ejemplo, no se puede agregar la colección genérica <xref:System.Collections.Generic.List%601> de `Integer` y la colección genérica de `Integer` a <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, porque sería imposible determinar cuál de las dos se debe usar cuando se encuentre una lista de enteros en el esquema.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="8d6ed-294">Los duplicados se detectan solo si hay un tipo en el esquema que expone el problema de los duplicados.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="8d6ed-295">Por ejemplo, si el esquema que se importa no contiene listas de enteros, está permitido tener tanto <xref:System.Collections.Generic.List%601> genérica de `Integer` como la colección genérica de `Integer` en <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, pero ninguna tiene efecto.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="8d6ed-296">Reglas avanzadas de colección</span><span class="sxs-lookup"><span data-stu-id="8d6ed-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="8d6ed-297">Serialización de colecciones</span><span class="sxs-lookup"><span data-stu-id="8d6ed-297">Serializing Collections</span></span>

<span data-ttu-id="8d6ed-298">A continuación, se muestra una lista de las reglas de colección para la serialización:</span><span class="sxs-lookup"><span data-stu-id="8d6ed-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="8d6ed-299">Se permite combinar los tipos de colección (tener colecciones de colecciones).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="8d6ed-300">Las matrices escalonadas se tratan como colecciones de colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="8d6ed-301">No se soportan matrices multidimensionales.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="8d6ed-302">Las matrices de byte y matrices de <xref:System.Xml.XmlNode> son los tipos de matriz especiales que se tratan como primitivas, no colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="8d6ed-303">Al serializar una matriz de bytes se obtiene un elemento XML único que contiene un bloque de datos con codificación Base64, en lugar de un elemento aparte para cada byte.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="8d6ed-304">Para obtener más información sobre cómo se trata una matriz de <xref:System.Xml.XmlNode> , vea [tipos XML y ADO.net en los contratos de datos](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="8d6ed-305">Evidentemente, estos tipos especiales pueden participar en colecciones: una matriz de matriz de byte resulta en múltiples elementos XML, y cada uno de ellos contiene un bloque de datos codificados por Base64.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="8d6ed-306">Si el atributo <xref:System.Runtime.Serialization.DataContractAttribute> se aplica a un tipo de colección, el tipo se trata como un tipo de contrato de datos normal, no como una colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="8d6ed-307">Si un tipo de colección implementa la interfaz <xref:System.Xml.Serialization.IXmlSerializable> , se aplican las siguientes reglas dado un tipo `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="8d6ed-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="8d6ed-308">Si el tipo declarado es `IList<string>`, el tipo se serializa como una lista.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="8d6ed-309">Si el tipo declarado es `myType`, se serializa como `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="8d6ed-310">Si el tipo declarado es `IXmlSerializable`, se serializa como `IXmlSerializable`, pero solo si se agrega `myType` a la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="8d6ed-311">Las colecciones se serializan y deserializan con los métodos que se muestran en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="8d6ed-312">El tipo de colección implementa</span><span class="sxs-lookup"><span data-stu-id="8d6ed-312">Collection type implements</span></span>|<span data-ttu-id="8d6ed-313">Los métodos llamados durante la serialización</span><span class="sxs-lookup"><span data-stu-id="8d6ed-313">Method(s) called on serialization</span></span>|<span data-ttu-id="8d6ed-314">Métodos llamados durante la deserialización</span><span class="sxs-lookup"><span data-stu-id="8d6ed-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>|<span data-ttu-id="8d6ed-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="8d6ed-317">Agregar genérico</span><span class="sxs-lookup"><span data-stu-id="8d6ed-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="8d6ed-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="8d6ed-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph>|<span data-ttu-id="8d6ed-320">Indizador <xref:System.Collections.Generic.IList%601> genérico</span><span class="sxs-lookup"><span data-stu-id="8d6ed-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="8d6ed-321">Agregar genérico</span><span class="sxs-lookup"><span data-stu-id="8d6ed-321">Generic Add</span></span>|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.ICollection%601&gt;</ph>|<span data-ttu-id="8d6ed-323">Enumerador</span><span class="sxs-lookup"><span data-stu-id="8d6ed-323">Enumerator</span></span>|<span data-ttu-id="8d6ed-324">Agregar genérico</span><span class="sxs-lookup"><span data-stu-id="8d6ed-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="8d6ed-325"><xref:System.Collections.IList> Indizador</span><span class="sxs-lookup"><span data-stu-id="8d6ed-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|Generic <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>|`GetEnumerator`|<span data-ttu-id="8d6ed-327">Un método no estático llamado `Add` que toma un parámetro del tipo adecuado (el tipo del parámetro genérico o uno de sus tipos base).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="8d6ed-328">Este tipo de método debe existir para que el serializador pueda tratar un tipo de colección como una colección durante serialización y deserialización.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="8d6ed-329"><xref:System.Collections.IEnumerable> (y por consiguiente <xref:System.Collections.ICollection>, que deriva de él)</span><span class="sxs-lookup"><span data-stu-id="8d6ed-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="8d6ed-330">Un método no estático llamado `Add` que toma un parámetro de tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="8d6ed-331">Este tipo de método debe existir para que el serializador pueda tratar un tipo de colección como una colección durante serialización y deserialización.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="8d6ed-332">En la tabla anterior se muestran las interfaces de colección en orden descendente de prioridad.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="8d6ed-333">Por ejemplo, esto significa que si un tipo implementa tanto <xref:System.Collections.IList> como <xref:System.Collections.Generic.IEnumerable%601>genérica, la colección se serializa y deserializa según las reglas <xref:System.Collections.IList> :</span><span class="sxs-lookup"><span data-stu-id="8d6ed-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="8d6ed-334">En la deserialización, todas las colecciones se deserializan creando primero una instancia del tipo llamando al constructor sin parámetros, que debe estar presente para que el serializador trate un tipo de colección como una colección durante la serialización y la deserialización.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="8d6ed-335">Si se implementa la misma interfaz de colección genérica más de una vez (por ejemplo, si un tipo implementa tanto <xref:System.Collections.Generic.ICollection%601> genérica de `Integer` como <xref:System.Collections.Generic.ICollection%601> genérica de <xref:System.String>) y no se encuentra ninguna interfaz de la prioridad más alta, la colección no se trata como una colección válida.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="8d6ed-336">Los tipos de colección pueden tener el atributo <xref:System.SerializableAttribute> aplicado a ellos e implementar la interfaz <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="8d6ed-337">Se ignoran ambos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-337">Both of these are ignored.</span></span> <span data-ttu-id="8d6ed-338">Sin embargo, si el tipo no cumple totalmente los requisitos del tipo de colección (por ejemplo, no se encuentra el método `Add` ), no se considera un tipo de colección y, por consiguiente, se usan el atributo <xref:System.SerializableAttribute> y la interfaz <xref:System.Runtime.Serialization.ISerializable> para determinar si el tipo se puede serializar.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="8d6ed-339">Al aplicar el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> a una colección para personalizarla, se quita el mecanismo de reserva anterior de <xref:System.SerializableAttribute> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="8d6ed-340">En su lugar, si una colección personalizada no cumple los requisitos de tipo de colección, se produce una excepción <xref:System.Runtime.Serialization.InvalidDataContractException> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="8d6ed-341">La cadena de excepción contiene a menudo información que explica por qué un tipo determinado no se considera una colección válida (ningún `Add` método, ningún constructor sin parámetros, etc.), por lo que a menudo resulta útil aplicar el <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atributo con fines de depuración.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="8d6ed-342">Denominación de colección</span><span class="sxs-lookup"><span data-stu-id="8d6ed-342">Collection Naming</span></span>

<span data-ttu-id="8d6ed-343">A continuación, se muestra una lista de las reglas para denominar una colección:</span><span class="sxs-lookup"><span data-stu-id="8d6ed-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="8d6ed-344">El espacio de nombres predeterminado para todos los contratos de datos de colección de diccionarios, así como para los contratos de datos de colección de listas que contienen tipos primitivos, es `http://schemas.microsoft.com/2003/10/Serialization/Arrays` a menos que se invalide con el espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="8d6ed-345">Los tipos que se asignan a tipos XSD integrados, así como `char`, `Timespan`y los tipos `Guid` , se consideran primitivos para este propósito.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="8d6ed-346">El espacio de nombres predeterminado para tipos de colección que contienen tipos no primitivos, a menos que se invalide mediante el uso de Namespace, es el mismo que el espacio de nombres de contrato de datos del tipo contenido en la colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="8d6ed-347">El nombre predeterminado para los contratos de datos de colección de listas, a menos que se invalide utilizando Nombre, es la cadena "ArrayOf" combinada con el nombre de contrato de datos del tipo contenido en la colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="8d6ed-348">Por ejemplo, el nombre de contrato de datos para una lista genérica de enteros es "ArrayOfint."</span><span class="sxs-lookup"><span data-stu-id="8d6ed-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="8d6ed-349">Tenga presente que el nombre de contrato de datos de `Object` es "anyType", de modo que el nombre de contrato de datos de listas no genéricas como <xref:System.Collections.ArrayList> es "ArrayOfanyType."</span><span class="sxs-lookup"><span data-stu-id="8d6ed-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="8d6ed-350">El nombre predeterminado para los contratos de datos de colección de diccionarios, a menos que se invalide utilizando `Name`, es la cadena "ArrayOfKeyValueOf" combinada con el nombre de contrato de datos del tipo clave seguido por el nombre de contrato de datos del tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="8d6ed-351">Por ejemplo, el nombre de contrato de datos para un diccionario genérico de cadena y entero es "ArrayOfKeyValueOfstringint."</span><span class="sxs-lookup"><span data-stu-id="8d6ed-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="8d6ed-352">Adicionalmente, si los tipos de clave o valor no son tipos primitivos, un hash de espacio de nombres de los espacios de nombres de contrato de datos de los tipos de clave y valor se agrega al nombre.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="8d6ed-353">Para obtener más información sobre los hash de espacio de nombres, vea [nombres de contratos de datos](data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="8d6ed-353">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="8d6ed-354">Cada contrato de datos de colección de diccionarios tiene un contrato de datos complementario que representa una entrada en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="8d6ed-355">Su nombre es igual que para el contrato de datos del diccionario, salvo el prefijo "ArrayOf", y su espacio de nombres es igual que para el contrato de datos del diccionario.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="8d6ed-356">Por ejemplo, para el contrato de datos de diccionario de "ArrayOfKeyValueOfstringint", el contrato de datos de "KeyValueofstringint" representa una entrada en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="8d6ed-357">Puede personalizar el nombre de este contrato de datos utilizando la propiedad `ItemName` , como se describe en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="8d6ed-358">Las reglas de denominación de tipo genérico, como se describen en [Data Contract Names](data-contract-names.md), se aplican totalmente a los tipos de colección; es decir, puede usar llaves dentro del nombre para indicar los parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-358">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="8d6ed-359">Sin embargo, los números entre llaves hacen referencia a parámetros genéricos y no a tipos contenidos dentro de la colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="8d6ed-360">Personalización de colección</span><span class="sxs-lookup"><span data-stu-id="8d6ed-360">Collection Customization</span></span>

<span data-ttu-id="8d6ed-361">Los usos siguientes del atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> están prohibidos y producen una excepción <xref:System.Runtime.Serialization.InvalidDataContractException> :</span><span class="sxs-lookup"><span data-stu-id="8d6ed-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="8d6ed-362">Aplicar el atributo <xref:System.Runtime.Serialization.DataContractAttribute> a un tipo al que se ha aplicado el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> o a uno de sus tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="8d6ed-363">Aplicar el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> a un tipo que implementa la interfaz <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="8d6ed-364">Aplicar el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> a un tipo de no colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="8d6ed-365">Intentando establecer <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> o <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> en un atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> aplicado a un tipo de no diccionario.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="8d6ed-366">Reglas del polimorfismo</span><span class="sxs-lookup"><span data-stu-id="8d6ed-366">Polymorphism Rules</span></span>

<span data-ttu-id="8d6ed-367">Como se ha mencionado previamente, la personalización de colecciones mediante el atributo <xref:System.Runtime.Serialization.CollectionDataContractAttribute> puede interferir con la intercambiabilidad de las colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="8d6ed-368">Dos tipos de colección personalizados solo se pueden considerar equivalentes si su nombre, espacio de nombres, nombre de elemento, así como nombres de clave y valor (si son colecciones de diccionarios) coinciden.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="8d6ed-369">Debido a las personalizaciones, es posible utilizar inadvertidamente un contrato de datos de colección donde se espera otro.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="8d6ed-370">Éste debería evitarse.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-370">This should be avoided.</span></span> <span data-ttu-id="8d6ed-371">Vea los tipos siguientes.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="8d6ed-372">En este caso, una instancia de `Marks1` se puede asignar a `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="8d6ed-373">Sin embargo, no se debería utilizar `Marks2` porque su contrato de datos no se considera equivalente al contrato de datos `IList<int>` .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="8d6ed-374">El nombre del contrato de datos es "Marks2" y no "ArrayOfint", y el nombre del elemento repetido es " \<mark> " y no " \<int> ".</span><span class="sxs-lookup"><span data-stu-id="8d6ed-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="8d6ed-375">Las reglas de la tabla siguiente se aplican a la asignación polimórfica de colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="8d6ed-376">Tipo declarado</span><span class="sxs-lookup"><span data-stu-id="8d6ed-376">Declared type</span></span>|<span data-ttu-id="8d6ed-377">Asignar una colección no personalizada</span><span class="sxs-lookup"><span data-stu-id="8d6ed-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="8d6ed-378">Asignar una colección personalizada</span><span class="sxs-lookup"><span data-stu-id="8d6ed-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="8d6ed-379">Object</span><span class="sxs-lookup"><span data-stu-id="8d6ed-379">Object</span></span>|<span data-ttu-id="8d6ed-380">El nombre del contrato está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-380">Contract name is serialized.</span></span>|<span data-ttu-id="8d6ed-381">El nombre del contrato está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="8d6ed-382">Se utiliza la personalización.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-382">Customization is used.</span></span>|
|<span data-ttu-id="8d6ed-383">Interfaz de colección</span><span class="sxs-lookup"><span data-stu-id="8d6ed-383">Collection interface</span></span>|<span data-ttu-id="8d6ed-384">El nombre del contrato no está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-384">Contract name is not serialized.</span></span>|<span data-ttu-id="8d6ed-385">El nombre del contrato no está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="8d6ed-386">No se utiliza la personalización.\*</span><span class="sxs-lookup"><span data-stu-id="8d6ed-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="8d6ed-387">Colección no personalizada</span><span class="sxs-lookup"><span data-stu-id="8d6ed-387">Non-customized collection</span></span>|<span data-ttu-id="8d6ed-388">El nombre del contrato no está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-388">Contract name is not serialized.</span></span>|<span data-ttu-id="8d6ed-389">El nombre del contrato está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="8d6ed-390">Se utiliza la personalización.\*\*</span><span class="sxs-lookup"><span data-stu-id="8d6ed-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="8d6ed-391">Colección personalizada</span><span class="sxs-lookup"><span data-stu-id="8d6ed-391">Customized collection</span></span>|<span data-ttu-id="8d6ed-392">El nombre del contrato está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-392">Contract name is serialized.</span></span> <span data-ttu-id="8d6ed-393">No se utiliza la personalización.\*\*</span><span class="sxs-lookup"><span data-stu-id="8d6ed-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="8d6ed-394">El nombre del contrato está serializado.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="8d6ed-395">Se utiliza la personalización del tipo asignado.\*\*</span><span class="sxs-lookup"><span data-stu-id="8d6ed-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="8d6ed-396">\*Con la <xref:System.Runtime.Serialization.NetDataContractSerializer> clase, en este caso se utiliza la personalización.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="8d6ed-397">La clase <xref:System.Runtime.Serialization.NetDataContractSerializer> también serializa el nombre de tipo real en este caso, por lo que la deserialización funciona como se espera.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="8d6ed-398">\*\*Estos casos generan instancias no válidas para el esquema y, por tanto, deben evitarse.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="8d6ed-399">En los casos donde se serializa el nombre del contrato, el tipo de colección asignado debería estar en la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="8d6ed-400">Lo contrario también es cierto: en los casos en los que no se serializa el nombre, no es necesario agregar el tipo a la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="8d6ed-401">Una matriz de un tipo derivado se puede asignar a una matriz de un tipo base.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="8d6ed-402">En este caso, el nombre del contrato para el tipo derivado se serializa para cada elemento repetido.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="8d6ed-403">Por ejemplo, si un tipo `Book` deriva del tipo `LibraryItem`, puede asignar una matriz de `Book` a una matriz de `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="8d6ed-404">Esto no se aplica a otros tipos de colección.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-404">This does not apply to other collection types.</span></span> <span data-ttu-id="8d6ed-405">Por ejemplo, puede asignar `Generic List of Book` a `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="8d6ed-406">Sin embargo, puede asignar `Generic List of LibraryItem` que contiene las instancias `Book` .</span><span class="sxs-lookup"><span data-stu-id="8d6ed-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="8d6ed-407">Tanto en el caso de matriz como de no matriz, `Book` debería estar en la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="8d6ed-408">Preservación de colecciones y de la referencia de objetos</span><span class="sxs-lookup"><span data-stu-id="8d6ed-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="8d6ed-409">Cuando un serializador funciona en un modo donde preserva las referencias de objetos, la preservación de la referencia de objetos también se aplica a las colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="8d6ed-410">Específicamente, la identidad de objeto se preserva tanto para colecciones completas como para elementos individuales contenidos en colecciones.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="8d6ed-411">Para los diccionarios, la identidad de objeto se preserva tanto para los objetos de par clave-valor como para los objetos individuales de clave y valor.</span><span class="sxs-lookup"><span data-stu-id="8d6ed-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="8d6ed-412">Vea también</span><span class="sxs-lookup"><span data-stu-id="8d6ed-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
