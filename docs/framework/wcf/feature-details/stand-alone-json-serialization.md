---
title: Serialización de JSON independiente mediante DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 6bd075405a3bca0cc64dda90225526096b6fa8e3
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 05/29/2020
ms.locfileid: "84202390"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="42f88-102">Serialización de JSON independiente mediante DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="42f88-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="42f88-103">Este artículo trata acerca de <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .</span><span class="sxs-lookup"><span data-stu-id="42f88-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="42f88-104">Para la mayoría de los escenarios que implican la serialización y deserialización de JSON, se recomiendan las API en el [espacio de nombres System. Text. JSON](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="42f88-105">JSON (JavaScript Object Notation) es un formato de datos diseñado específicamente para usarse por código JavaScript que se ejecute en páginas web dentro del explorador.</span><span class="sxs-lookup"><span data-stu-id="42f88-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="42f88-106">Es el formato de datos predeterminado que usan los servicios de ASP.NET AJAX creados en Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="42f88-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="42f88-107">Este formato también puede usarse al crear servicios de AJAX sin integrar con ASP.NET, en este caso, XML es el valor predeterminado pero se puede elegir JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="42f88-108">Finalmente, si necesita compatibilidad JSON pero no está creando un servicio de AJAX, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> permite serializar directamente los objetos .NET en datos JSON y volver a deserializar estos datos en instancias de tipos .NET.</span><span class="sxs-lookup"><span data-stu-id="42f88-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="42f88-109">Para obtener una descripción de cómo hacerlo, consulte [Cómo: serializar y deserializar datos JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="42f88-110">Al trabajar con JSON, se admiten los mismos tipos .NET, con una pocas excepciones, como las compatibles con <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="42f88-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="42f88-111">Para obtener una lista de los tipos admitidos, consulte [tipos admitidos por el serializador de contrato de datos](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="42f88-112">Entre éstos se incluyen los tipos más primitivos, la mayoría de tipos de colección y matriz, y también tipos complejos que usan <xref:System.Runtime.Serialization.DataContractAttribute> y <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="42f88-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="42f88-113">Asignación de tipos .NET a tipos JSON</span><span class="sxs-lookup"><span data-stu-id="42f88-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="42f88-114">En la siguiente tabla se muestra la correspondencia entre los tipos .NET y los tipos JSON/JavaScript cuando se asignan mediante procedimientos de serialización y deserialización.</span><span class="sxs-lookup"><span data-stu-id="42f88-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="42f88-115">Tipos .NET</span><span class="sxs-lookup"><span data-stu-id="42f88-115">.NET Types</span></span>|<span data-ttu-id="42f88-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="42f88-116">JSON/JavaScript</span></span>|<span data-ttu-id="42f88-117">Notas</span><span class="sxs-lookup"><span data-stu-id="42f88-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="42f88-118">Todos los tipos numéricos, por ejemplo <xref:System.Int32>, <xref:System.Decimal> o <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="42f88-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="42f88-119">Número</span><span class="sxs-lookup"><span data-stu-id="42f88-119">Number</span></span>|<span data-ttu-id="42f88-120">Los valores especiales como `Double.NaN`, `Double.PositiveInfinity` y `Double.NegativeInfinity` no son compatibles y dan como resultado una JSON no válida.</span><span class="sxs-lookup"><span data-stu-id="42f88-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="42f88-121">Número</span><span class="sxs-lookup"><span data-stu-id="42f88-121">Number</span></span>|<span data-ttu-id="42f88-122">Vea "Enumeraciones y JSON" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="42f88-123">Booleano</span><span class="sxs-lookup"><span data-stu-id="42f88-123">Boolean</span></span>|--|
|<span data-ttu-id="42f88-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="42f88-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="42f88-125">String</span><span class="sxs-lookup"><span data-stu-id="42f88-125">String</span></span>|--|
|<span data-ttu-id="42f88-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="42f88-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="42f88-127">String</span><span class="sxs-lookup"><span data-stu-id="42f88-127">String</span></span>|<span data-ttu-id="42f88-128">El formato de estos tipos en JSON es el mismo que en XML (esencialmente, TimeSpan en el formato de duración ISO 8601, GUID en el formato "12345678-ABCD-ABCD-ABCD-1234567890AB" y el URI en su forma de cadena natural como " http://www.example.com ").</span><span class="sxs-lookup"><span data-stu-id="42f88-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="42f88-129">Para obtener información precisa, vea [referencia de esquema de contrato de datos](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="42f88-130">String</span><span class="sxs-lookup"><span data-stu-id="42f88-130">String</span></span>|<span data-ttu-id="42f88-131">El formato es "nombre:espaciodenombres" (cualquier cosa antes de los primeros dos puntos es el nombre).</span><span class="sxs-lookup"><span data-stu-id="42f88-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="42f88-132">Puede que falte el nombre o el espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="42f88-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="42f88-133">Si no hay ningún espacio de nombres, también se pueden omitir los dos puntos.</span><span class="sxs-lookup"><span data-stu-id="42f88-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="42f88-134"><xref:System.Array> de tipo <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="42f88-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="42f88-135">Matriz de números</span><span class="sxs-lookup"><span data-stu-id="42f88-135">Array of numbers</span></span>|<span data-ttu-id="42f88-136">Cada número representa el valor de un byte.</span><span class="sxs-lookup"><span data-stu-id="42f88-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="42f88-137">DateTime (fecha y hora) o cadena</span><span class="sxs-lookup"><span data-stu-id="42f88-137">DateTime or String</span></span>|<span data-ttu-id="42f88-138">Vea Fechas/horas y JSON más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="42f88-139">Tipo complejo</span><span class="sxs-lookup"><span data-stu-id="42f88-139">Complex type</span></span>|<span data-ttu-id="42f88-140">Vea Fechas/horas y JSON más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="42f88-141">Tipos XML y ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="42f88-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="42f88-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="42f88-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="42f88-143">Matrices de <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="42f88-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="42f88-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="42f88-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="42f88-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="42f88-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="42f88-146">String</span><span class="sxs-lookup"><span data-stu-id="42f88-146">String</span></span>|<span data-ttu-id="42f88-147">Consulte la sección Tipos XML y JSON en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="42f88-148">Tipo complejo vacío</span><span class="sxs-lookup"><span data-stu-id="42f88-148">Empty complex type</span></span>|--|
|<span data-ttu-id="42f88-149">Colecciones, diccionarios y matrices</span><span class="sxs-lookup"><span data-stu-id="42f88-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="42f88-150">Matriz</span><span class="sxs-lookup"><span data-stu-id="42f88-150">Array</span></span>|<span data-ttu-id="42f88-151">Consulte la sección Colecciones, diccionarios y matrices en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="42f88-152">Tipos complejos (con el <xref:System.Runtime.Serialization.DataContractAttribute> o <xref:System.SerializableAttribute> aplicado)</span><span class="sxs-lookup"><span data-stu-id="42f88-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="42f88-153">Tipo complejo</span><span class="sxs-lookup"><span data-stu-id="42f88-153">Complex type</span></span>|<span data-ttu-id="42f88-154">Los miembros de datos se convierten en miembros del tipo complejo de Javascript.</span><span class="sxs-lookup"><span data-stu-id="42f88-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="42f88-155">Tipos complejos que implementan la interfaz <xref:System.Runtime.Serialization.ISerializable>)</span><span class="sxs-lookup"><span data-stu-id="42f88-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="42f88-156">Tipo complejo</span><span class="sxs-lookup"><span data-stu-id="42f88-156">Complex type</span></span>|<span data-ttu-id="42f88-157">Igual que otros tipos complejos, pero algunos tipos <xref:System.Runtime.Serialization.ISerializable> no se admiten; vea la nota sobre la compatibilidad de ISerializable en la sección de Información avanzada de este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="42f88-158">Valor `Null` para cualquier tipo</span><span class="sxs-lookup"><span data-stu-id="42f88-158">`Null` value for any type</span></span>|<span data-ttu-id="42f88-159">Null</span><span class="sxs-lookup"><span data-stu-id="42f88-159">Null</span></span>|<span data-ttu-id="42f88-160">Los tipos de valor que aceptan valores null también se admiten y se asignan a JSON de la misma manera que los tipos de valor que no aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="42f88-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="42f88-161">Enumeraciones y JSON</span><span class="sxs-lookup"><span data-stu-id="42f88-161">Enumerations and JSON</span></span>

<span data-ttu-id="42f88-162">Los valores del miembro de enumeración se tratan como números en JSON, que es diferente de cómo se tratan en contratos de datos, donde se incluyen como nombres de miembros.</span><span class="sxs-lookup"><span data-stu-id="42f88-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="42f88-163">Para obtener más información sobre el tratamiento del contrato de datos, vea [tipos de enumeración en contratos de datos](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="42f88-164">Por ejemplo, si tiene `public enum Color {red, green, blue, yellow, pink}`, al serializar `yellow`, se genera el número 3 y no la cadena "amarillo".</span><span class="sxs-lookup"><span data-stu-id="42f88-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="42f88-165">Todos los miembros `enum` son serializables.</span><span class="sxs-lookup"><span data-stu-id="42f88-165">All `enum` members are serializable.</span></span> <span data-ttu-id="42f88-166">Se omiten los atributos <xref:System.Runtime.Serialization.EnumMemberAttribute> y <xref:System.NonSerializedAttribute> si se utilizan.</span><span class="sxs-lookup"><span data-stu-id="42f88-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="42f88-167">Es posible deserializar un valor `enum` no existente, por ejemplo, el valor 87 se puede deserializar en la enumeración de color anterior aunque no esté definido un nombre de color correspondiente.</span><span class="sxs-lookup"><span data-stu-id="42f88-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="42f88-168">Una `enum` de marcas no es especial y se trata igual que otra `enum`.</span><span class="sxs-lookup"><span data-stu-id="42f88-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="42f88-169">Fechas/horas y JSON</span><span class="sxs-lookup"><span data-stu-id="42f88-169">Dates/Times and JSON</span></span>

<span data-ttu-id="42f88-170">El formato JSON no admite directamente fechas y horas.</span><span class="sxs-lookup"><span data-stu-id="42f88-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="42f88-171">No obstante, se usan correctamente y AJAX de ASP.NET proporciona compatibilidad especial para estos tipos.</span><span class="sxs-lookup"><span data-stu-id="42f88-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="42f88-172">Al usar proxies AJAX de ASP.NET, el tipo <xref:System.DateTime> de .NET se corresponde completamente con el tipo `DateTime` de JavaScript.</span><span class="sxs-lookup"><span data-stu-id="42f88-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="42f88-173">Cuando no se utiliza ASP.NET, se representa un tipo <xref:System.DateTime> en JSON como una cadena con un formato especial que se describe en la sección de Información avanzada en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="42f88-174"><xref:System.DateTimeOffset> se representa en JSON como un tipo complejo: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="42f88-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="42f88-175">El miembro `offsetMinutes` es el desplazamiento de la hora local respecto a la hora del meridiano de Greenwich (GMT), también conocida como hora universal coordinada (UTC), que está asociado a la ubicación del evento de interés.</span><span class="sxs-lookup"><span data-stu-id="42f88-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="42f88-176">El miembro `dateTime` representa la instancia temporal en la que se produce el evento de interés (de nuevo, se convierte en un `DateTime` en JavaScript cuando se usa AJAX de ASP.NET y en una cadena cuando no se usa).</span><span class="sxs-lookup"><span data-stu-id="42f88-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="42f88-177">En la serialización, el miembro `dateTime` siempre se serializa en GMT.</span><span class="sxs-lookup"><span data-stu-id="42f88-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="42f88-178">Por lo tanto, si se describen las 3:00 a.m. hora de Nueva York, `dateTime` tiene un componente horario de 8:00 a.m. y `offsetMinutes` son 300 (menos 300 minutos o 5 horas con respecto a GMT).</span><span class="sxs-lookup"><span data-stu-id="42f88-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="42f88-179">Los objetos <xref:System.DateTime> y <xref:System.DateTimeOffset>, cuando se serializan en JSON, solo conservan información de precisión de milisegundos.</span><span class="sxs-lookup"><span data-stu-id="42f88-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="42f88-180">Los valores de submilisegundos (micro y nanosegundos) se pierden durante la serialización.</span><span class="sxs-lookup"><span data-stu-id="42f88-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="42f88-181">Tipos XML y JSON</span><span class="sxs-lookup"><span data-stu-id="42f88-181">XML Types and JSON</span></span>

<span data-ttu-id="42f88-182">Los tipos XML se convierten en cadenas JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="42f88-183">Por ejemplo, si un miembro de datos "q" de tipo XElement contiene \<abc/> , el JSON es {"q": " \<abc/> "}.</span><span class="sxs-lookup"><span data-stu-id="42f88-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="42f88-184">Hay algunas reglas especiales que especifican el ajuste de XML; para obtener más información, consulte la sección Información avanzada más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="42f88-185">Si está utilizando AJAX de ASP.NET y no desea usar cadenas en JavaScript, pero quiere XML DOM en su lugar, establezca la propiedad <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> en XML en <xref:System.ServiceModel.Web.WebGetAttribute> o la propiedad <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> en XML en <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="42f88-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="42f88-186">Colecciones, diccionarios y matrices</span><span class="sxs-lookup"><span data-stu-id="42f88-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="42f88-187">Todas las colecciones, diccionarios y matrices se representan en JSON como matrices.</span><span class="sxs-lookup"><span data-stu-id="42f88-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="42f88-188">Cualquier personalización que utilice <xref:System.Runtime.Serialization.CollectionDataContractAttribute> se omite en la representación de JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="42f88-189">Los diccionarios no son una forma para trabajar directamente con JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="42f88-190">\<string,object>Es posible que el diccionario no se admita de la misma manera en WCF, como se esperaba, al trabajar con otras tecnologías JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="42f88-191">Por ejemplo, si "abc" está asignado a "xyz" y "def" está asignado a 42 en un diccionario, la representación de JSON no es {"abc":"xyz","def":42} si no que en su lugar es [{"Clave":"abc","Valor":"xyz"},{"Clave":"def","Valor":42}].</span><span class="sxs-lookup"><span data-stu-id="42f88-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="42f88-192">Si desea trabajar con JSON directamente (obteniendo acceso dinámicamente a claves y valores, sin predefinir una restricción rígida), tiene varias opciones:</span><span class="sxs-lookup"><span data-stu-id="42f88-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="42f88-193">Considere la posibilidad de usar el ejemplo de [serialización JSON (AJAX) de tipo débil](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) .</span><span class="sxs-lookup"><span data-stu-id="42f88-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="42f88-194">Considere usar la interfaz <xref:System.Runtime.Serialization.ISerializable> y los constructores de deserialización; estos dos mecanismos le permiten obtener acceso a parejas de valores y claves de JSON en serialización y deserialización respectivamente, pero no funcionan en escenarios de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="42f88-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="42f88-195">Considere la posibilidad de trabajar con la [asignación entre JSON y XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) en lugar de usar un serializador.</span><span class="sxs-lookup"><span data-stu-id="42f88-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="42f88-196">El *polimorfismo* en el contexto de serialización hace referencia a la capacidad de serializar un tipo derivado donde se espera su tipo base.</span><span class="sxs-lookup"><span data-stu-id="42f88-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="42f88-197">Hay reglas específicas de JSON especiales al utilizar las colecciones de manera polimórfica, por ejemplo, al asignar una colección a un <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="42f88-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="42f88-198">Este problema se trata con todo detalle en la sección de Información avanzada más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="42f88-199">Detalles adicionales</span><span class="sxs-lookup"><span data-stu-id="42f88-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="42f88-200">Orden de los miembros de datos</span><span class="sxs-lookup"><span data-stu-id="42f88-200">Order of Data Members</span></span>

<span data-ttu-id="42f88-201">El orden de miembros de datos no es importante al utilizar JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="42f88-202">Específicamente, incluso cuando se establece <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>, los datos de JSON aún se pueden deserializar en cualquier orden.</span><span class="sxs-lookup"><span data-stu-id="42f88-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="42f88-203">Tipos JSON</span><span class="sxs-lookup"><span data-stu-id="42f88-203">JSON Types</span></span>

<span data-ttu-id="42f88-204">El tipo JSON no tiene que coincidir con la tabla precedente en la deserialización.</span><span class="sxs-lookup"><span data-stu-id="42f88-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="42f88-205">Por ejemplo, un `Int` normalmente asigna a un número JSON, pero también se puede deserializar correctamente de una cadena JSON siempre que esa cadena contenga un número válido.</span><span class="sxs-lookup"><span data-stu-id="42f88-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="42f88-206">Es decir, ambos {"q": 42} y {"q": "42"} son válidos si hay un miembro de datos `Int` denominado "q".</span><span class="sxs-lookup"><span data-stu-id="42f88-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="42f88-207">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="42f88-207">Polymorphism</span></span>

<span data-ttu-id="42f88-208">La serialización polimórfica es la capacidad de serializar un tipo derivado donde se espera su tipo base.</span><span class="sxs-lookup"><span data-stu-id="42f88-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="42f88-209">Esto se admite para la serialización de JSON con WCF comparable a la manera en que se admite la serialización XML.</span><span class="sxs-lookup"><span data-stu-id="42f88-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="42f88-210">Por ejemplo, puede serializar `MyDerivedType` donde `MyBaseType` se espera o serializar `Int` donde `Object` se espera.</span><span class="sxs-lookup"><span data-stu-id="42f88-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="42f88-211">La información de tipo puede perderse al deserializar un tipo derivado si se espera el tipo base, a menos que esté deserializando un tipo complejo.</span><span class="sxs-lookup"><span data-stu-id="42f88-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="42f88-212">Por ejemplo, si se serializa <xref:System.Uri> donde se espera un <xref:System.Object>, resulta en una cadena de JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="42f88-213">Si esta cadena se vuelve a deserializar en <xref:System.Object>, se devuelve un <xref:System.String> .NET.</span><span class="sxs-lookup"><span data-stu-id="42f88-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="42f88-214">El deserializador no conoce el tipo <xref:System.Uri> inicial de la cadena.</span><span class="sxs-lookup"><span data-stu-id="42f88-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="42f88-215">Generalmente, cuando se espera <xref:System.Object>, todas las cadenas JSON se deserializan como cadenas .NET y todas las matrices JSON usadas para serializar colecciones, diccionarios y matrices .NET se deserializan como <xref:System.Array> .NET de tipo <xref:System.Object>, independientemente de cual haya sido el tipo original real.</span><span class="sxs-lookup"><span data-stu-id="42f88-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="42f88-216">Un booleano JSON se asigna a un <xref:System.Boolean> .NET.</span><span class="sxs-lookup"><span data-stu-id="42f88-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="42f88-217">No obstante, al esperar un <xref:System.Object>, los números de JSON se deserializan como <xref:System.Int32>, <xref:System.Decimal> o <xref:System.Double> .NET, donde se escoge automáticamente el tipo más adecuado.</span><span class="sxs-lookup"><span data-stu-id="42f88-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="42f88-218">Al deserializar en un tipo de interfaz, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializa como si el tipo declarado fuese un objeto.</span><span class="sxs-lookup"><span data-stu-id="42f88-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="42f88-219">Al trabajar con sus tipos base y derivados propios, normalmente se requiere utilizar <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> o un mecanismo equivalente.</span><span class="sxs-lookup"><span data-stu-id="42f88-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="42f88-220">Por ejemplo, si tiene una operación que tiene un `Animal` valor devuelto y realmente devuelve una instancia de `Cat` (derivada de `Animal` ), debe aplicar <xref:System.Runtime.Serialization.KnownTypeAttribute> , al `Animal` tipo o <xref:System.ServiceModel.ServiceKnownTypeAttribute> a la operación y especificar el `Cat` tipo en estos atributos.</span><span class="sxs-lookup"><span data-stu-id="42f88-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="42f88-221">Para obtener más información, vea [tipos conocidos de contratos de datos](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="42f88-222">Para obtener detalles sobre cómo funciona la serialización polimórfica y una explicación sobre algunas limitaciones que se deben respetar al usarla, consulte el sección Información avanzada más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="42f88-223">Control de versiones</span><span class="sxs-lookup"><span data-stu-id="42f88-223">Versioning</span></span>

<span data-ttu-id="42f88-224">Las características de versiones de contratos de datos, incluida la interfaz de <xref:System.Runtime.Serialization.IExtensibleDataObject>, con completamente compatible en JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="42f88-225">Además, en la mayoría de los casos es posible deserializar un tipo en un formato (por ejemplo, XML) y, a continuación, serializarlo en otro formato (por ejemplo, JSON) y conservar los datos en <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="42f88-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="42f88-226">Para obtener más información, vea [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) (Contratos de datos compatibles con el reenvío).</span><span class="sxs-lookup"><span data-stu-id="42f88-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="42f88-227">Recuerde que JSON no está ordenado por lo que se pierde la información de orden.</span><span class="sxs-lookup"><span data-stu-id="42f88-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="42f88-228">Además, JSON no admite múltiples parejas de claves y valores con el mismo nombre de clave.</span><span class="sxs-lookup"><span data-stu-id="42f88-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="42f88-229">Finalmente, todas las operaciones en <xref:System.Runtime.Serialization.IExtensibleDataObject> son inherentemente polimórficas, es decir, que su tipo derivado se asigna a <xref:System.Object>, el tipo base para todos los tipos.</span><span class="sxs-lookup"><span data-stu-id="42f88-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="42f88-230">JSON en direcciones URL</span><span class="sxs-lookup"><span data-stu-id="42f88-230">JSON in URLs</span></span>

<span data-ttu-id="42f88-231">Al utilizar puntos de conexión AJAX de ASP.NET con el verbo HTTP GET (usando el atributo <xref:System.ServiceModel.Web.WebGetAttribute>), los parámetros de entrada aparecen en la dirección URL de solicitud en lugar del cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="42f88-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="42f88-232">JSON se admite incluso en la dirección URL de la solicitud, por lo que si tiene una operación que toma un `Int` llamado "número" y un `Person` tipo complejo denominado "p", la dirección URL puede ser similar a la siguiente dirección URL.</span><span class="sxs-lookup"><span data-stu-id="42f88-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="42f88-233">Si está utilizando un control Script Manager de AJAX de ASP.NET y proxy para llamar al servicio, el proxy genera automáticamente esta dirección URL y no se ve.</span><span class="sxs-lookup"><span data-stu-id="42f88-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="42f88-234">JSON no se puede utilizar en direcciones URL ni en puntos de conexión AJAX de no ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="42f88-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="42f88-235">Información avanzada</span><span class="sxs-lookup"><span data-stu-id="42f88-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="42f88-236">Compatible con ISerializable</span><span class="sxs-lookup"><span data-stu-id="42f88-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="42f88-237">Tipos compatibles y no compatibles con ISerializable</span><span class="sxs-lookup"><span data-stu-id="42f88-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="42f88-238">En general, los tipos que implementan la interfaz <xref:System.Runtime.Serialization.ISerializable> son completamente compatibles al serializar o deserializar JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="42f88-239">No obstante, algunos de estos tipos (incluidos algunos tipos .NET Framework) se implementan de tal forma que los aspectos de serialización específicos de JSON hacen que no se deserialicen correctamente:</span><span class="sxs-lookup"><span data-stu-id="42f88-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="42f88-240">Con <xref:System.Runtime.Serialization.ISerializable>, el tipo de los miembros de datos individuales nunca se conocen por anticipado.</span><span class="sxs-lookup"><span data-stu-id="42f88-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="42f88-241">Esto lleva a una situación polimórfica similar a deserializar tipos en un objeto.</span><span class="sxs-lookup"><span data-stu-id="42f88-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="42f88-242">Como se mencionó anteriormente, esto puede llevar a perder la información de tipo en JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="42f88-243">Por ejemplo, un tipo que serializa un `enum` en su implementación de <xref:System.Runtime.Serialization.ISerializable> e intenta volver a deserializar correctamente en un `enum` (sin las conversiones adecuadas) tiene errores, porque una `enum` se serializa usando números en JSON y los números JSON se deserializan en tipos numéricos .NET integrados (Int32, decimal o doble).</span><span class="sxs-lookup"><span data-stu-id="42f88-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="42f88-244">Por tanto, el hecho de que el número usado sea un valor `enum` se pierde.</span><span class="sxs-lookup"><span data-stu-id="42f88-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="42f88-245">Un tipo <xref:System.Runtime.Serialization.ISerializable> que depende de un orden particular de deserialización en su constructor de deserialización también puede tener errores al deserializar algunos datos JSON, porque la mayoría de serializadores JSON no garantizan ningún orden específico.</span><span class="sxs-lookup"><span data-stu-id="42f88-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="42f88-246">Tipos de fábrica</span><span class="sxs-lookup"><span data-stu-id="42f88-246">Factory Types</span></span>

<span data-ttu-id="42f88-247">Mientras que, en general, la interfaz <xref:System.Runtime.Serialization.IObjectReference> se admite en JSON, no se admiten los atributos que requieren la característica "tipo de fábrica" (que devuelven una instancia de un tipo diferente de <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> del tipo que implementa la interfaz).</span><span class="sxs-lookup"><span data-stu-id="42f88-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="42f88-248">Formato de conexión DateTime</span><span class="sxs-lookup"><span data-stu-id="42f88-248">DateTime Wire Format</span></span>

<span data-ttu-id="42f88-249">Los valores <xref:System.DateTime> aparecen como cadenas JSON con el formato "/Date(700000+0500)/", donde el primer número (en el ejemplo proporcionado, 700000) es el número de milisegundos en la zona horaria GMT, hora normal (sin horario de verano) desde la medianoche del 1 de enero de 1970.</span><span class="sxs-lookup"><span data-stu-id="42f88-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="42f88-250">El número puede ser negativo para representar horas anteriores.</span><span class="sxs-lookup"><span data-stu-id="42f88-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="42f88-251">La parte del ejemplo que contiene "+0500" es opcional e indica que la hora es de tipo <xref:System.DateTimeKind.Local>, es decir, debe convertirse a la zona horaria local en la deserialización.</span><span class="sxs-lookup"><span data-stu-id="42f88-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="42f88-252">Si no está presente, la hora se deserializa como <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="42f88-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="42f88-253">El número real (en el ejemplo, "0500") y su signo (+ o -) se omiten.</span><span class="sxs-lookup"><span data-stu-id="42f88-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="42f88-254">Al serializar las horas <xref:System.DateTime>, <xref:System.DateTimeKind.Local> y <xref:System.DateTimeKind.Unspecified> se escriben con un desplazamiento y <xref:System.DateTimeKind.Utc> se escribe sin él.</span><span class="sxs-lookup"><span data-stu-id="42f88-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="42f88-255">El código JavaScript del cliente de AJAX de ASP.NET convierte automáticamente estas cadenas en instancias `DateTime` de JavaScript.</span><span class="sxs-lookup"><span data-stu-id="42f88-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="42f88-256">Si existen otras cadenas con un formato similar que son sean de tipo <xref:System.DateTime> en .NET, también se convierten.</span><span class="sxs-lookup"><span data-stu-id="42f88-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="42f88-257">La conversión solo tiene lugar si los caracteres "/" son caracteres de escape (es decir, el JSON es similar a " \\ /Date (700000 + 0500) \\ /") y, por este motivo, el codificador JSON de WCF (habilitado por <xref:System.ServiceModel.WebHttpBinding> ) siempre escapa del carácter "/".</span><span class="sxs-lookup"><span data-stu-id="42f88-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="42f88-258">Cadenas XML en JSON</span><span class="sxs-lookup"><span data-stu-id="42f88-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="42f88-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="42f88-259">XmlElement</span></span>

<span data-ttu-id="42f88-260"><xref:System.Xml.XmlElement> se serializa como tal, sin ajustes.</span><span class="sxs-lookup"><span data-stu-id="42f88-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="42f88-261">Por ejemplo, el miembro de datos "x" de tipo <xref:System.Xml.XmlElement> que contiene \<abc/> se representa de la manera siguiente:</span><span class="sxs-lookup"><span data-stu-id="42f88-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="42f88-262">Matrices de XmlNode</span><span class="sxs-lookup"><span data-stu-id="42f88-262">Arrays of XmlNode</span></span>

<span data-ttu-id="42f88-263">Los objetos de <xref:System.Array> de tipo <xref:System.Xml.XmlNode> se ajustan en un elemento denominado ArrayOfXmlNode en el espacio de nombres del contrato de datos estándar del tipo.</span><span class="sxs-lookup"><span data-stu-id="42f88-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="42f88-264">Si "x" es una matriz que contiene el nodo de atributo "N" en el espacio de nombres "ns" que contiene "valor" y un nodo del elemento "M" vacío, la representación es la siguiente.</span><span class="sxs-lookup"><span data-stu-id="42f88-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="42f88-265">No se admiten atributos en el espacio de nombres vacío al principio de matrices XmlNode (antes de otros elementos).</span><span class="sxs-lookup"><span data-stu-id="42f88-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="42f88-266">Tipos IXmlSerializable incluidos XElement y DataSet</span><span class="sxs-lookup"><span data-stu-id="42f88-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="42f88-267">Los tipos <xref:System.Runtime.Serialization.ISerializable> se subdividen en "tipos Content", "tipos DataSet" y "tipos Element".</span><span class="sxs-lookup"><span data-stu-id="42f88-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="42f88-268">Para obtener definiciones de estos tipos, consulte [tipos XML y ADO.net en los contratos de datos](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="42f88-269">Los tipos "Content" y "DataSet" se serializan de forma similar a los objetos <xref:System.Array> de <xref:System.Xml.XmlNode> explicados en la sección anterior.</span><span class="sxs-lookup"><span data-stu-id="42f88-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="42f88-270">Se ajustan en un elemento cuyo nombre y espacio de nombres se corresponde al nombre y espacio de nombres del contrato de datos del tipo en cuestión.</span><span class="sxs-lookup"><span data-stu-id="42f88-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="42f88-271">Los tipos "Element" como <xref:System.Xml.Linq.XElement> are se serializan como tales, similar a <xref:System.Xml.XmlElement> explicado anteriormente en este tema.</span><span class="sxs-lookup"><span data-stu-id="42f88-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="42f88-272">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="42f88-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="42f88-273">Conservación de la información de tipo</span><span class="sxs-lookup"><span data-stu-id="42f88-273">Preserving Type Information</span></span>

<span data-ttu-id="42f88-274">Como se indicó anteriormente, se admite el polimorfismo en JSON con algunas limitaciones.</span><span class="sxs-lookup"><span data-stu-id="42f88-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="42f88-275">JavaScript es un lenguaje débilmente tipado y la identidad de tipos normalmente no es un problema.</span><span class="sxs-lookup"><span data-stu-id="42f88-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="42f88-276">Sin embargo, al usar JSON para comunicarse entre un sistema fuertemente tipado (.NET) y un sistema de tipo débil (JavaScript), es útil conservar la identidad de tipo.</span><span class="sxs-lookup"><span data-stu-id="42f88-276">However, when using JSON to communicate between a strongly typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="42f88-277">Por ejemplo, los tipos con nombres de contrato de datos "Cuadrado" y "Círculo" derivan de un tipo con un nombre de contrato de datos "Forma".</span><span class="sxs-lookup"><span data-stu-id="42f88-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="42f88-278">Si "Círculo" se envía de .NET a JavaScript y después se devuelve a un método .NET que espera "Forma", es útil en el lado de .NET saber que el objeto en cuestión originalmente era un "Círculo", en otro caso, cualquier información específica al tipo derivado (por ejemplo, el miembro de datos "radio" en "Círculo") se puede perder.</span><span class="sxs-lookup"><span data-stu-id="42f88-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="42f88-279">Para conservar la identidad de tipos, al serializar tipos complejos a JSON se puede agregar una "sugerencia de tipo" y deserializador reconoce la sugerencia y actúa correctamente.</span><span class="sxs-lookup"><span data-stu-id="42f88-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="42f88-280">La "sugerencia de tipo" es un par clave-valor de JSON con el nombre de clave " \_ \_ tipo" (dos subrayados seguidos de la palabra "tipo").</span><span class="sxs-lookup"><span data-stu-id="42f88-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="42f88-281">El valor es una cadena JSON de formato "DataContractName:DataContractNamespace" (lo que va antes de los dos puntos es el nombre).</span><span class="sxs-lookup"><span data-stu-id="42f88-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="42f88-282">Con el ejemplo anterior, "Círculo" se puede serializar de la forma siguiente.</span><span class="sxs-lookup"><span data-stu-id="42f88-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="42f88-283">La sugerencia de tipo es muy similar al atributo `xsi:type` definido por la instancia de esquema XML estándar y se usa al serializar y deserializar XML.</span><span class="sxs-lookup"><span data-stu-id="42f88-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="42f88-284">Los miembros de datos denominados " \_ \_ type" están prohibidos debido a un posible conflicto con la sugerencia de tipo.</span><span class="sxs-lookup"><span data-stu-id="42f88-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="42f88-285">Reducción del tamaño de sugerencias de tipo</span><span class="sxs-lookup"><span data-stu-id="42f88-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="42f88-286">Para reducir el tamaño de los mensajes JSON, el prefijo de espacio de nombres del contrato de datos predeterminado ( `http://schemas.datacontract.org/2004/07/` ) se reemplaza por el carácter "#".</span><span class="sxs-lookup"><span data-stu-id="42f88-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="42f88-287">(Para que este reemplazo sea reversible, se usa una regla de escape: Si el espacio de nombres comienza con los caracteres "#" o " \\ ", se anexan con un \\ carácter "" adicional).</span><span class="sxs-lookup"><span data-stu-id="42f88-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="42f88-288">Por lo tanto, si "Circle" es un tipo del espacio de nombres de .NET "MyApp. Shapes", su espacio de nombres de contrato de datos predeterminado es `http://schemas.datacontract.org/2004/07/MyApp` .</span><span class="sxs-lookup"><span data-stu-id="42f88-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="42f88-289">Las formas y la representación  JSON son las siguientes.</span><span class="sxs-lookup"><span data-stu-id="42f88-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="42f88-290">Tanto el nombre truncado (#MyApp. Shapes) como los <http://schemas.datacontract.org/2004/07/MyApp.Shapes> nombres completos () se entienden en la deserialización.</span><span class="sxs-lookup"><span data-stu-id="42f88-290">Both the truncated (#MyApp.Shapes) and the full (<http://schemas.datacontract.org/2004/07/MyApp.Shapes>) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="42f88-291">Posición de la sugerencia de tipo en objetos JSON</span><span class="sxs-lookup"><span data-stu-id="42f88-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="42f88-292">Observe que la sugerencia de tipo debe aparecer primero en la representación JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="42f88-293">Éste es el único caso donde el orden de las parejas de clave y valor es importante en el procesamiento JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="42f88-294">Por ejemplo, lo siguiente no es una forma válida de especificar una sugerencia de tipo.</span><span class="sxs-lookup"><span data-stu-id="42f88-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="42f88-295">Tanto las <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> páginas de cliente de WCF como las usadas por las páginas de cliente de ASP.NET AJAX siempre emiten primero la sugerencia de tipo.</span><span class="sxs-lookup"><span data-stu-id="42f88-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="42f88-296">Las sugerencias de tipo solo se aplican a tipos complejos.</span><span class="sxs-lookup"><span data-stu-id="42f88-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="42f88-297">No hay ninguna manera de emitir una sugerencia de tipo para tipos no complejos.</span><span class="sxs-lookup"><span data-stu-id="42f88-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="42f88-298">Por ejemplo, si una operación tiene un valor de devolución de <xref:System.Object> pero devuelve un Círculo, la representación JSON se puede mostrar antes y la información de tipo se conserva.</span><span class="sxs-lookup"><span data-stu-id="42f88-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="42f88-299">No obstante, si se devuelve el identificador URI, la representación JSON es una cadena y se pierde el hecho de la cadena usada para representar un URI.</span><span class="sxs-lookup"><span data-stu-id="42f88-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="42f88-300">Esto se aplica no solo a tipos primitivos, si no también a colecciones y matrices.</span><span class="sxs-lookup"><span data-stu-id="42f88-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="42f88-301">Cuando se emiten sugerencias de tipo</span><span class="sxs-lookup"><span data-stu-id="42f88-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="42f88-302">Las sugerencias de tipo pueden aumentar de forma significativa el tamaño del mensaje (una forma de mitigarlo es usar espacios de nombres de contratos de datos más cortos si es posible).</span><span class="sxs-lookup"><span data-stu-id="42f88-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="42f88-303">Por consiguiente, rigen las siguientes reglas si se emiten sugerencias de tipo:</span><span class="sxs-lookup"><span data-stu-id="42f88-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="42f88-304">Al usar ASP.NET AJAX, las sugerencias de tipo siempre se emiten cuando es posible, incluso si no existe una asignación base/derivada, por ejemplo, incluso si un Círculo se asigna a Círculo.</span><span class="sxs-lookup"><span data-stu-id="42f88-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="42f88-305">(Esto es necesario para habilitar completamente el proceso de llamada desde el entorno JSON fuertemente tipado en el entorno de .NET fuertemente tipado sin pérdida de información.)</span><span class="sxs-lookup"><span data-stu-id="42f88-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="42f88-306">Al usar servicios de AJAX sin integración de ASP.NET, las sugerencias de tipo solo se emiten cuando existe una asignación base/derivada, es decir, se emiten cuando un Círculo se asigna a Forma o <xref:System.Object>, pero no cuando se asigna a Círculo.</span><span class="sxs-lookup"><span data-stu-id="42f88-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="42f88-307">Esto proporciona la información mínima necesaria para implementar correctamente un cliente JavaScript, por tanto para mejorar el rendimiento, pero no protege contra la pérdida de información en clientes designado de forma incorrecta.</span><span class="sxs-lookup"><span data-stu-id="42f88-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="42f88-308">Evite asignaciones base/derivadas juntas en el servidor si desea evitar este problema en el cliente.</span><span class="sxs-lookup"><span data-stu-id="42f88-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="42f88-309">Al utilizar el tipo <xref:System.Runtime.Serialization.DataContractSerializer>, el parámetro de constructor `alwaysEmitTypeInformation` le permite elegir entre los dos modos anteriores, con el valor predeterminado de "`false`" (solo se emiten sugerencias de tipo cuando son necesarias).</span><span class="sxs-lookup"><span data-stu-id="42f88-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="42f88-310">Nombres de miembros de datos duplicados</span><span class="sxs-lookup"><span data-stu-id="42f88-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="42f88-311">La información de tipo derivado se presenta en el mismo objeto JSON que la información de tipo base y puede producirse en cualquier orden.</span><span class="sxs-lookup"><span data-stu-id="42f88-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="42f88-312">Por ejemplo, `Shape` se puede representar como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="42f88-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="42f88-313">Mientras que Círculo puede representarse de la manera siguiente.</span><span class="sxs-lookup"><span data-stu-id="42f88-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="42f88-314">Si el `Shape` tipo base también contenía un miembro de datos denominado " `radius` ", esto conduce a una colisión en la serialización (porque los objetos JSON no pueden tener nombres de clave repetidos) y la deserialización (porque no está claro si "RADIUS" hace referencia a `Shape.radius` o `Circle.radius` ).</span><span class="sxs-lookup"><span data-stu-id="42f88-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="42f88-315">Por tanto, mientras que generalmente no se recomienda el concepto de "ocultamiento de propiedad" (miembros de datos con el mismo nombre en clases base y derivadas) en clases de contratos de datos, realmente está prohibido en el caso de JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="42f88-316">Polimorfismo y tipos IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="42f88-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="42f88-317">Los tipos <xref:System.Xml.Serialization.IXmlSerializable> pueden asignarse de forma polimórfica a otro como se hace habitualmente siempre que se cumplan los requisitos de Tipos conocidos, según las reglas de contrato de datos normal.</span><span class="sxs-lookup"><span data-stu-id="42f88-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="42f88-318">No obstante, serializar un tipo <xref:System.Xml.Serialization.IXmlSerializable> en vez de <xref:System.Object> produce una pérdida de información de tipo como resultado en una cadena JSON.</span><span class="sxs-lookup"><span data-stu-id="42f88-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="42f88-319">Polimorfismo y determinados tipos de interfaz</span><span class="sxs-lookup"><span data-stu-id="42f88-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="42f88-320">Se prohíbe serializar un tipo de colección o un tipo que implemente <xref:System.Xml.Serialization.IXmlSerializable> donde no se espera un tipo de no colección <xref:System.Xml.Serialization.IXmlSerializable> (excepto para <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="42f88-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="42f88-321">Por ejemplo, una interfaz personalizada denominada `IMyInterface` y un tipo `MyType` que implementan ambos <xref:System.Collections.Generic.IEnumerable%601> tipos `int` y `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="42f88-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="42f88-322">Está prohibido devolver `MyType` desde una operación cuyo tipo de valor devuelto sea `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="42f88-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="42f88-323">Esto se debe a que se `MyType` debe serializar como una matriz JSON y requiere una sugerencia de tipo y, como se indicó antes, no se puede incluir una sugerencia de tipo con matrices, solo con tipos complejos.</span><span class="sxs-lookup"><span data-stu-id="42f88-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="42f88-324">Tipos conocidos y configuración</span><span class="sxs-lookup"><span data-stu-id="42f88-324">Known Types and Configuration</span></span>

<span data-ttu-id="42f88-325">Todos los mecanismos de tipos conocidos usados por <xref:System.Runtime.Serialization.DataContractSerializer> también se admiten de la misma manera en <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="42f88-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="42f88-326">Ambos serializadores leen el mismo elemento de configuración, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) en [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md) , para detectar los tipos conocidos agregados a través de un archivo de configuración.</span><span class="sxs-lookup"><span data-stu-id="42f88-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="42f88-327">Colecciones asignadas a objetos</span><span class="sxs-lookup"><span data-stu-id="42f88-327">Collections Assigned to Object</span></span>

<span data-ttu-id="42f88-328">Las colecciones asignadas a objetos se serializan como si fueran colecciones que implementan  <xref:System.Collections.Generic.IEnumerable%601>: una matriz JSON donde cada entrada tiene una sugerencia de tipo si es un tipo complejo.</span><span class="sxs-lookup"><span data-stu-id="42f88-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="42f88-329">Por ejemplo, un <xref:System.Collections.Generic.List%601> de tipo `Shape` asignado a <xref:System.Object> tiene un aspecto similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="42f88-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="42f88-330">Al volver a deserializar en <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="42f88-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="42f88-331">`Shape`debe estar en la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="42f88-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="42f88-332">Tener <xref:System.Collections.Generic.List%601> un tipo `Shape` en tipos conocidos no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="42f88-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="42f88-333">Tenga en cuenta que, en este caso, no tiene que agregar `Shape` a tipos conocidos en la serialización; esto se hace automáticamente.</span><span class="sxs-lookup"><span data-stu-id="42f88-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="42f88-334">La colección se deserializa como un <xref:System.Array> de tipo <xref:System.Object> que contiene `Shape` instancias de.</span><span class="sxs-lookup"><span data-stu-id="42f88-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="42f88-335">Colecciones derivadas asignadas a colecciones base</span><span class="sxs-lookup"><span data-stu-id="42f88-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="42f88-336">Cuando una colección derivada se asigna a una colección base, la colección normalmente se serializa como si fuera una colección del tipo base.</span><span class="sxs-lookup"><span data-stu-id="42f88-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="42f88-337">No obstante, si el tipo de elemento de la colección derivada no se puede asignar al tipo de elemento de la colección base, se inicia una excepción.</span><span class="sxs-lookup"><span data-stu-id="42f88-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="42f88-338">Sugerencias de tipo y diccionarios</span><span class="sxs-lookup"><span data-stu-id="42f88-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="42f88-339">Cuando se asigna un diccionario a un <xref:System.Object>, cada entrada Clave y Valor del diccionario se trata como si se asignara a <xref:System.Object> y se obtiene una sugerencia de tipo.</span><span class="sxs-lookup"><span data-stu-id="42f88-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="42f88-340">Al serializar tipos de diccionario, el objeto JSON que contiene los miembros "Clave" y "Valor" no se ven afectados por el parámetro `alwaysEmitTypeInformation` y solo contiene una sugerencia de tipo cuando las reglas de la colección precedente lo requieren.</span><span class="sxs-lookup"><span data-stu-id="42f88-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="42f88-341">Nombres de claves JSON válidos</span><span class="sxs-lookup"><span data-stu-id="42f88-341">Valid JSON Key Names</span></span>

<span data-ttu-id="42f88-342">El serializador XML codifica nombres de claves que no son nombres XML válidos.</span><span class="sxs-lookup"><span data-stu-id="42f88-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="42f88-343">Por ejemplo, un miembro de datos con el nombre "123" tendría un nombre codificado como " \_ x0031 \_ \_ x0032 \_ \_ x0033 \_ " porque "123" es un nombre de elemento XML no válido (empieza con un dígito).</span><span class="sxs-lookup"><span data-stu-id="42f88-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="42f88-344">Se puede producir una situación similar con algunos juegos de caracteres internacionales no válidos en nombres de XML.</span><span class="sxs-lookup"><span data-stu-id="42f88-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="42f88-345">Para obtener una explicación de este efecto de XML en el procesamiento de JSON, consulte [asignación entre JSON y XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="42f88-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="42f88-346">Consulta también</span><span class="sxs-lookup"><span data-stu-id="42f88-346">See also</span></span>

- [<span data-ttu-id="42f88-347">Compatibilidad con JSON y otros formatos de transferencia de datos</span><span class="sxs-lookup"><span data-stu-id="42f88-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
