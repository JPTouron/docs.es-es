---
title: Implementación de un método Dispose
description: En este artículo, aprenderá a implementar el método Dispose, que libera los recursos no administrados que usa su código en .NET.
ms.date: 05/27/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: c8b4b9a79577776bc049ef77e222d63374178708
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/05/2020
ms.locfileid: "84447178"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="4c0cf-103">Implementación de un método Dispose</span><span class="sxs-lookup"><span data-stu-id="4c0cf-103">Implement a Dispose method</span></span>

<span data-ttu-id="4c0cf-104">La implementación del método <xref:System.IDisposable.Dispose%2A> sirve principalmente para publicar recursos no administrados que utiliza su código.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources used by your code.</span></span> <span data-ttu-id="4c0cf-105">Al trabajar con miembros de instancia que son implementaciones de <xref:System.IDisposable>, es habitual hacer llamadas de <xref:System.IDisposable.Dispose%2A> en cascada.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="4c0cf-106">Hay otras razones para implementar <xref:System.IDisposable.Dispose%2A>, como deshacer algo que se ha hecho anteriormente.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, such as undoing something that was previously done.</span></span> <span data-ttu-id="4c0cf-107">Por ejemplo, liberar la memoria que se asignó, quitar un elemento de una colección que se agregó, señalar el lanzamiento de un bloqueo adquirido, etc.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-107">For example, freeing memory that was allocated, removing an item from a collection that was added, signaling the release of a lock that was acquired, and so on.</span></span>

<span data-ttu-id="4c0cf-108">El [recolector de elementos no utilizados de .NET](index.md) no asigna ni libera memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-108">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="4c0cf-109">El modelo para desechar un objeto, lo que se conoce como patrón de Dispose, sirve para imponer orden sobre la duración de un objeto.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-109">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="4c0cf-110">El patrón de Dispose se utiliza solo con los objetos que implementan la inferfaz <xref:System.IDisposable>, y es común al interactuar con identificadores de archivo y de canalización, identificadores de registro, identificadores de espera o punteros a bloques de memoria sin administrar.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-110">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="4c0cf-111">Esto se debe a que el recolector de elementos no utilizados no puede reclamar objetos no administrados.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-111">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="4c0cf-112">Para asegurarse de que los recursos se limpien siempre correctamente, un método <xref:System.IDisposable.Dispose%2A> debe ser idempotente, de manera que sea invocable varias veces sin que se produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-112">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="4c0cf-113">Además, las siguientes invocaciones de <xref:System.IDisposable.Dispose%2A> no deben hacer nada.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-113">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="4c0cf-114">El ejemplo de código proporcionado para el método <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> muestra cómo la recolección de elementos no utilizados puede hacer que un finalizador se ejecute mientras una referencia no administrada al objeto o a sus miembros todavía está en uso.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-114">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="4c0cf-115">Usar <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> tiene sentido para hacer que el objeto no sea válido para la recolección de elementos no utilizados desde el principio de la rutina actual y hasta el momento en que se llamó a este método.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-115">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="4c0cf-116">Identificadores seguros</span><span class="sxs-lookup"><span data-stu-id="4c0cf-116">Safe handles</span></span>

<span data-ttu-id="4c0cf-117">La escritura de código para el finalizador de un objeto es una tarea compleja que puede producir problemas si no se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-117">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="4c0cf-118">Por tanto, se recomienda construir objetos <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> en lugar de implementar un finalizador.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-118">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="4c0cf-119">Un <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> es un tipo administrado abstracto que contiene un <xref:System.IntPtr?displayProperty=nameWithType> que identifica un recurso no administrado.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-119">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="4c0cf-120">En Windows, puede identificar un identificador y, en UNIX, un descriptor de archivo.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-120">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="4c0cf-121">Proporciona toda la lógica necesaria para asegurarse de que este recurso se libera una vez y solo una vez, cuando se elimina `SafeHandle` o cuando se quitan todas las referencias a `SafeHandle` y se finaliza la instancia de `SafeHandle`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-121">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="4c0cf-122"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> es una clase base abstracta.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-122">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="4c0cf-123">Las clases derivadas proporcionan instancias específicas para diferentes tipos de identificadores.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-123">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="4c0cf-124">Estas clases derivadas validan qué valores de <xref:System.IntPtr?displayProperty=nameWithType> se consideran no válidos y cómo liberar realmente el identificador.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-124">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="4c0cf-125">Por ejemplo, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> se deriva de `SafeHandle` para ajustar `IntPtrs` que identifican los identificadores o descriptores de archivos abiertos e invalida su método <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> para cerrarlo (a través de la función `close` en Unix o la función `CloseHandle` en Windows).</span><span class="sxs-lookup"><span data-stu-id="4c0cf-125">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="4c0cf-126">La mayoría de las API de las bibliotecas de .NET que crean un recurso no administrado lo encapsularán en `SafeHandle` y devolverán ese `SafeHandle` según sea necesario, en lugar de volver a entregar el puntero básico.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-126">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="4c0cf-127">En situaciones en las que interactúe con un componente no administrado y obtenga `IntPtr` para un recurso no administrado, puede crear su propio tipo de `SafeHandle` para ajustarlo.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-127">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="4c0cf-128">Como resultado, algunos tipos no `SafeHandle` necesitan implementar finalizadores; la mayoría de las implementaciones de patrón descartable solo terminan con el ajuste de otros recursos administrados, algunos de los cuales pueden ser `SafeHandle`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-128">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="4c0cf-129">Las clases derivadas siguientes en el espacio de nombres <xref:Microsoft.Win32.SafeHandles> proporcionan controladores seguros:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-129">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="4c0cf-130">La clase <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> y <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> para archivos, archivos asignados en memoria y canalizaciones.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-130">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="4c0cf-131">La clase <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> para vistas de memoria.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-131">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="4c0cf-132">Las clases <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> y <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> para construcciones criptográficas.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-132">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="4c0cf-133">La clase <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> para claves del Registro.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-133">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="4c0cf-134">La clase <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> para identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-134">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="4c0cf-135">Dispose() y Dispose (booleano)</span><span class="sxs-lookup"><span data-stu-id="4c0cf-135">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="4c0cf-136">La interfaz <xref:System.IDisposable> requiere la implementación de un único método sin parámetros, <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-136">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="4c0cf-137">Además, cualquier clase no sellada debe tener un método de sobrecarga `Dispose(bool)` adicional que se va a implementar:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-137">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="4c0cf-138">Una implementación `public` que no sea virtual ( `NonInheritable` en Visual Basic) de tipo <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> que no tenga parámetros.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-138">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="4c0cf-139">Un método `protected virtual` (`Overridable` en Visual Basic) de tipo `Dispose` cuya signatura sea:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-139">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="4c0cf-140">El parámetro `disposing` debe ser `false` cuando se llama desde un finalizador y `true` cuando se llama desde el método <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-140">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4c0cf-141">En otras palabras, es `true` cuando se llama de forma determinista y `false` cuando se llama de forma no determinista.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-141">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="4c0cf-142">Método Dispose()</span><span class="sxs-lookup"><span data-stu-id="4c0cf-142">The Dispose() method</span></span>

<span data-ttu-id="4c0cf-143">Dado que un consumidor del tipo llama a este método`Dispose` `public`, no virtual (`NonInheritable` en Visual Basic) y sin parámetros, su propósito consiste en liberar recursos no administrados, realizar limpiezas generales e indicar que el finalizador, si existe, no tiene que ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-143">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="4c0cf-144">La liberación de la memoria real asociada a un objeto administrado es siempre una tarea que corresponde al [recolector de elementos no utilizados](index.md).</span><span class="sxs-lookup"><span data-stu-id="4c0cf-144">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="4c0cf-145">Debido a esto, se realiza una implementación estándar:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-145">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="4c0cf-146">El método `Dispose` limpia todos los objetos, por lo que el recolector de elementos no utilizados no necesita llamar a la invalidación <xref:System.Object.Finalize%2A?displayProperty=nameWithType> de los objetos.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-146">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="4c0cf-147">Por consiguiente, la llamada al método <xref:System.GC.SuppressFinalize%2A> evita que el recolector de elementos no utilizados ejecute el finalizador.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-147">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="4c0cf-148">Si el tipo no tiene ningún finalizador, la llamada a <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-148">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="4c0cf-149">Tenga en cuenta que la limpieza real se realiza mediante la sobrecarga del método `Dispose(bool)`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-149">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="4c0cf-150">Sobrecarga del método Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="4c0cf-150">The Dispose(bool) method overload</span></span>

<span data-ttu-id="4c0cf-151">En la sobrecarga, el parámetro `disposing` es un valor <xref:System.Boolean> que indica si la llamada al método procede de un método <xref:System.IDisposable.Dispose%2A> (su valor es `true`) o de un finalizador (su valor es `false`).</span><span class="sxs-lookup"><span data-stu-id="4c0cf-151">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="4c0cf-152">El cuerpo del método consta de dos bloques de código:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-152">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="4c0cf-153">Un bloque que libera los recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-153">A block that frees unmanaged resources.</span></span> <span data-ttu-id="4c0cf-154">Este bloque se ejecuta independientemente del valor del parámetro `disposing`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-154">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="4c0cf-155">Un bloque condicional que libera los recursos administrados.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-155">A conditional block that frees managed resources.</span></span> <span data-ttu-id="4c0cf-156">Este bloque se ejecuta si el valor de `disposing` es `true`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-156">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="4c0cf-157">Estos son algunos de los recursos administrados que se liberan:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-157">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="4c0cf-158">**Objetos administrados que implementan <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="4c0cf-158">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="4c0cf-159">El bloque condicional se puede utilizar para llamar a la implementación <xref:System.IDisposable.Dispose%2A> (eliminación en cascada).</span><span class="sxs-lookup"><span data-stu-id="4c0cf-159">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="4c0cf-160">Si ha utilizado una clase derivada de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> para ajustar el recurso no administrado, debe llamar aquí a la implementación <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-160">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="4c0cf-161">**Objetos administrados que consumen gran cantidad de memoria o recursos insuficientes.**</span><span class="sxs-lookup"><span data-stu-id="4c0cf-161">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="4c0cf-162">Asigne referencias de objetos administrados grandes a `null` para aumentar la probabilidad de que no se pueda acceder a ellos.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-162">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="4c0cf-163">De este modo, se liberan más rápido que si se recuperaran de forma no determinista.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-163">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="4c0cf-164">Si la llamada al método procede de un finalizador, solo se debe ejecutar el código que libera los recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-164">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="4c0cf-165">El implementador es responsable de garantizar que la ruta de acceso falsa no interactúe con los objetos administrados que se pueden haber reclamado.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-165">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="4c0cf-166">Esto es importante porque el orden en el que el recolector de elementos no utilizados destruye los objetos administrados durante la finalización no es determinista.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-166">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="4c0cf-167">Llamadas de eliminación en cascada</span><span class="sxs-lookup"><span data-stu-id="4c0cf-167">Cascade dispose calls</span></span>

<span data-ttu-id="4c0cf-168">Si la clase posee un campo o una propiedad y su tipo implementa <xref:System.IDisposable>, la propia clase contenedora también debe implementar <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-168">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="4c0cf-169">Una clase que crea instancias de una implementación de <xref:System.IDisposable> y la almacena como un miembro de instancia, también es responsable de su limpieza.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-169">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="4c0cf-170">Esto ayuda a garantizar que los tipos descartables a los que se hace referencia tienen la oportunidad de realizar una limpieza determinista mediante el método <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-170">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="4c0cf-171">En este ejemplo, la clase es `sealed` (o `NotInheritable` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4c0cf-171">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="4c0cf-172">Implementación del patrón Dispose</span><span class="sxs-lookup"><span data-stu-id="4c0cf-172">Implement the dispose pattern</span></span>

<span data-ttu-id="4c0cf-173">Todas las clases no selladas o (clases de Visual Basic no modificadas como `NotInheritable`) deben considerarse una clase base potencial, ya que se podrían heredar.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-173">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="4c0cf-174">Cuando se implementa el patrón de Dispose para cualquier clase base potencial, debe proporcionar lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-174">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="4c0cf-175">Una implementación <xref:System.IDisposable.Dispose%2A> que llame al método `Dispose(bool)`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-175">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="4c0cf-176">Un método `Dispose(bool)` que realiza la tarea real de limpieza.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-176">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="4c0cf-177">Una clase derivada de <xref:System.Runtime.InteropServices.SafeHandle> que contiene el recurso no administrado (recomendado), o una invalidación del método <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-177">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4c0cf-178">La clase <xref:System.Runtime.InteropServices.SafeHandle> proporciona un finalizador, por lo que no tiene que escribir uno personalmente.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-178">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4c0cf-179">Es posible que una clase base solo haga referencia a objetos administrados e implemente el patrón de Dispose.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-179">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="4c0cf-180">En estos casos, un finalizador no es necesario.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-180">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="4c0cf-181">Un finalizador solo es necesario si se hace referencia directamente a los recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-181">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="4c0cf-182">A continuación se muestra el patrón general para implementar el patrón de Dispose para una clase base que utiliza un controlador seguro.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-182">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="4c0cf-183">El ejemplo anterior utiliza un objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para ilustrar el patrón; cualquier objeto derivado de <xref:System.Runtime.InteropServices.SafeHandle> podría usarse en su lugar.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-183">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="4c0cf-184">Tenga en cuenta que el ejemplo no crea una instancia de su objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> correctamente.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-184">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="4c0cf-185">A continuación se muestra el patrón general para implementar el patrón de Dispose para una clase base que invalide a <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-185">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="4c0cf-186">En C#, se crea un [finalizador](../../csharp/programming-guide/classes-and-structs/destructors.md) invalidando <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-186">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4c0cf-187">En Visual Basic, esto se hace con `Protected Overrides Sub Finalize()`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-187">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="4c0cf-188">Implementación del patrón de Dispose para una clase derivada</span><span class="sxs-lookup"><span data-stu-id="4c0cf-188">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="4c0cf-189">Una clase derivada de una clase que implemente la interfaz <xref:System.IDisposable> no debe implementar <xref:System.IDisposable>, porque la implementación de la clase base de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> la heredan sus clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-189">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="4c0cf-190">En su lugar, para limpiar una clase derivada, debe proporcionar los siguientes elementos:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-190">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="4c0cf-191">Un método `protected override void Dispose(bool)` que invalide el método de la clase base y realice la limpieza real de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-191">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="4c0cf-192">Este método también debe llamar al método `base.Dispose(bool)` (`MyBase.Dispose(bool)` en Visual Basic) de la clase base y pasar su estado disposing para el argumento.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-192">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="4c0cf-193">Una clase derivada de <xref:System.Runtime.InteropServices.SafeHandle> que contiene el recurso no administrado (recomendado), o una invalidación del método <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-193">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4c0cf-194">La clase <xref:System.Runtime.InteropServices.SafeHandle> proporciona un finalizador que evita que tenga que codificar uno.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-194">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="4c0cf-195">Si proporciona un finalizador, debe llamar a la sobrecarga de `Dispose(bool)` con un argumento `disposing` que sea `false`.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-195">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="4c0cf-196">A continuación se muestra el patrón general para implementar el patrón de Dispose para una clase derivada que utiliza un controlador seguro:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-196">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="4c0cf-197">El ejemplo anterior utiliza un objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para ilustrar el patrón; cualquier objeto derivado de <xref:System.Runtime.InteropServices.SafeHandle> podría usarse en su lugar.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-197">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="4c0cf-198">Tenga en cuenta que el ejemplo no crea una instancia de su objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> correctamente.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-198">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="4c0cf-199">A continuación se muestra el patrón general para implementar el patrón de Dispose para una clase derivada que invalide a <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="4c0cf-199">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="4c0cf-200">Implementación del patrón de Dispose con identificadores seguros</span><span class="sxs-lookup"><span data-stu-id="4c0cf-200">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="4c0cf-201">En el ejemplo siguiente se muestra el patrón de Dispose para una clase base, `DisposableStreamResource`, que utiliza un controlador seguro para encapsular los recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-201">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="4c0cf-202">Define una clase `DisposableStreamResource` que utiliza un <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para incluir un objeto <xref:System.IO.Stream> que representa un archivo abierto.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-202">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="4c0cf-203">La clase también incluye una propiedad única, `Size`, que devuelve el número total de bytes de la secuencia de archivos.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-203">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="4c0cf-204">Implementación del patrón de Dispose para una clase derivada con identificadores seguros</span><span class="sxs-lookup"><span data-stu-id="4c0cf-204">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="4c0cf-205">En el ejemplo siguiente se muestra el patrón de Dispose para una clase derivada, `DisposableStreamResource2`, que se hereda de la clase `DisposableStreamResource` mostrada en el ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-205">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="4c0cf-206">La clase agrega un método adicional, `WriteFileInfo`, y utiliza un objeto <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> para incluir el identificador del archivo editable.</span><span class="sxs-lookup"><span data-stu-id="4c0cf-206">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="4c0cf-207">Vea también</span><span class="sxs-lookup"><span data-stu-id="4c0cf-207">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="4c0cf-208">Definición y uso de clases y estructuras (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="4c0cf-208">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
