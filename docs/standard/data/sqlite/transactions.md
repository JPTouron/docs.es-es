---
title: Transacciones
ms.date: 09/08/2020
description: Obtenga información sobre cómo usar las transacciones.
ms.openlocfilehash: 50c4cd1023eac892cafc3ae4395e9168bd8e9f36
ms.sourcegitcommit: aa6d8a90a4f5d8fe0f6e967980b8c98433f05a44
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2020
ms.locfileid: "90678867"
---
# <a name="transactions"></a><span data-ttu-id="3768a-103">Transacciones</span><span class="sxs-lookup"><span data-stu-id="3768a-103">Transactions</span></span>

<span data-ttu-id="3768a-104">Las transacciones permiten agrupar varias instrucciones SQL en una misma unidad de trabajo que se confirma en la base de datos como una unidad atómica.</span><span class="sxs-lookup"><span data-stu-id="3768a-104">Transactions let you group multiple SQL statements into a single unit of work that is committed to the database as one atomic unit.</span></span> <span data-ttu-id="3768a-105">Si se produce un error en una instrucción de la transacción, los cambios realizados por las instrucciones anteriores se pueden revertir.</span><span class="sxs-lookup"><span data-stu-id="3768a-105">If any statement in the transaction fails, changes made by the previous statements can be rolled back.</span></span> <span data-ttu-id="3768a-106">Se conservará el estado inicial de la base de datos cuando se inició la transacción.</span><span class="sxs-lookup"><span data-stu-id="3768a-106">The initial state of the database when the transaction was started is preserved.</span></span> <span data-ttu-id="3768a-107">El uso de una transacción también puede mejorar el rendimiento en SQLite cuando se realizan varios cambios en la base de datos a la vez.</span><span class="sxs-lookup"><span data-stu-id="3768a-107">Using a transaction can also improve performance on SQLite when making numerous changes to the database at once.</span></span>

## <a name="concurrency"></a><span data-ttu-id="3768a-108">simultaneidad</span><span class="sxs-lookup"><span data-stu-id="3768a-108">Concurrency</span></span>

<span data-ttu-id="3768a-109">En SQLite, solo una transacción puede tener cambios pendientes en la base de datos en un momento determinado.</span><span class="sxs-lookup"><span data-stu-id="3768a-109">In SQLite, only one transaction is allowed to have changes pending in the database at a time.</span></span> <span data-ttu-id="3768a-110">Por este motivo, el tiempo de espera de las llamadas a los métodos <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> y `Execute` en <xref:Microsoft.Data.Sqlite.SqliteCommand> se puede agotar si otra transacción tarda demasiado en completarse.</span><span class="sxs-lookup"><span data-stu-id="3768a-110">Because of this, calls to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> and the `Execute` methods on <xref:Microsoft.Data.Sqlite.SqliteCommand> may time out if another transaction takes too long to complete.</span></span>

<span data-ttu-id="3768a-111">Para más información sobre los bloqueos, los reintentos y los tiempos de espera, vea [Errores de base de datos](database-errors.md).</span><span class="sxs-lookup"><span data-stu-id="3768a-111">For more information about locking, retries, and timeouts, see [Database errors](database-errors.md).</span></span>

## <a name="isolation-levels"></a><span data-ttu-id="3768a-112">Niveles de aislamiento</span><span class="sxs-lookup"><span data-stu-id="3768a-112">Isolation levels</span></span>

<span data-ttu-id="3768a-113">Las transacciones se **serializan** de forma predeterminada en SQLite.</span><span class="sxs-lookup"><span data-stu-id="3768a-113">Transactions are **serializable** by default in SQLite.</span></span> <span data-ttu-id="3768a-114">Este nivel de aislamiento garantiza que los cambios realizados en una transacción estén completamente aislados.</span><span class="sxs-lookup"><span data-stu-id="3768a-114">This isolation level guarantees that any changes made within a transaction are completely isolated.</span></span> <span data-ttu-id="3768a-115">El resto de instrucciones ejecutadas fuera de la transacción no se verán afectadas por los cambios de la transacción.</span><span class="sxs-lookup"><span data-stu-id="3768a-115">Other statements executed outside of the transaction aren't affected by the transaction's changes.</span></span>

<span data-ttu-id="3768a-116">SQLite también admite la **lectura no confirmada** cuando se usa una memoria caché compartida.</span><span class="sxs-lookup"><span data-stu-id="3768a-116">SQLite also supports **read uncommitted** when using a shared cache.</span></span> <span data-ttu-id="3768a-117">Este nivel permite lecturas de datos sucios, lecturas no repetibles y filas fantasma:</span><span class="sxs-lookup"><span data-stu-id="3768a-117">This level allows dirty reads, nonrepeatable reads, and phantoms:</span></span>

- <span data-ttu-id="3768a-118">Una *lectura de datos sucios* es aquella que se produce cuando una consulta fuera de la transacción devuelve los cambios pendientes de una transacción, pero esos cambios en la transacción se revierten.</span><span class="sxs-lookup"><span data-stu-id="3768a-118">A *dirty read* occurs when changes pending in one transaction are returned by a query outside of the transaction, but the changes in the transaction are rolled back.</span></span> <span data-ttu-id="3768a-119">Los resultados contienen datos que nunca se confirmaron realmente en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="3768a-119">The results contain data that was never actually committed to the database.</span></span>

- <span data-ttu-id="3768a-120">Una *lectura no repetible* es aquella que se produce cuando una transacción consulta la misma fila dos veces, pero los resultados son diferentes porque otra transacción cambió la fila entre una consulta y la otra.</span><span class="sxs-lookup"><span data-stu-id="3768a-120">A *nonrepeatable read* occurs when a transaction queries same row twice, but the results are different because it was changed between the two queries by another transaction.</span></span>

- <span data-ttu-id="3768a-121">Las *filas fantasma* son filas que se cambian o se agregan para cumplir la cláusula WHERE de una consulta durante una transacción.</span><span class="sxs-lookup"><span data-stu-id="3768a-121">*Phantoms* are rows that get changed or added to meet the where clause of a query during a transaction.</span></span> <span data-ttu-id="3768a-122">Si se permite, la misma consulta podría devolver filas diferentes si se ejecutase dos veces en la misma transacción.</span><span class="sxs-lookup"><span data-stu-id="3768a-122">If allowed, the same query could return different rows when executed twice in the same transaction.</span></span>

<span data-ttu-id="3768a-123">Microsoft.Data.Sqlite trata el nivel IsolationLevel pasado a <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> como el nivel mínimo.</span><span class="sxs-lookup"><span data-stu-id="3768a-123">Microsoft.Data.Sqlite treats the IsolationLevel passed to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> as a minimum level.</span></span> <span data-ttu-id="3768a-124">El nivel de aislamiento real subirá a lectura no confirmada o serializable.</span><span class="sxs-lookup"><span data-stu-id="3768a-124">The actual isolation level will be promoted to either read uncommitted or serializable.</span></span>

<span data-ttu-id="3768a-125">En el siguiente código se simula una lectura de datos sucios.</span><span class="sxs-lookup"><span data-stu-id="3768a-125">The following code simulates a dirty read.</span></span> <span data-ttu-id="3768a-126">Fíjese en que la cadena de conexión debe incluir `Cache=Shared`.</span><span class="sxs-lookup"><span data-stu-id="3768a-126">Note, the connection string must include `Cache=Shared`.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DirtyReadSample/Program.cs?name=snippet_DirtyRead)]

## <a name="deferred-transactions"></a><span data-ttu-id="3768a-127">Transacciones diferidas</span><span class="sxs-lookup"><span data-stu-id="3768a-127">Deferred transactions</span></span>

<span data-ttu-id="3768a-128">A partir de la versión 5.0 de Microsoft.Data.Sqlite, las transacciones se pueden diferir.</span><span class="sxs-lookup"><span data-stu-id="3768a-128">Starting with Microsoft.Data.Sqlite version 5.0, transactions can be deferred.</span></span> <span data-ttu-id="3768a-129">Esto aplaza la creación de la transacción real en la base de datos hasta que se ejecute el primer comando.</span><span class="sxs-lookup"><span data-stu-id="3768a-129">This defers the creation of the actual transaction in the database until the first command is executed.</span></span> <span data-ttu-id="3768a-130">También hace que la transacción se actualice de manera gradual de una transacción de lectura a una de escritura, según las necesidades de sus comandos.</span><span class="sxs-lookup"><span data-stu-id="3768a-130">It also causes the transaction to gradually upgrade from a read transaction to a write transaction as needed by its commands.</span></span> <span data-ttu-id="3768a-131">Esto puede ser útil para habilitar el acceso simultáneo a la base de datos durante la transacción.</span><span class="sxs-lookup"><span data-stu-id="3768a-131">This can be useful for enabling concurrent access to the database during the transaction.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DeferredTransactionSample/Program.cs?name=snippet_DeferredTransaction)]

> [!WARNING]
> <span data-ttu-id="3768a-132">Los comandos dentro de una transacción diferida pueden producir un error si hacen que la transacción se actualice de una transacción de lectura a una de escritura mientras la base de datos está bloqueada.</span><span class="sxs-lookup"><span data-stu-id="3768a-132">Commands inside a deferred transaction can fail if they cause the transaction to be upgraded from a read transaction to a write transaction while the database is locked.</span></span> <span data-ttu-id="3768a-133">Cuando esto ocurre, la aplicación tendrá que reintentar la transacción completa.</span><span class="sxs-lookup"><span data-stu-id="3768a-133">When this happens, the application will need to retry the entire transaction.</span></span>
