---
description: Error del compilador CS0165
title: Error del compilador CS0165
ms.date: 07/20/2015
f1_keywords:
- CS0165
helpviewer_keywords:
- CS0165
ms.assetid: e7eb7c90-af16-4734-b747-214030696975
ms.openlocfilehash: 8256154a7cb8ad7affa1e497f83a7ada9956b69b
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 08/30/2020
ms.locfileid: "89137349"
---
# <a name="compiler-error-cs0165"></a><span data-ttu-id="9553b-103">Error del compilador CS0165</span><span class="sxs-lookup"><span data-stu-id="9553b-103">Compiler Error CS0165</span></span>

<span data-ttu-id="9553b-104">Uso de la variable local no asignada "name"</span><span class="sxs-lookup"><span data-stu-id="9553b-104">Use of unassigned local variable 'name'</span></span>  
  
<span data-ttu-id="9553b-105">El compilador de C# no permite el uso de variables no inicializadas.</span><span class="sxs-lookup"><span data-stu-id="9553b-105">The C# compiler doesn't allow the use of uninitialized variables.</span></span> <span data-ttu-id="9553b-106">Si el compilador detecta el uso de una variable que pueda no haberse inicializado, genera el error CS0165.</span><span class="sxs-lookup"><span data-stu-id="9553b-106">If the compiler detects the use of a variable that might not have been initialized, it generates compiler error CS0165.</span></span> <span data-ttu-id="9553b-107">Para obtener más información, vea [Campos (Guía de programación de C#)](../../programming-guide/classes-and-structs/fields.md).</span><span class="sxs-lookup"><span data-stu-id="9553b-107">For more information, see [Fields](../../programming-guide/classes-and-structs/fields.md).</span></span> <span data-ttu-id="9553b-108">Este error se genera cuando el compilador encuentra una construcción que podría dar como resultado el uso de una variable no asignada, incluso en el caso de que su código determinado no la use.</span><span class="sxs-lookup"><span data-stu-id="9553b-108">This error is generated when the compiler encounters a construct that might result in the use of an unassigned variable, even if your particular code does not.</span></span> <span data-ttu-id="9553b-109">Esto evita tener que usar reglas demasiado complejas para la asignación definitiva.</span><span class="sxs-lookup"><span data-stu-id="9553b-109">This avoids the necessity of overly complex rules for definite assignment.</span></span>  
  
<span data-ttu-id="9553b-110">Para más información, consulte [Why does a recursive lambda cause a definite assignment error?](https://docs.microsoft.com/archive/blogs/ericlippert/why-does-a-recursive-lambda-cause-a-definite-assignment-error) (¿Por qué se producen un error de asignación definitivo en una expresión lambda recursiva?).</span><span class="sxs-lookup"><span data-stu-id="9553b-110">For more information, see [Why does a recursive lambda cause a definite assignment error?](https://docs.microsoft.com/archive/blogs/ericlippert/why-does-a-recursive-lambda-cause-a-definite-assignment-error).</span></span>  
  
## <a name="example"></a><span data-ttu-id="9553b-111">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="9553b-111">Example</span></span>  

<span data-ttu-id="9553b-112">En el ejemplo siguiente se genera el error CS0165:</span><span class="sxs-lookup"><span data-stu-id="9553b-112">The following sample generates CS0165:</span></span>  
  
```csharp  
// CS0165.cs  
using System;  
  
class MyClass  
{  
    public int i;  
}  
  
class MyClass2  
{  
    public static void Main(string[] args)  
    {  
        // i and j are not initialized.  
        int i, j;  
  
        // You can provide a value for args[0] in the 'Command line arguments'  
        // text box on the Debug tab of the project Properties window.  
        if (args[0] == "test")  
        {  
            i = 0;  
        }  
        // If the following else clause is absent, i might not be  
        // initialized.  
        //else  
        //{  
        //    i = 1;  
        //}  
  
        // Because i might not have been initialized, the following
        // line causes CS0165.  
        j = i;  
  
        // To resolve the error, uncomment the else clause of the previous  
        // if statement, or initialize i when you declare it.  
  
        // The following example causes CS0165 because myInstance is  
        // declared but not instantiated.  
        MyClass myInstance;  
        // The following line causes the error.  
        myInstance.i = 0;
  
        // To resolve the error, replace the previous declaration with  
        // the following line.  
        //MyClass myInstance = new MyClass();  
    }  
}  
```  
  
## <a name="example"></a><span data-ttu-id="9553b-113">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="9553b-113">Example</span></span>  

<span data-ttu-id="9553b-114">El error del compilador CS0165 puede producirse en definiciones de delegados recursivas.</span><span class="sxs-lookup"><span data-stu-id="9553b-114">Compiler error CS0165 can occur in recursive delegate definitions.</span></span> <span data-ttu-id="9553b-115">Puede evitarlo mediante la definición del delegado en dos instrucciones, de manera que la variable no se use antes de inicializarse.</span><span class="sxs-lookup"><span data-stu-id="9553b-115">You can avoid the error by defining the delegate in two statements so that the variable is not used before it is initialized.</span></span> <span data-ttu-id="9553b-116">En el ejemplo siguiente se muestra el error y la resolución.</span><span class="sxs-lookup"><span data-stu-id="9553b-116">The following example demonstrates the error and the resolution.</span></span>  
  
```csharp  
class Program  
{  
    delegate void Del();  
    static void Main(string[] args)  
    {  
        // The following line causes CS0165 because variable d is used
        // as an argument before it has been initialized.  
        Del d = delegate() { System.Console.WriteLine(d); };
  
        //// To resolve the error, initialize d in a separate statement.  
        //Del d = null;  
        //// After d is initialized, you can use it as an argument.  
        //d = delegate() { System.Console.WriteLine(d); };  
        //d();  
    }  
}  
```
