---
description: Error del compilador CS0029
title: Error del compilador CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 310a730733cb76b0afb29f5496ad22b77fb29243
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 08/30/2020
ms.locfileid: "89139936"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="e6605-103">Error del compilador CS0029</span><span class="sxs-lookup"><span data-stu-id="e6605-103">Compiler Error CS0029</span></span>

<span data-ttu-id="e6605-104">No se puede convertir implícitamente el tipo 'type' en 'type'</span><span class="sxs-lookup"><span data-stu-id="e6605-104">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="e6605-105">El compilador requiere una conversión explícita.</span><span class="sxs-lookup"><span data-stu-id="e6605-105">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="e6605-106">Por ejemplo, puede que necesite convertir un valor R para que sea del mismo tipo que un valor L.</span><span class="sxs-lookup"><span data-stu-id="e6605-106">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="e6605-107">O bien, debe proporcionar rutinas de conversión para poder admitir ciertas sobrecargas de operador.</span><span class="sxs-lookup"><span data-stu-id="e6605-107">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="e6605-108">Las conversiones deben producirse al asignar una variable de un tipo a una variable de un tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="e6605-108">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="e6605-109">Al realizar una asignación entre variables de tipos diferentes, el compilador debe convertir el tipo en el lado derecho del operador de asignación al tipo del lado izquierdo del operador de asignación.</span><span class="sxs-lookup"><span data-stu-id="e6605-109">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="e6605-110">Considere el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="e6605-110">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="e6605-111">`i = lng;` realiza una asignación, pero los tipos de datos de las variables en el lado izquierdo y derecho del operador de asignación no coinciden.</span><span class="sxs-lookup"><span data-stu-id="e6605-111">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="e6605-112">Antes de realizar la asignación, el compilador está convirtiendo implícitamente la variable `lng`, que es de tipo long, a int. Esto se realiza de manera implícita porque ningún código ha indicado explícitamente al compilador que realice esta conversión.</span><span class="sxs-lookup"><span data-stu-id="e6605-112">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="e6605-113">El problema con este código es que se considera una conversión de restricción, y el compilador no permite conversiones de restricción implícitas porque podría haber una pérdida de datos potencial.</span><span class="sxs-lookup"><span data-stu-id="e6605-113">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="e6605-114">Una conversión de restricción existe cuando se convierte a un tipo de datos que ocupa menos espacio de almacenamiento en la memoria que el tipo de datos desde el que se está convirtiendo.</span><span class="sxs-lookup"><span data-stu-id="e6605-114">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="e6605-115">Por ejemplo, convertir long en int se consideraría una conversión de restricción.</span><span class="sxs-lookup"><span data-stu-id="e6605-115">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="e6605-116">Un valor long ocupa 8 bytes de memoria mientras que int ocupa 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="e6605-116">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="e6605-117">Para ver cómo puede producirse una pérdida de datos, considere el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="e6605-117">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="e6605-118">La variable `lng` ahora contiene un valor que no puede almacenarse en la variable `i` porque es demasiado grande.</span><span class="sxs-lookup"><span data-stu-id="e6605-118">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="e6605-119">Si fuéramos a convertir este valor a un tipo int estaríamos perdiendo algunos de nuestros datos y el valor convertido no sería el mismo que el valor antes de la conversión.</span><span class="sxs-lookup"><span data-stu-id="e6605-119">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="e6605-120">Una conversión de ampliación sería lo contrario que una conversión de restricción.</span><span class="sxs-lookup"><span data-stu-id="e6605-120">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="e6605-121">Con conversiones de ampliación, estamos convirtiendo a un tipo de datos que ocupa más espacio de almacenamiento en la memoria que el tipo de datos desde el que se está convirtiendo.</span><span class="sxs-lookup"><span data-stu-id="e6605-121">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="e6605-122">Aquí se muestra un ejemplo de una conversión de ampliación:</span><span class="sxs-lookup"><span data-stu-id="e6605-122">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="e6605-123">Observe la diferencia entre este ejemplo de código y el primero.</span><span class="sxs-lookup"><span data-stu-id="e6605-123">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="e6605-124">Esta vez la variable `lng` está en el lado izquierdo del operador de asignación, así que es el destino de nuestra asignación.</span><span class="sxs-lookup"><span data-stu-id="e6605-124">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="e6605-125">Antes de que se realice la asignación, el compilador debe convertir implícitamente la variable `i`, que es de tipo int, a tipo long.</span><span class="sxs-lookup"><span data-stu-id="e6605-125">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="e6605-126">Esta es una conversión de ampliación ya que estamos convirtiendo de un tipo que ocupa 4 bytes de memoria (un int) a un tipo que ocupa 8 bytes de memoria (un long).</span><span class="sxs-lookup"><span data-stu-id="e6605-126">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="e6605-127">Las conversiones de ampliación implícitas se permiten porque no existe una pérdida de datos potencial.</span><span class="sxs-lookup"><span data-stu-id="e6605-127">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="e6605-128">Cualquier valor que puede almacenarse en un int también puede almacenarse en un long.</span><span class="sxs-lookup"><span data-stu-id="e6605-128">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="e6605-129">Sabemos que las conversiones de ampliación implícitas no se permiten, de manera que para poder compilar este código necesitamos convertir explícitamente el tipo de datos.</span><span class="sxs-lookup"><span data-stu-id="e6605-129">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="e6605-130">Las conversiones explícitas se realizan mediante la conversión.</span><span class="sxs-lookup"><span data-stu-id="e6605-130">Explicit conversions are done using casting.</span></span> <span data-ttu-id="e6605-131">La conversión es el término que se usa en C# para describir la conversión de un tipo de datos a otro.</span><span class="sxs-lookup"><span data-stu-id="e6605-131">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="e6605-132">Para obtener el código que se va a compilar necesitaríamos usar la sintaxis siguiente:</span><span class="sxs-lookup"><span data-stu-id="e6605-132">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="e6605-133">La tercera línea de código indica al compilador que convierta explícitamente la variable `lng`, que es de tipo long, a un tipo int antes de realizar la asignación.</span><span class="sxs-lookup"><span data-stu-id="e6605-133">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="e6605-134">Recuerde que con una conversión de restricción, existe una pérdida de datos potencial.</span><span class="sxs-lookup"><span data-stu-id="e6605-134">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="e6605-135">Las conversiones de restricción deben usarse con precaución y aunque se compile el código puede obtener resultados inesperados en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e6605-135">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="e6605-136">Esta discusión solo ha sido para los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="e6605-136">This discussion has only been for value types.</span></span> <span data-ttu-id="e6605-137">Al trabajar con tipos de valor, trabaja directamente con los datos almacenados en la variable.</span><span class="sxs-lookup"><span data-stu-id="e6605-137">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="e6605-138">En cambio, .NET Framework también tiene tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="e6605-138">However, the .NET Framework also has reference types.</span></span> <span data-ttu-id="e6605-139">Al trabajar con tipos de referencia, está trabajando con una referencia a una variable, no con los datos reales.</span><span class="sxs-lookup"><span data-stu-id="e6605-139">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="e6605-140">Ejemplos de tipos de referencia serían clases, interfaces y matrices.</span><span class="sxs-lookup"><span data-stu-id="e6605-140">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="e6605-141">No puede convertir implícita o explícitamente un tipo de referencia en otro a no ser que el compilador permita la conversión específica o se implementen los operadores de conversión apropiados.</span><span class="sxs-lookup"><span data-stu-id="e6605-141">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="e6605-142">En el ejemplo siguiente se genera la advertencia CS0029:</span><span class="sxs-lookup"><span data-stu-id="e6605-142">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="e6605-143">Vea también</span><span class="sxs-lookup"><span data-stu-id="e6605-143">See also</span></span>

- [<span data-ttu-id="e6605-144">Operadores de conversión definidos por el usuario</span><span class="sxs-lookup"><span data-stu-id="e6605-144">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
