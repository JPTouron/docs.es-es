---
title: 'Genéricos en el tiempo de ejecución: Guía de programación de C#'
description: Aprenda sobre los tipos genéricos en tiempo de ejecución. Vea ejemplos de código y examine los recursos adicionales disponibles.
ms.date: 07/20/2015
helpviewer_keywords:
- generics [C#], at run time
ms.assetid: 119df7e6-9ceb-49df-af36-24f8f8c0747f
ms.openlocfilehash: 8e072e7aa53177929dda0be931beb85863b6a12e
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 07/28/2020
ms.locfileid: "87299232"
---
# <a name="generics-in-the-run-time-c-programming-guide"></a><span data-ttu-id="ba0f3-104">Genéricos en el motor en tiempo de ejecución (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="ba0f3-104">Generics in the Run Time (C# Programming Guide)</span></span>
<span data-ttu-id="ba0f3-105">Cuando se compila un tipo o método genérico en el lenguaje intermedio de Microsoft (MSIL), contiene metadatos que lo identifican como poseedor de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-105">When a generic type or method is compiled into Microsoft intermediate language (MSIL), it contains metadata that identifies it as having type parameters.</span></span> <span data-ttu-id="ba0f3-106">La forma en que se usa MSIL para un tipo genérico depende de si el parámetro de tipo proporcionado es un tipo de valor o de referencia.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-106">How the MSIL for a generic type is used differs based on whether the supplied type parameter is a value type or reference type.</span></span>  
  
 <span data-ttu-id="ba0f3-107">Cuando se construye por primera vez un tipo genérico con un tipo de valor como parámetro, el motor de ejecución crea un tipo genérico especializado sustituyendo el parámetro o los parámetros proporcionados en los lugares adecuados del MSIL.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-107">When a generic type is first constructed with a value type as a parameter, the runtime creates a specialized generic type with the supplied parameter or parameters substituted in the appropriate locations in the MSIL.</span></span> <span data-ttu-id="ba0f3-108">Los tipos genéricos especializados se crean una vez para cada tipo de valor único que se usa como parámetro.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-108">Specialized generic types are created one time for each unique value type that is used as a parameter.</span></span>  
  
 <span data-ttu-id="ba0f3-109">Por ejemplo, suponga que el código de su programa ha declarado una pila compuesta por enteros:</span><span class="sxs-lookup"><span data-stu-id="ba0f3-109">For example, suppose your program code declared a stack that is constructed of integers:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#42](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#42)]  
  
 <span data-ttu-id="ba0f3-110">En este momento, el motor de ejecución genera una versión especializada de la clase <xref:System.Collections.Generic.Stack%601> sustituyendo el entero adecuadamente para su parámetro.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-110">At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that has the integer substituted appropriately for its parameter.</span></span> <span data-ttu-id="ba0f3-111">Ahora, cada vez que el código de su programa use una pila de enteros, el motor en tiempo de ejecución vuelve a usar la clase especializada generada <xref:System.Collections.Generic.Stack%601>.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-111">Now, whenever your program code uses a stack of integers, the runtime reuses the generated specialized <xref:System.Collections.Generic.Stack%601> class.</span></span> <span data-ttu-id="ba0f3-112">En el ejemplo siguiente, se crean dos instancias de una pila de enteros y comparten una instancia única del código `Stack<int>`:</span><span class="sxs-lookup"><span data-stu-id="ba0f3-112">In the following example, two instances of a stack of integers are created, and they share a single instance of the `Stack<int>` code:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#43](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#43)]  
  
 <span data-ttu-id="ba0f3-113">En cambio, suponga que otra clase <xref:System.Collections.Generic.Stack%601> con un tipo de valor diferente, como un `long` o una estructura definida por el usuario como parámetro, se crea en otro punto del código.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-113">However, suppose that another <xref:System.Collections.Generic.Stack%601> class with a different value type such as a `long` or a user-defined structure as its parameter is created at another point in your code.</span></span> <span data-ttu-id="ba0f3-114">Como resultado, el motor de ejecución genera otra versión del tipo genérico y sustituye un `long` en los lugares apropiados en el MSIL.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-114">As a result, the runtime generates another version of the generic type and substitutes a `long` in the appropriate locations in MSIL.</span></span> <span data-ttu-id="ba0f3-115">Las conversiones ya no son necesarias porque cada clase genérica especializada contiene de forma nativa el tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-115">Conversions are no longer necessary because each specialized generic class natively contains the value type.</span></span>  
  
 <span data-ttu-id="ba0f3-116">Los genéricos funcionan de forma ligeramente distinta para los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-116">Generics work somewhat differently for reference types.</span></span> <span data-ttu-id="ba0f3-117">Cuando se construye un tipo genérico por primera vez con un tipo de referencia, el motor en tiempo de ejecución crea un tipo genérico especializado sustituyendo las referencias a objetos para los parámetros del MSIL.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-117">The first time a generic type is constructed with any reference type, the runtime creates a specialized generic type with object references substituted for the parameters in the MSIL.</span></span> <span data-ttu-id="ba0f3-118">Después, cada vez que se crea una instancia de un tipo construido con un tipo de referencia como parámetro, independientemente del tipo que sea, el motor de ejecución vuelve a usar la versión especializada del tipo genérico previamente creada.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-118">Then, every time that a constructed type is instantiated with a reference type as its parameter, regardless of what type it is, the runtime reuses the previously created specialized version of the generic type.</span></span> <span data-ttu-id="ba0f3-119">Esto es posible porque todas las referencias son del mismo tamaño.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-119">This is possible because all references are the same size.</span></span>  
  
 <span data-ttu-id="ba0f3-120">Por ejemplo, suponga que tiene dos tipos de referencia, una clase `Customer` y una clase `Order`, y que ha creado una pila de tipos `Customer`:</span><span class="sxs-lookup"><span data-stu-id="ba0f3-120">For example, suppose you had two reference types, a `Customer` class and an `Order` class, and also suppose that you created a stack of `Customer` types:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#47](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#47)]  
  
 [!code-csharp[csProgGuideGenerics#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#44)]  
  
 <span data-ttu-id="ba0f3-121">En este punto, el motor de ejecución genera una versión especializada de la clase <xref:System.Collections.Generic.Stack%601> que, en lugar de almacenar los datos, almacena referencias a objetos que se rellenarán más tarde.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-121">At this point, the runtime generates a specialized version of the <xref:System.Collections.Generic.Stack%601> class that stores object references that will be filled in later instead of storing data.</span></span> <span data-ttu-id="ba0f3-122">Suponga que la línea siguiente de código crea una pila de otro tipo de referencia, que se denomina `Order`:</span><span class="sxs-lookup"><span data-stu-id="ba0f3-122">Suppose the next line of code creates a stack of another reference type, which is named `Order`:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#45](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#45)]  
  
 <span data-ttu-id="ba0f3-123">A diferencia de lo que sucede con los tipos de valor, no se crea otra versión especializada de la clase <xref:System.Collections.Generic.Stack%601> para el tipo `Order`.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-123">Unlike with value types, another specialized version of the <xref:System.Collections.Generic.Stack%601> class is not created for the `Order` type.</span></span> <span data-ttu-id="ba0f3-124">En su lugar, se crea una instancia de la versión especializada de la clase <xref:System.Collections.Generic.Stack%601> y se establece la variable `orders` para hacer referencia a ella.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-124">Instead, an instance of the specialized version of the <xref:System.Collections.Generic.Stack%601> class is created and the `orders` variable is set to reference it.</span></span> <span data-ttu-id="ba0f3-125">Suponga que encuentra una línea de código para crear una pila de tipo `Customer`:</span><span class="sxs-lookup"><span data-stu-id="ba0f3-125">Suppose that you then encountered a line of code to create a stack of a `Customer` type:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#46](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#46)]  
  
 <span data-ttu-id="ba0f3-126">Como con el uso anterior de la clase <xref:System.Collections.Generic.Stack%601> creada usando el tipo `Order`, se crea otra instancia de la clase especializada <xref:System.Collections.Generic.Stack%601>.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-126">As with the previous use of the <xref:System.Collections.Generic.Stack%601> class created by using the `Order` type, another instance of the specialized <xref:System.Collections.Generic.Stack%601> class is created.</span></span> <span data-ttu-id="ba0f3-127">Los punteros contenidos allí se establecen para hacer referencia a un área de memoria del tamaño de un tipo `Customer`.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-127">The pointers that are contained therein are set to reference an area of memory the size of a `Customer` type.</span></span> <span data-ttu-id="ba0f3-128">Dado que el número de tipos de referencia puede variar significativamente de un programa a otro, la implementación de genéricos de C# reduce significativamente la cantidad de código limitando a uno el número de clases especializadas creadas por el compilador para las clases genéricas de tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-128">Because the number of reference types can vary wildly from program to program, the C# implementation of generics greatly reduces the amount of code by reducing to one the number of specialized classes created by the compiler for generic classes of reference types.</span></span>  
  
 <span data-ttu-id="ba0f3-129">Además, cuando se crea una instancia de una clase de C# genérica mediante un parámetro de tipo de valor o de referencia se puede consultar en tiempo de ejecución mediante reflexión, y se puede comprobar tanto su tipo real como su parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="ba0f3-129">Moreover, when a generic C# class is instantiated by using a value type or reference type parameter, reflection can query it at runtime and both its actual type and its type parameter can be ascertained.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ba0f3-130">Consulte también</span><span class="sxs-lookup"><span data-stu-id="ba0f3-130">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="ba0f3-131">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="ba0f3-131">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="ba0f3-132">Introducción a los genéricos</span><span class="sxs-lookup"><span data-stu-id="ba0f3-132">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="ba0f3-133">Genéricos</span><span class="sxs-lookup"><span data-stu-id="ba0f3-133">Generics</span></span>](../../../standard/generics/index.md)
