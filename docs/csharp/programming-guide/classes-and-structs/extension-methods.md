---
title: 'Métodos de extensión: Guía de programación de C#'
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0f9c0f053e531a44640084a35dc5d8e844ee0b46
ms.sourcegitcommit: 1eae045421d9ea2bfc82aaccfa5b1ff1b8c9e0e4
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/16/2020
ms.locfileid: "84803188"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="c8424-102">Métodos de extensión (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="c8424-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="c8424-103">Los métodos de extensión permiten "agregar" métodos a los tipos existentes sin crear un nuevo tipo derivado, recompilar o modificar de otra manera el tipo original.</span><span class="sxs-lookup"><span data-stu-id="c8424-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="c8424-104">Los métodos de extensión son métodos estáticos, pero se les llama como si fueran métodos de instancia en el tipo extendido.</span><span class="sxs-lookup"><span data-stu-id="c8424-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="c8424-105">En el caso del código de cliente escrito en C#, F# y Visual Basic, no existe ninguna diferencia aparente entre llamar a un método de extensión y llamar a los métodos definidos en un tipo.</span><span class="sxs-lookup"><span data-stu-id="c8424-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="c8424-106">Los métodos de extensión más comunes son los operadores de consulta LINQ estándar, que agregan funciones de consulta a los tipos <xref:System.Collections.IEnumerable?displayProperty=nameWithType> y <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> existentes.</span><span class="sxs-lookup"><span data-stu-id="c8424-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="c8424-107">Para usar los operadores de consulta estándar, inclúyalos primero en el ámbito con una directiva `using System.Linq`.</span><span class="sxs-lookup"><span data-stu-id="c8424-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="c8424-108">A partir de ese momento, cualquier tipo que implemente <xref:System.Collections.Generic.IEnumerable%601> parecerá tener métodos de instancia como <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, etc.</span><span class="sxs-lookup"><span data-stu-id="c8424-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="c8424-109">Puede ver estos métodos adicionales en la finalización de instrucciones de IntelliSense al escribir "punto" después de una instancia de un tipo <xref:System.Collections.Generic.IEnumerable%601>, como <xref:System.Collections.Generic.List%601> o <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="c8424-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="c8424-110">Ejemplo de OrderBy</span><span class="sxs-lookup"><span data-stu-id="c8424-110">OrderBy Example</span></span>

<span data-ttu-id="c8424-111">En el ejemplo siguiente se muestra cómo llamar al método `OrderBy` de operador de consulta estándar en una matriz de enteros.</span><span class="sxs-lookup"><span data-stu-id="c8424-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="c8424-112">La expresión entre paréntesis es una expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="c8424-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="c8424-113">Muchos operadores de consulta estándar toman expresiones lambda como parámetros, pero no es un requisito para los métodos de extensión.</span><span class="sxs-lookup"><span data-stu-id="c8424-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="c8424-114">Para obtener más información, vea [Expresiones lambda](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c8424-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="c8424-115">Los métodos de extensión se definen como métodos estáticos, pero se les llama usando la sintaxis de método de instancia.</span><span class="sxs-lookup"><span data-stu-id="c8424-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="c8424-116">Su primer parámetro especifica en qué tipo funciona el método.</span><span class="sxs-lookup"><span data-stu-id="c8424-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="c8424-117">El parámetro va precedido del modificador [this](../../language-reference/keywords/this.md).</span><span class="sxs-lookup"><span data-stu-id="c8424-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="c8424-118">Los métodos de extensión únicamente se encuentran dentro del ámbito cuando el espacio de nombres se importa explícitamente en el código fuente con una directiva `using`.</span><span class="sxs-lookup"><span data-stu-id="c8424-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="c8424-119">En el ejemplo siguiente se muestra un método de extensión definido para la clase <xref:System.String?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c8424-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="c8424-120">Se define dentro de una clase estática no anidada y no genérica:</span><span class="sxs-lookup"><span data-stu-id="c8424-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="c8424-121">El método de extensión `WordCount` se puede incluir en el ámbito con esta directiva `using`:</span><span class="sxs-lookup"><span data-stu-id="c8424-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="c8424-122">También se le puede llamar desde una aplicación con esta sintaxis:</span><span class="sxs-lookup"><span data-stu-id="c8424-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="c8424-123">El método de extensión se invoca en el código con la sintaxis de método de instancia.</span><span class="sxs-lookup"><span data-stu-id="c8424-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="c8424-124">El lenguaje intermedio (IL) generado por el compilador convierte el código en una llamada en el método estático.</span><span class="sxs-lookup"><span data-stu-id="c8424-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="c8424-125">El principio de encapsulación no se infringe realmente.</span><span class="sxs-lookup"><span data-stu-id="c8424-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="c8424-126">Los métodos de extensión no pueden tener acceso a las variables privadas en el tipo que extienden.</span><span class="sxs-lookup"><span data-stu-id="c8424-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="c8424-127">Para obtener más información, vea [Procedimiento para implementar e invocar un método de extensión personalizado](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="c8424-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="c8424-128">En general, probablemente se llamará a métodos de extensión con mucha más frecuencia de la que se implementarán métodos propios.</span><span class="sxs-lookup"><span data-stu-id="c8424-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="c8424-129">Dado que los métodos de extensión se llaman con la sintaxis de método de instancia, no se requieren conocimientos especiales para usarlos desde el código de cliente.</span><span class="sxs-lookup"><span data-stu-id="c8424-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="c8424-130">Para habilitar los métodos de extensión para un tipo determinado, basta con agregar una directiva `using` para el espacio de nombres en el que se definen los métodos.</span><span class="sxs-lookup"><span data-stu-id="c8424-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="c8424-131">Por ejemplo, para usar los operadores de consulta estándar, agregue esta directiva `using` al código:</span><span class="sxs-lookup"><span data-stu-id="c8424-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="c8424-132">(Puede que haya que agregar también una referencia a System.Core.dll). Observará que los operadores de consulta estándar aparecen ahora en IntelliSense como métodos adicionales disponibles para la mayoría de los tipos <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="c8424-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="c8424-133">Enlazar métodos de extensión en tiempo de compilación</span><span class="sxs-lookup"><span data-stu-id="c8424-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="c8424-134">Se pueden usar métodos de extensión para ampliar una clase o interfaz, pero no para invalidarlas.</span><span class="sxs-lookup"><span data-stu-id="c8424-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="c8424-135">Nunca se llamará a un método de extensión con el mismo nombre y signatura que un método de interfaz o clase.</span><span class="sxs-lookup"><span data-stu-id="c8424-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="c8424-136">En tiempo de compilación, los métodos de extensión siempre tienen menos prioridad que los métodos de instancia definidos en el propio tipo.</span><span class="sxs-lookup"><span data-stu-id="c8424-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="c8424-137">En otras palabras, si un tipo tiene un método denominado `Process(int i)` y hay un método de extensión con la misma signatura, el compilador siempre se enlazará al método de instancia.</span><span class="sxs-lookup"><span data-stu-id="c8424-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="c8424-138">Cuando el compilador encuentra una invocación de método, primero busca una coincidencia en los métodos de instancia del tipo.</span><span class="sxs-lookup"><span data-stu-id="c8424-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="c8424-139">Si no la hay, buscará cualquier método de extensión definido para el tipo y se enlazará al primer método de extensión que encuentre.</span><span class="sxs-lookup"><span data-stu-id="c8424-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="c8424-140">En el ejemplo siguiente se muestra cómo determina el compilador a qué método de extensión o de instancia enlazarse.</span><span class="sxs-lookup"><span data-stu-id="c8424-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="c8424-141">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="c8424-141">Example</span></span>

<span data-ttu-id="c8424-142">En el ejemplo siguiente se muestran las reglas que el compilador de C# sigue para determinar si se va a enlazar una llamada a método a un método de instancia del tipo o a un método de extensión.</span><span class="sxs-lookup"><span data-stu-id="c8424-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="c8424-143">La clase estática `Extensions` contiene métodos de extensión definidos para cualquier tipo que implemente `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="c8424-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="c8424-144">Las clases `A`, `B` y `C` implementan la interfaz.</span><span class="sxs-lookup"><span data-stu-id="c8424-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="c8424-145">Nunca se llama al método de extensión `MethodB`, porque su nombre y signatura coinciden exactamente con los métodos ya implementados por las clases.</span><span class="sxs-lookup"><span data-stu-id="c8424-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="c8424-146">Si el compilador no encuentra un método de instancia con una signatura coincidente, se enlazará a un método de extensión coincidente, si existe.</span><span class="sxs-lookup"><span data-stu-id="c8424-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="c8424-147">Patrones de uso común</span><span class="sxs-lookup"><span data-stu-id="c8424-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="c8424-148">Funcionalidad de colección</span><span class="sxs-lookup"><span data-stu-id="c8424-148">Collection Functionality</span></span>

<span data-ttu-id="c8424-149">En el pasado, era habitual crear "Clases de colección" que implementaban la interfaz <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> para un tipo especificado e incluían una funcionalidad que actuaba en colecciones de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="c8424-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="c8424-150">Aunque no hay ningún problema con la creación de este tipo de objeto de colección, se puede lograr la misma funcionalidad mediante una extensión en <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c8424-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c8424-151">Las extensiones tienen la ventaja de permitir que se llame a la funcionalidad desde cualquier colección como <xref:System.Array?displayProperty=nameWithType> o <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> que implementa <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> en ese tipo.</span><span class="sxs-lookup"><span data-stu-id="c8424-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="c8424-152">Encontrará un ejemplo de esto mediante una matriz de Int32 [anteriormente en este artículo](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="c8424-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="c8424-153">Funcionalidad específica de la capa</span><span class="sxs-lookup"><span data-stu-id="c8424-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="c8424-154">Al usar Onion Architecture (Arquitectura cebolla) u otro diseño de la aplicación por niveles, es habitual tener un conjunto de entidades de dominio u objetos de transferencia de datos que se pueden usar para la comunicación entre los límites de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c8424-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="c8424-155">Por regla general, estos objetos no contienen ninguna funcionalidad o contienen únicamente una funcionalidad mínima que se aplica a todas las capas de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c8424-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="c8424-156">Los métodos de extensión se pueden usar para agregar una funcionalidad específica de cada capa de la aplicación sin cargar el objeto con métodos no necesarios o deseados en otras capas.</span><span class="sxs-lookup"><span data-stu-id="c8424-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="c8424-157">Ampliación de tipos predefinidos</span><span class="sxs-lookup"><span data-stu-id="c8424-157">Extending Predefined Types</span></span>

<span data-ttu-id="c8424-158">En lugar de crear objetos cuando es necesario crear una funcionalidad reutilizable, a menudo podemos ampliar un tipo existente como un tipo CLR o de .NET.</span><span class="sxs-lookup"><span data-stu-id="c8424-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="c8424-159">Como ejemplo, si no usamos métodos de extensión, podemos crear una clase `Engine` o `Query` para ejecutar una consulta en un servidor SQL Server al que se puede llamar desde varias ubicaciones en nuestro código.</span><span class="sxs-lookup"><span data-stu-id="c8424-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="c8424-160">Sin embargo, en su lugar, podemos ampliar la clase <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> mediante métodos de extensión para realizar esa consulta desde cualquier lugar en el que tengamos una conexión a un servidor SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c8424-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="c8424-161">Otros ejemplos podrían ser la adición de una funcionalidad común a la clase <xref:System.String?displayProperty=nameWithType>, la ampliación de las funcionalidades de procesamiento de datos de los objetos <xref:System.IO.File?displayProperty=nameWithType> y <xref:System.IO.Stream?displayProperty=nameWithType>, y los objetos <xref:System.Exception?displayProperty=nameWithType> para una funcionalidad de control de errores específica.</span><span class="sxs-lookup"><span data-stu-id="c8424-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="c8424-162">Solo su imaginación y sentido común limitan estos tipos de casos de uso.</span><span class="sxs-lookup"><span data-stu-id="c8424-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="c8424-163">La ampliación de tipos predefinidos puede ser difícil con los tipos `struct`, ya que se pasan en función del valor a los métodos.</span><span class="sxs-lookup"><span data-stu-id="c8424-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="c8424-164">Eso significa que los cambios en la estructura se realizan en una copia de la misma.</span><span class="sxs-lookup"><span data-stu-id="c8424-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="c8424-165">Esos cambios dejarán de verse una vez que se salga del método de extensión.</span><span class="sxs-lookup"><span data-stu-id="c8424-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="c8424-166">A partir de C# 7.2, puede agregar el modificador `ref` al primer argumento de un método de extensión.</span><span class="sxs-lookup"><span data-stu-id="c8424-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="c8424-167">La adición del modificador `ref` significa que el primer argumento se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="c8424-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="c8424-168">Esto le permite escribir métodos de extensión que cambian el estado de la estructura que se amplía.</span><span class="sxs-lookup"><span data-stu-id="c8424-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="c8424-169">Instrucciones generales</span><span class="sxs-lookup"><span data-stu-id="c8424-169">General Guidelines</span></span>

<span data-ttu-id="c8424-170">Aunque sigue considerándose preferible agregar la funcionalidad modificando un código del objeto o derivando un nuevo tipo siempre que sea razonable y posible hacerlo, los métodos de extensión se han convertido en una opción fundamental para crear una funcionalidad reutilizable en todo el ecosistema .NET.</span><span class="sxs-lookup"><span data-stu-id="c8424-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="c8424-171">Para esas ocasiones en las que no cuente con el control del origen original, si un objeto derivado es inadecuado o imposible, o la funcionalidad no se debe exponer más allá de su ámbito aplicable, los métodos de extensión son una opción excelente.</span><span class="sxs-lookup"><span data-stu-id="c8424-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="c8424-172">Para obtener más información sobre los tipos derivados, consulte [Herencia](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="c8424-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="c8424-173">Al usar un método de extensión para ampliar un tipo cuyo código fuente no está bajo su control, se corre el riesgo de que un cambio en la implementación del tipo interrumpa el método de extensión.</span><span class="sxs-lookup"><span data-stu-id="c8424-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="c8424-174">Si se implementan métodos de extensión para un tipo determinado, recuerde los puntos siguientes:</span><span class="sxs-lookup"><span data-stu-id="c8424-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="c8424-175">Nunca se llamará a un método de extensión si tiene la misma signatura que un método definido en el tipo.</span><span class="sxs-lookup"><span data-stu-id="c8424-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="c8424-176">Los métodos de extensión se incluyen en el ámbito en el nivel de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="c8424-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="c8424-177">Por ejemplo, si se tienen varias clases estáticas que contienen métodos de extensión en un único espacio de nombres denominado `Extensions`, la directiva `using Extensions;` los incluirá a todos en el ámbito.</span><span class="sxs-lookup"><span data-stu-id="c8424-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="c8424-178">Para una biblioteca de clases ya implementada, no deben usarse métodos de extensión para evitar incrementar el número de versión de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c8424-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="c8424-179">Si quiere agregar una funcionalidad significativa a una biblioteca de cuyo código fuente es propietario, siga las instrucciones de .NET estándar para el control de versiones de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c8424-179">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="c8424-180">Para obtener más información, vea [Versiones de los ensamblados](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="c8424-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="c8424-181">Vea también</span><span class="sxs-lookup"><span data-stu-id="c8424-181">See also</span></span>

- [<span data-ttu-id="c8424-182">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="c8424-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="c8424-183">Ejemplos de programación en paralelo (incluyen numerosos métodos de extensión de ejemplo)</span><span class="sxs-lookup"><span data-stu-id="c8424-183">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="c8424-184">Expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="c8424-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="c8424-185">Información general sobre operadores de consulta estándar</span><span class="sxs-lookup"><span data-stu-id="c8424-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- <span data-ttu-id="c8424-186">[Conversion rules for Instance parameters and their impact](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact) (Reglas de conversión para los parámetros de instancia y su impacto)</span><span class="sxs-lookup"><span data-stu-id="c8424-186">[Conversion rules for Instance parameters and their impact](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)</span></span>
- <span data-ttu-id="c8424-187">[Extension methods Interoperability between languages](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages) (Interoperabilidad de los métodos de extensión entre lenguajes)</span><span class="sxs-lookup"><span data-stu-id="c8424-187">[Extension methods Interoperability between languages](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)</span></span>
- <span data-ttu-id="c8424-188">[Extension methods and Curried Delegates](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates) (Métodos de extensión y delegados currificados)</span><span class="sxs-lookup"><span data-stu-id="c8424-188">[Extension methods and Curried Delegates](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)</span></span>
- <span data-ttu-id="c8424-189">[Extension method Binding and Error reporting](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting) (Enlazar métodos de extensión y notificación de errores)</span><span class="sxs-lookup"><span data-stu-id="c8424-189">[Extension method Binding and Error reporting](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)</span></span>
