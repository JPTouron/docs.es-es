---
title: 'Polimorfismo: Guía de programación de C#'
description: Obtenga información sobre el polimorfismo, un concepto clave en lenguajes de programación orientados a objetos como C#, que describe la relación entre las clases base y derivadas.
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 59b5f5d2d5a8f274845607aeca370c316670bd68
ms.sourcegitcommit: 40de8df14289e1e05b40d6e5c1daabd3c286d70c
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 07/22/2020
ms.locfileid: "86925454"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="ce39e-103">Polimorfismo (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="ce39e-103">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="ce39e-104">El polimorfismo suele considerarse el tercer pilar de la programación orientada a objetos, después de la encapsulación y la herencia.</span><span class="sxs-lookup"><span data-stu-id="ce39e-104">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="ce39e-105">Polimorfismo es una palabra griega que significa "con muchas formas" y tiene dos aspectos diferentes:</span><span class="sxs-lookup"><span data-stu-id="ce39e-105">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="ce39e-106">En tiempo de ejecución, los objetos de una clase derivada pueden ser tratados como objetos de una clase base en lugares como parámetros de métodos y colecciones o matrices.</span><span class="sxs-lookup"><span data-stu-id="ce39e-106">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="ce39e-107">Cuando se produce este polimorfismo, el tipo declarado del objeto ya no es idéntico a su tipo en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ce39e-107">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="ce39e-108">Las clases base pueden definir e implementar *métodos* [virtuales](../../language-reference/keywords/virtual.md), y las clases derivadas pueden [invalidarlos](../../language-reference/keywords/override.md), lo que significa que pueden proporcionar su propia definición e implementación.</span><span class="sxs-lookup"><span data-stu-id="ce39e-108">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="ce39e-109">En tiempo de ejecución, cuando el código de cliente llama al método, CLR busca el tipo en tiempo de ejecución del objeto e invoca esa invalidación del método virtual.</span><span class="sxs-lookup"><span data-stu-id="ce39e-109">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="ce39e-110">En el código fuente puede llamar a un método en una clase base y hacer que se ejecute una versión del método de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="ce39e-110">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="ce39e-111">Los métodos virtuales permiten trabajar con grupos de objetos relacionados de manera uniforme.</span><span class="sxs-lookup"><span data-stu-id="ce39e-111">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="ce39e-112">Por ejemplo, supongamos que tiene una aplicación de dibujo que permite a un usuario crear varios tipos de formas en una superficie de dibujo.</span><span class="sxs-lookup"><span data-stu-id="ce39e-112">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="ce39e-113">En tiempo de compilación, no sabe qué tipos específicos de formas creará el usuario.</span><span class="sxs-lookup"><span data-stu-id="ce39e-113">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="ce39e-114">Sin embargo, la aplicación tiene que realizar el seguimiento de los distintos tipos de formas que se crean, y tiene que actualizarlos en respuesta a las acciones del mouse del usuario.</span><span class="sxs-lookup"><span data-stu-id="ce39e-114">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="ce39e-115">Para solucionar este problema en dos pasos básicos, puede usar el polimorfismo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-115">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="ce39e-116">Crear una jerarquía de clases en la que cada clase de forma específica deriva de una clase base común.</span><span class="sxs-lookup"><span data-stu-id="ce39e-116">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="ce39e-117">Usar un método virtual para invocar el método apropiado en una clase derivada mediante una sola llamada al método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="ce39e-117">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="ce39e-118">Primero, cree una clase base llamada `Shape` y clases derivadas como `Rectangle`, `Circle` y `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="ce39e-118">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="ce39e-119">Dé a la clase `Shape` un método virtual llamado `Draw` e invalídelo en cada clase derivada para dibujar la forma determinada que la clase representa.</span><span class="sxs-lookup"><span data-stu-id="ce39e-119">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="ce39e-120">Cree un objeto `List<Shape>` y agréguele una instancia de `Circle`, `Triangle` y `Rectangle`.</span><span class="sxs-lookup"><span data-stu-id="ce39e-120">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="ce39e-121">Para actualizar la superficie de dibujo, use un bucle [foreach](../../language-reference/keywords/foreach-in.md) para iterar por la lista y llamar al método `Draw` en cada objeto `Shape` de la lista.</span><span class="sxs-lookup"><span data-stu-id="ce39e-121">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="ce39e-122">Aunque cada objeto de la lista tenga un tipo declarado de `Shape`, se invocará el tipo en tiempo de ejecución (la versión invalidada del método en cada clase derivada).</span><span class="sxs-lookup"><span data-stu-id="ce39e-122">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="ce39e-123">En C#, cada tipo es polimórfico porque todos los tipos, incluidos los definidos por el usuario, heredan de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="ce39e-123">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="ce39e-124">Introducción al polimorfismo</span><span class="sxs-lookup"><span data-stu-id="ce39e-124">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="ce39e-125">Miembros virtuales</span><span class="sxs-lookup"><span data-stu-id="ce39e-125">Virtual members</span></span>

<span data-ttu-id="ce39e-126">Cuando una clase derivada hereda de una clase base, obtiene todos los métodos, campos, propiedades y eventos de la clase base.</span><span class="sxs-lookup"><span data-stu-id="ce39e-126">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="ce39e-127">El diseñador de la clase derivada tiene diferentes opciones para el comportamiento de los métodos virtuales:</span><span class="sxs-lookup"><span data-stu-id="ce39e-127">The designer of the derived class has different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="ce39e-128">La clase derivada puede invalidar los miembros virtuales de la clase base, y definir un comportamiento nuevo.</span><span class="sxs-lookup"><span data-stu-id="ce39e-128">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="ce39e-129">La clase derivada hereda el método de clase base más cercano sin invalidarlo, para conservar el comportamiento existente, pero permite que más clases derivadas invaliden el método.</span><span class="sxs-lookup"><span data-stu-id="ce39e-129">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="ce39e-130">La clase derivada puede definir una nueva implementación no virtual de esos miembros que oculte las implementaciones de la clase base.</span><span class="sxs-lookup"><span data-stu-id="ce39e-130">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="ce39e-131">Una clase derivada puede invalidar un miembro de la clase base si este se declara como [virtual](../../language-reference/keywords/virtual.md) o [abstracto](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="ce39e-131">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="ce39e-132">El miembro derivado debe usar la palabra clave [override](../../language-reference/keywords/override.md) para indicar explícitamente que el propósito del método es participar en una invocación virtual.</span><span class="sxs-lookup"><span data-stu-id="ce39e-132">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="ce39e-133">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-133">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="ce39e-134">Los campos no pueden ser virtuales; solo pueden serlo los métodos, propiedades, eventos e indizadores.</span><span class="sxs-lookup"><span data-stu-id="ce39e-134">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="ce39e-135">Cuando una clase derivada invalida un miembro virtual, se llama a ese miembro aunque se acceda a una instancia de esa clase como una instancia de la clase base.</span><span class="sxs-lookup"><span data-stu-id="ce39e-135">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="ce39e-136">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-136">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#SnippetTestVirtualMethods)]

<span data-ttu-id="ce39e-137">Los métodos y propiedades virtuales permiten a las clases derivadas extender una clase base sin necesidad de usar la implementación de clase base de un método.</span><span class="sxs-lookup"><span data-stu-id="ce39e-137">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="ce39e-138">Para obtener más información, consulte [Control de versiones con las palabras clave Override y New](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="ce39e-138">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="ce39e-139">Una interfaz proporciona otra manera de definir un método o conjunto de métodos cuya implementación se deja a las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="ce39e-139">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="ce39e-140">Para más información, vea [Interfaces](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="ce39e-140">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="ce39e-141">Ocultación de miembros de clase base con miembros nuevos</span><span class="sxs-lookup"><span data-stu-id="ce39e-141">Hide base class members with new members</span></span>

<span data-ttu-id="ce39e-142">Si quiere que la clase derivada tenga un miembro con el mismo nombre que el de un miembro de una clase base, puede usar la palabra clave [new](../../language-reference/keywords/new-modifier.md) para ocultar el miembro de clase base.</span><span class="sxs-lookup"><span data-stu-id="ce39e-142">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="ce39e-143">La palabra clave `new` se coloca antes que el tipo devuelto del miembro de la clase que se está reemplazando.</span><span class="sxs-lookup"><span data-stu-id="ce39e-143">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="ce39e-144">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-144">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="ce39e-145">Se puede acceder a los miembros de la clase base ocultos desde el código de cliente si se convierte la instancia de la clase derivada en una instancia de la clase base.</span><span class="sxs-lookup"><span data-stu-id="ce39e-145">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="ce39e-146">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-146">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="ce39e-147">Evasión de que las clases derivadas invaliden los miembros virtuales</span><span class="sxs-lookup"><span data-stu-id="ce39e-147">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="ce39e-148">Los miembros virtuales siguen siendo virtuales con independencia de cuántas clases se hayan declarado entre el miembro virtual y la clase que originalmente lo haya declarado.</span><span class="sxs-lookup"><span data-stu-id="ce39e-148">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="ce39e-149">Si la clase `A` declara un miembro virtual y la clase `B` deriva de `A`, y la clase `C` de `B`, la clase `C` hereda el miembro virtual y puede invalidarlo, independientemente de que la clase `B` haya declarado una invalidación para ese miembro.</span><span class="sxs-lookup"><span data-stu-id="ce39e-149">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="ce39e-150">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-150">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="ce39e-151">Una clase derivada puede detener la herencia virtual al declarar una invalidación como [sealed](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="ce39e-151">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="ce39e-152">Para detener la herencia, es necesario colocar la palabra clave `sealed` antes de la palabra clave `override` en la declaración del miembro de la clase.</span><span class="sxs-lookup"><span data-stu-id="ce39e-152">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="ce39e-153">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-153">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="ce39e-154">En el ejemplo anterior, el método `DoWork` ya no es virtual para ninguna clase que se derive de `C`.</span><span class="sxs-lookup"><span data-stu-id="ce39e-154">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="ce39e-155">Sigue siendo virtual para las instancias de `C`, aunque se conviertan al tipo `B` o al tipo `A`.</span><span class="sxs-lookup"><span data-stu-id="ce39e-155">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="ce39e-156">Los métodos sellados se pueden reemplazar por clases derivadas mediante la palabra clave `new`, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="ce39e-156">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="ce39e-157">En este caso, si se llama a `DoWork` en `D` con una variable de tipo `D`, se llama a la nueva instancia de `DoWork`.</span><span class="sxs-lookup"><span data-stu-id="ce39e-157">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="ce39e-158">Si se usa una variable de tipo `C`, `B` o `A` para acceder a una instancia de `D`, la llamada a `DoWork` seguirá las reglas de herencia virtual y enrutará esas llamadas a la implementación de `DoWork` en la clase `C`.</span><span class="sxs-lookup"><span data-stu-id="ce39e-158">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="ce39e-159">Acceso a miembros virtuales de clases base desde clases derivadas</span><span class="sxs-lookup"><span data-stu-id="ce39e-159">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="ce39e-160">Una clase derivada que ha reemplazado o invalidado un método o propiedad puede seguir accediendo al método o propiedad en la clase base usando la siguiente palabra clave `base`.</span><span class="sxs-lookup"><span data-stu-id="ce39e-160">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="ce39e-161">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ce39e-161">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="ce39e-162">Para obtener más información, vea [base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="ce39e-162">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="ce39e-163">Se recomienda que las máquinas virtuales usen `base` para llamar a la implementación de la clase base de ese miembro en su propia implementación.</span><span class="sxs-lookup"><span data-stu-id="ce39e-163">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="ce39e-164">Dejar que se produzca el comportamiento de la clase base permite a la clase derivada concentrarse en implementar el comportamiento específico de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="ce39e-164">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="ce39e-165">Si no se llama a la implementación de la clase base, depende de la clase derivada hacer que su comportamiento sea compatible con el de la clase base.</span><span class="sxs-lookup"><span data-stu-id="ce39e-165">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="ce39e-166">En esta sección</span><span class="sxs-lookup"><span data-stu-id="ce39e-166">In this section</span></span>

- [<span data-ttu-id="ce39e-167">Control de versiones con las palabras clave Override y New</span><span class="sxs-lookup"><span data-stu-id="ce39e-167">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="ce39e-168">Saber cuándo utilizar las palabras clave Override y New</span><span class="sxs-lookup"><span data-stu-id="ce39e-168">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="ce39e-169">Invalidación del método ToString</span><span class="sxs-lookup"><span data-stu-id="ce39e-169">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="ce39e-170">Vea también</span><span class="sxs-lookup"><span data-stu-id="ce39e-170">See also</span></span>

- [<span data-ttu-id="ce39e-171">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="ce39e-171">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="ce39e-172">Herencia</span><span class="sxs-lookup"><span data-stu-id="ce39e-172">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="ce39e-173">Clases y miembros de clase abstractos y sellados</span><span class="sxs-lookup"><span data-stu-id="ce39e-173">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="ce39e-174">Métodos</span><span class="sxs-lookup"><span data-stu-id="ce39e-174">Methods</span></span>](./methods.md)
- [<span data-ttu-id="ce39e-175">Eventos</span><span class="sxs-lookup"><span data-stu-id="ce39e-175">Events</span></span>](../events/index.md)
- [<span data-ttu-id="ce39e-176">Propiedades</span><span class="sxs-lookup"><span data-stu-id="ce39e-176">Properties</span></span>](./properties.md)
- [<span data-ttu-id="ce39e-177">Indizadores</span><span class="sxs-lookup"><span data-stu-id="ce39e-177">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="ce39e-178">Tipos</span><span class="sxs-lookup"><span data-stu-id="ce39e-178">Types</span></span>](../types/index.md)
