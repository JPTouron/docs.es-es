---
title: 'Tipos anónimos: Guía de programación de C#'
description: Los tipos anónimos de C# encapsulan un conjunto de propiedades de solo lectura en un objeto sin necesidad de definir un tipo de forma explícita. El compilador genera un nombre.
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: f60c1ea4f3f029ec3b81a4197a711523ec372df9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186164"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="01483-104">Tipos anónimos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="01483-104">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="01483-105">Los tipos anónimos son una manera cómoda de encapsular un conjunto de propiedades de solo lectura en un único objeto sin tener que definir primero un tipo explícitamente.</span><span class="sxs-lookup"><span data-stu-id="01483-105">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="01483-106">El compilador genera el nombre del tipo y no está disponible en el nivel de código fuente.</span><span class="sxs-lookup"><span data-stu-id="01483-106">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="01483-107">El compilador deduce el tipo de cada propiedad.</span><span class="sxs-lookup"><span data-stu-id="01483-107">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="01483-108">Para crear tipos anónimos, use el operador [new](../../language-reference/operators/new-operator.md) con un inicializador de objeto.</span><span class="sxs-lookup"><span data-stu-id="01483-108">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="01483-109">Para obtener más información sobre los inicializadores de objeto, vea [Inicializadores de objeto y colección (Guía de programación de C#)](./object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="01483-109">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="01483-110">En el ejemplo siguiente se muestra un tipo anónimo que se inicializa con dos propiedades llamadas `Amount` y `Message`.</span><span class="sxs-lookup"><span data-stu-id="01483-110">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="01483-111">Los tipos anónimos suelen usarse en la cláusula [select](../../language-reference/keywords/select-clause.md) de una expresión de consulta para devolver un subconjunto de las propiedades de cada objeto en la secuencia de origen.</span><span class="sxs-lookup"><span data-stu-id="01483-111">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="01483-112">Para más información sobre las consultas, vea [LINQ en C#](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="01483-112">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="01483-113">Los tipos anónimos contienen una o varias propiedades públicas de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="01483-113">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="01483-114">No es válido ningún otro tipo de miembros de clase, como métodos o eventos.</span><span class="sxs-lookup"><span data-stu-id="01483-114">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="01483-115">La expresión que se usa para inicializar una propiedad no puede ser `null`, una función anónima o un tipo de puntero.</span><span class="sxs-lookup"><span data-stu-id="01483-115">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="01483-116">El escenario más habitual es inicializar un tipo anónimo con propiedades de otro tipo.</span><span class="sxs-lookup"><span data-stu-id="01483-116">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="01483-117">En el siguiente ejemplo, se da por hecho que existe una clase con el nombre `Product`.</span><span class="sxs-lookup"><span data-stu-id="01483-117">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="01483-118">La clase `Product` incluye las propiedades `Color` y `Price`, junto con otras propiedades que no son de su interés.</span><span class="sxs-lookup"><span data-stu-id="01483-118">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="01483-119">La variable `products` es una colección de objetos `Product`.</span><span class="sxs-lookup"><span data-stu-id="01483-119">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="01483-120">La declaración de tipo anónimo comienza con la palabra clave `new`.</span><span class="sxs-lookup"><span data-stu-id="01483-120">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="01483-121">La declaración inicializa un nuevo tipo que solo usa dos propiedades de `Product`.</span><span class="sxs-lookup"><span data-stu-id="01483-121">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="01483-122">Esto hace que la consulta devuelva una cantidad de datos menor.</span><span class="sxs-lookup"><span data-stu-id="01483-122">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="01483-123">Si no especifica los nombres de miembro en el tipo anónimo, el compilador da a los miembros de tipo anónimo el mismo nombre que la propiedad que se usa para inicializarlos.</span><span class="sxs-lookup"><span data-stu-id="01483-123">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="01483-124">Debe proporcionar un nombre para una propiedad que se está inicializando con una expresión, como se muestra en el ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="01483-124">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="01483-125">En el siguiente ejemplo, los nombres de las propiedades del tipo anónimo son `Color` y `Price`.</span><span class="sxs-lookup"><span data-stu-id="01483-125">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="01483-126">Normalmente, cuando se usa un tipo anónimo para inicializar una variable, la variable se declara como variable local con tipo implícito mediante [var](../../language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="01483-126">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="01483-127">El nombre del tipo no se puede especificar en la declaración de la variable porque solo el compilador tiene acceso al nombre subyacente del tipo anónimo.</span><span class="sxs-lookup"><span data-stu-id="01483-127">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="01483-128">Para obtener más información sobre `var`, vea [Variables locales con asignación implícita de tipos](./implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="01483-128">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="01483-129">Puede crear una matriz de elementos con tipo anónimo combinando una variable local con tipo implícito y una matriz con tipo implícito, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="01483-129">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="01483-130">Comentarios</span><span class="sxs-lookup"><span data-stu-id="01483-130">Remarks</span></span>  

 <span data-ttu-id="01483-131">Los tipos anónimos son tipos [class](../../language-reference/keywords/class.md) que derivan directamente de [object](../../language-reference/builtin-types/reference-types.md) y que no se pueden convertir a ningún tipo excepto [object](../../language-reference/builtin-types/reference-types.md).</span><span class="sxs-lookup"><span data-stu-id="01483-131">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="01483-132">El compilador proporciona un nombre para cada tipo anónimo, aunque la aplicación no pueda acceder a él.</span><span class="sxs-lookup"><span data-stu-id="01483-132">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="01483-133">Desde el punto de vista de Common Language Runtime, un tipo anónimo no es diferente de otros tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="01483-133">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="01483-134">Si dos o más inicializadores de objeto anónimo en un ensamblado especifican una secuencia de propiedades que están en el mismo orden y que tienen los mismos nombres y tipos, el compilador trata el objeto como instancias del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="01483-134">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="01483-135">Comparten la misma información de tipo generada por el compilador.</span><span class="sxs-lookup"><span data-stu-id="01483-135">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="01483-136">No se puede declarar que un campo, una propiedad, un evento o el tipo de valor devuelto de un método tengan un tipo anónimo.</span><span class="sxs-lookup"><span data-stu-id="01483-136">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="01483-137">De forma similar, no se puede declarar que un parámetro formal de un método, propiedad, constructor o indizador tenga un tipo anónimo.</span><span class="sxs-lookup"><span data-stu-id="01483-137">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="01483-138">Para pasar un tipo anónimo, o una colección que contiene tipos anónimos, como un argumento a un método, puede declarar el parámetro como objeto de tipo.</span><span class="sxs-lookup"><span data-stu-id="01483-138">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="01483-139">Sin embargo, al hacerlo se invalida el propósito del tipado fuerte.</span><span class="sxs-lookup"><span data-stu-id="01483-139">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="01483-140">Si tiene que almacenar resultados de consulta o pasarlos fuera del límite del método, considere la posibilidad de usar un struct o una clase con nombre normal en lugar de un tipo anónimo.</span><span class="sxs-lookup"><span data-stu-id="01483-140">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="01483-141">Como los métodos <xref:System.Object.Equals%2A> y <xref:System.Object.GetHashCode%2A> de tipos anónimos se definen en términos de los métodos `Equals` y `GetHashCode` de las propiedades, dos instancias del mismo tipo anónimo son iguales solo si todas sus propiedades son iguales.</span><span class="sxs-lookup"><span data-stu-id="01483-141">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="01483-142">Vea también</span><span class="sxs-lookup"><span data-stu-id="01483-142">See also</span></span>

- [<span data-ttu-id="01483-143">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="01483-143">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="01483-144">Inicializadores de objeto y colección</span><span class="sxs-lookup"><span data-stu-id="01483-144">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="01483-145">Introducción a LINQ en C#</span><span class="sxs-lookup"><span data-stu-id="01483-145">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="01483-146">LINQ en C#</span><span class="sxs-lookup"><span data-stu-id="01483-146">LINQ in C#</span></span>](../../linq/index.md)
