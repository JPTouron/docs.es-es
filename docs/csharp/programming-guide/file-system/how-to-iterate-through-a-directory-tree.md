---
title: 'Procedimiento Recorrer en iteración un árbol de directorio: Guía de programación de C#'
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: 24a6225527becb0b896017616e2661ab8247c74c
ms.sourcegitcommit: a241301495a84cc8c64fe972330d16edd619868b
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/01/2020
ms.locfileid: "84241609"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="6c0aa-102">Procedimiento Recorrer en iteración un árbol de directorio (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="6c0aa-102">How to iterate through a directory tree (C# Programming Guide)</span></span>
<span data-ttu-id="6c0aa-103">La frase "recorrer en iteración un árbol de directorios" significa obtener acceso a cada uno de los archivos de todos los subdirectorios anidados bajo una carpeta raíz especificada hasta un nivel de profundidad cualquiera.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="6c0aa-104">No es necesario abrir cada archivo.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="6c0aa-105">Simplemente puede recuperar el nombre del archivo o subdirectorio como un `string`, o puede recuperar información adicional en el formato de un objeto <xref:System.IO.FileInfo?displayProperty=nameWithType> o <xref:System.IO.DirectoryInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6c0aa-106">En Windows, los términos "directorio" y "carpeta" se usan indistintamente.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="6c0aa-107">La mayor parte de la documentación y del texto de la interfaz de usuario usa el término "carpeta", pero las bibliotecas de clases de .NET usan el término "directorio".</span><span class="sxs-lookup"><span data-stu-id="6c0aa-107">Most documentation and user interface text uses the term "folder," but .NET class libraries use the term "directory."</span></span>  
  
 <span data-ttu-id="6c0aa-108">En el caso más simple, en el que sabe con seguridad que tiene permisos de acceso para todos los directorios incluidos en una raíz especificada, puede usar la marca `System.IO.SearchOption.AllDirectories`.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="6c0aa-109">Esta marca devuelve todos los subdirectorios anidados que coinciden con el patrón especificado.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="6c0aa-110">En el ejemplo siguiente se muestra cómo usar esta marca.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="6c0aa-111">El punto débil de este enfoque es que si uno de los subdirectorios incluidos en la raíz especificada produce una excepción <xref:System.IO.DirectoryNotFoundException> o <xref:System.UnauthorizedAccessException>, se produce un error en todo el método y no devuelve ningún directorio.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="6c0aa-112">Sucede lo mismo cuando usa el método <xref:System.IO.DirectoryInfo.GetFiles%2A>.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="6c0aa-113">Si tiene que controlar estas excepciones en subcarpetas específicas, debe recorrer manualmente el árbol de directorios, como se muestra en los ejemplos siguientes.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="6c0aa-114">Al recorrer manualmente un árbol de directorios, puede controlar primero los subdirectorios (*recorrido en preorden*) o los archivos (*recorrido en postorden*).</span><span class="sxs-lookup"><span data-stu-id="6c0aa-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="6c0aa-115">Al realizar un recorrido en preorden, se recorre todo el árbol bajo la carpeta actual antes de recorrer en iteración los archivos que están directamente en esa carpeta.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="6c0aa-116">Los ejemplos que se proporcionan más adelante en este documento realizan un recorrido en postorden, pero puede modificarlos fácilmente para que realicen un recorrido en preorden.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="6c0aa-117">Otra opción consiste en usar la recursividad o un recorrido basado en la pila.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="6c0aa-118">Los ejemplos que se proporcionan más adelante en este documento muestran ambos enfoques.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="6c0aa-119">Si tiene que realizar diversas operaciones en los archivos y las carpetas, puede dividir estos ejemplos en partes mediante la refactorización de la operación en funciones separadas que se puedan invocar usando un solo delegado.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6c0aa-120">Los sistemas de archivos NTFS pueden contener *puntos de reanálisis* en forma de *puntos de unión*, *vínculos simbólicos* y *vínculos físicos*.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="6c0aa-121">Los métodos de .NET Framework como <xref:System.IO.DirectoryInfo.GetFiles%2A> y <xref:System.IO.DirectoryInfo.GetDirectories%2A> no devolverán ningún subdirectorio en un punto de reanálisis.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-121">.NET methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="6c0aa-122">Este comportamiento protege frente al riesgo de provocar un bucle infinito cuando dos puntos de reanálisis se hacen referencia entre sí.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="6c0aa-123">En general, debería ser muy cuidadoso al tratar con puntos de reanálisis para asegurarse de no modificar o eliminar archivos involuntariamente.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="6c0aa-124">Si quiere obtener un control preciso de los puntos de reanálisis, use la invocación de plataforma o código nativo para llamar directamente a los métodos de sistema de archivos Win32 adecuados.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="6c0aa-125">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="6c0aa-125">Example</span></span>  
 <span data-ttu-id="6c0aa-126">En el ejemplo siguiente se muestra cómo recorrer un árbol de directorios mediante recursividad.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="6c0aa-127">El enfoque recursivo resulta elegante, pero puede producir una excepción de desbordamiento de la pila si el árbol de directorios es grande y cuenta con muchos elementos anidados.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="6c0aa-128">Las excepciones concretas que se controlan y las acciones determinadas que se realizan en cada archivo o carpeta se proporcionan simplemente como ejemplos.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="6c0aa-129">Debe modificar este código para que se ajuste a sus requisitos concretos.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="6c0aa-130">Para obtener más información, vea los comentarios del código.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  
  
## <a name="example"></a><span data-ttu-id="6c0aa-131">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="6c0aa-131">Example</span></span>  
 <span data-ttu-id="6c0aa-132">En el ejemplo siguiente se muestra cómo recorrer en iteración los archivos y las carpetas de un árbol de directorios sin usar la recursividad.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="6c0aa-133">Esta técnica usa el tipo de colección genérica <xref:System.Collections.Generic.Stack%601>, que es una pila de tipo LIFO (último en entrar, primero en salir).</span><span class="sxs-lookup"><span data-stu-id="6c0aa-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="6c0aa-134">Las excepciones concretas que se controlan y las acciones determinadas que se realizan en cada archivo o carpeta se proporcionan simplemente como ejemplos.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="6c0aa-135">Debe modificar este código para que se ajuste a sus requisitos concretos.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="6c0aa-136">Para obtener más información, vea los comentarios del código.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  
  
 <span data-ttu-id="6c0aa-137">Generalmente se tarda mucho tiempo en comprobar cada carpeta para determinar si su aplicación tiene permiso para abrirla.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="6c0aa-138">Por consiguiente, el ejemplo de código incluye esa parte de la operación en un bloque `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="6c0aa-139">Puede modificar el bloque `catch` de manera que, cuando se le deniegue el acceso a una carpeta, intente elevar sus permisos y obtener acceso a esta de nuevo.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="6c0aa-140">Como norma, detecte solamente las excepciones que puede controlar sin dejar la aplicación en un estado desconocido.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="6c0aa-141">Si debe almacenar el contenido de un árbol de directorios, ya sea en memoria o en el disco, la mejor opción es almacenar solamente la propiedad <xref:System.IO.FileSystemInfo.FullName%2A> (de tipo `string`) para cada archivo.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="6c0aa-142">Después, puede usar esta cadena para crear un nuevo objeto <xref:System.IO.FileInfo> o <xref:System.IO.DirectoryInfo>, según sea necesario, o para abrir cualquier archivo que requiera un procesamiento adicional.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="6c0aa-143">Programación sólida</span><span class="sxs-lookup"><span data-stu-id="6c0aa-143">Robust Programming</span></span>  
 <span data-ttu-id="6c0aa-144">Un código eficaz de iteración de archivos debe tener en cuenta las numerosas dificultades del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="6c0aa-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="6c0aa-145">Para más información sobre el sistema de archivos de Windows, vea [NTFS overview](/windows-server/storage/file-server/ntfs-overview) (Introducción a NTFS).</span><span class="sxs-lookup"><span data-stu-id="6c0aa-145">For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6c0aa-146">Vea también</span><span class="sxs-lookup"><span data-stu-id="6c0aa-146">See also</span></span>

- <xref:System.IO>
- [<span data-ttu-id="6c0aa-147">LINQ y directorios de archivos</span><span class="sxs-lookup"><span data-stu-id="6c0aa-147">LINQ and File Directories</span></span>](../concepts/linq/linq-and-file-directories.md)
- [<span data-ttu-id="6c0aa-148">Registro y sistema de archivos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="6c0aa-148">File System and the Registry (C# Programming Guide)</span></span>](./index.md)
