---
title: 'Variables y tipos de C#: un paseo por el lenguaje C#'
description: Obtenga información sobre cómo definir tipos y declarar variables de C#
ms.date: 04/24/2020
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: a14291d1eec4d090b0275875326c5a580e5abe9d
ms.sourcegitcommit: cb27c01a8b0b4630148374638aff4e2221f90b22
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 07/09/2020
ms.locfileid: "86174132"
---
# <a name="types-and-variables"></a><span data-ttu-id="cbb1d-103">Tipos y variables</span><span class="sxs-lookup"><span data-stu-id="cbb1d-103">Types and variables</span></span>

<span data-ttu-id="cbb1d-104">Hay dos clases de tipos en C#: *tipos de valor* y *tipos de referencia*.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="cbb1d-105">Las variables de tipos de valor contienen directamente los datos, mientras que las variables de los tipos de referencia almacenan referencias a los datos, lo que se conoce como objetos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="cbb1d-106">Con los tipos de referencia, es posible que dos variables hagan referencia al mismo objeto y que, por tanto, las operaciones en una variable afecten al objeto al que hace referencia la otra.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-106">With reference types, it's possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="cbb1d-107">Con los tipos de valor, cada variable tiene su propia copia de los datos y no es posible que las operaciones en una variable afecten a la otra (excepto para las variables de parámetro `ref` y `out`).</span><span class="sxs-lookup"><span data-stu-id="cbb1d-107">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="cbb1d-108">Los tipos de valor de C# se dividen en *tipos simples*, *tipos de enumeración*, *tipos de estructura* y *tipos de valor que aceptan valores NULL*.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-108">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="cbb1d-109">Los tipos de referencia de C# se dividen en *tipos de clase*, *tipos de interfaz*, *tipos de matriz* y *tipos delegados*.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-109">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="cbb1d-110">En el esquema siguiente se ofrece información general del sistema de tipos de C#.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-110">The following outline provides an overview of C#'s type system.</span></span>

- <span data-ttu-id="cbb1d-111">[Tipos de valor][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="cbb1d-112">[Tipos simples][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-112">[Simple types][SimpleTypes]</span></span>
    - <span data-ttu-id="cbb1d-113">Entero con signo: `sbyte`, `short`, `int`,`long`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="cbb1d-114">Entero sin signo: `byte`, `ushort`, `uint`,`ulong`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="cbb1d-115">Caracteres Unicode: `char`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-115">Unicode characters: `char`</span></span>
    - <span data-ttu-id="cbb1d-116">Punto flotante binario IEEE: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-116">IEEE binary floating-point: `float`, `double`</span></span>
    - <span data-ttu-id="cbb1d-117">Punto flotante decimal de alta precisión: `decimal`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-117">High-precision decimal floating-point: `decimal`</span></span>
    - <span data-ttu-id="cbb1d-118">Booleano: `bool`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="cbb1d-119">[Tipos de enumeración][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-119">[Enum types][EnumTypes]</span></span>
    - <span data-ttu-id="cbb1d-120">Tipos definidos por el usuario con el formato `enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="cbb1d-121">[Tipos de estructura][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-121">[Struct types][StructTypes]</span></span>
    - <span data-ttu-id="cbb1d-122">Tipos definidos por el usuario con el formato `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="cbb1d-123">[Tipos de valores que aceptan valores NULL][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-123">[Nullable value types][NullableTypes]</span></span>
    - <span data-ttu-id="cbb1d-124">Extensiones de todos los demás tipos de valor con un valor `null`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-124">Extensions of all other value types with a `null` value</span></span>
  - <span data-ttu-id="cbb1d-125">[Tipos de valor de tupla][TupleTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-125">[Tuple value types][TupleTypes]</span></span>
    - <span data-ttu-id="cbb1d-126">Tipos definidos por el usuario con el formato `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-126">User-defined types of the form `(T1, T2, ...)`</span></span>
- <span data-ttu-id="cbb1d-127">[Tipos de referencia][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-127">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="cbb1d-128">[Tipos de clase][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-128">[Class types][ClassTypes]</span></span>
    - <span data-ttu-id="cbb1d-129">Clase base definitiva de todos los demás tipos: `object`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-129">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="cbb1d-130">Cadenas Unicode: `string`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-130">Unicode strings: `string`</span></span>
    - <span data-ttu-id="cbb1d-131">Tipos definidos por el usuario con el formato `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-131">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="cbb1d-132">[Tipos de interfaz][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-132">[Interface types][InterfaceTypes]</span></span>
    - <span data-ttu-id="cbb1d-133">Tipos definidos por el usuario con el formato `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-133">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="cbb1d-134">[Tipos de matriz][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-134">[Array types][ArrayTypes]</span></span>
    - <span data-ttu-id="cbb1d-135">Unidimensional y multidimensional; por ejemplo, `int[]` y `int[,]`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-135">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="cbb1d-136">[Tipos delegados][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="cbb1d-136">[Delegate types][DelegateTypes]</span></span>
    - <span data-ttu-id="cbb1d-137">Tipos definidos por el usuario con el formato `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="cbb1d-137">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/builtin-types/value-types.md
[SimpleTypes]: ../language-reference/builtin-types/value-types.md#built-in-value-types
[EnumTypes]: ../language-reference/builtin-types/enum.md
[StructTypes]: ../language-reference/builtin-types/struct.md
[NullableTypes]: ../language-reference/builtin-types/nullable-value-types.md
[TupleTypes]: ../language-reference/builtin-types/value-tuples.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="cbb1d-138">Para obtener más información sobre los tipos numéricos, vea [Tipos enteros](../language-reference/builtin-types/integral-numeric-types.md) y [Tabla de tipos de punto flotante](../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="cbb1d-138">For more information about numeric types, see [Integral types](../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point types table](../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="cbb1d-139">El tipo `bool` de C# se utiliza para representar valores booleanos, valores que son `true` o `false`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-139">C#'s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="cbb1d-140">El procesamiento de caracteres y cadenas en C# utiliza la codificación Unicode.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="cbb1d-141">El tipo `char` representa una unidad de código UTF-16 y el tipo `string` representa una secuencia de unidades de código UTF-16.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="cbb1d-142">Los programas de C# utilizan *declaraciones de tipos* para crear nuevos tipos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-142">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="cbb1d-143">Una declaración de tipos especifica el nombre y los miembros del nuevo tipo.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-143">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="cbb1d-144">Cinco de las categorías de tipos de C# las define el usuario: tipos de clase, tipos de estructura, tipos de interfaz, tipos de enumeración y tipos delegados.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-144">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="cbb1d-145">A tipo `class` define una estructura de datos que contiene miembros de datos (campos) y miembros de función (métodos, propiedades y otros).</span><span class="sxs-lookup"><span data-stu-id="cbb1d-145">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="cbb1d-146">Los tipos de clase admiten herencia única y polimorfismo, mecanismos por los que las clases derivadas pueden extender y especializar clases base.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-146">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="cbb1d-147">Un tipo `struct` es similar a un tipo de clase, por el hecho de que representa una estructura con miembros de datos y miembros de función.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-147">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="cbb1d-148">Pero a diferencia de las clases, las estructuras son tipos de valor y no suelen requerir la asignación del montón.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-148">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="cbb1d-149">Los tipos de estructura no admiten la herencia especificada por el usuario y todos se heredan implícitamente del tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-149">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="cbb1d-150">Un tipo `interface` define un contrato como un conjunto con nombre de miembros de función públicos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-150">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="cbb1d-151">Un valor `class` o `struct` que implementa `interface` debe proporcionar implementaciones de miembros de función de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-151">A `class` or `struct` that implements an `interface` must provide implementations of the interface's function members.</span></span> <span data-ttu-id="cbb1d-152">Un `interface` puede heredar de varias interfaces base, y un `class` o `struct` pueden implementar varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-152">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="cbb1d-153">Un tipo `delegate` representa las referencias a métodos con una lista de parámetros determinada y un tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-153">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="cbb1d-154">Los delegados permiten tratar métodos como entidades que se puedan asignar a variables y se puedan pasar como parámetros.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-154">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="cbb1d-155">Los delegados son análogos a los tipos de función proporcionados por los lenguajes funcionales.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-155">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="cbb1d-156">También son similares al concepto de punteros de función de otros lenguajes.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-156">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="cbb1d-157">A diferencia de los punteros de función, los delegados están orientados a objetos y tienen seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-157">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="cbb1d-158">Los tipos `class`, `struct`, `interface` y `delegate` admiten parámetros genéricos, mediante los que se pueden parametrizar con otros tipos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-158">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="cbb1d-159">Un tipo `enum` es un tipo distinto con constantes con nombre.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-159">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="cbb1d-160">Cada tipo `enum` tiene un tipo subyacente, que debe ser uno de los ocho tipos enteros.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-160">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="cbb1d-161">El conjunto de valores de un tipo `enum` es igual que el conjunto de valores del tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-161">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="cbb1d-162">C# admite matrices unidimensionales y multidimensionales de cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-162">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="cbb1d-163">A diferencia de los tipos enumerados antes, no es necesario declarar los tipos de matriz antes de usarlos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-163">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="cbb1d-164">En su lugar, los tipos de matriz se crean mediante un nombre de tipo entre corchetes.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-164">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="cbb1d-165">Por ejemplo, `int[]` es una matriz unidimensional de `int`, `int[,]` es una matriz bidimensional de `int` y `int[][]` es una matriz unidimensional de la matriz unidimensional de `int`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-165">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="cbb1d-166">Tampoco es necesario declarar los tipos que admiten un valor NULL antes de usarlos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-166">Nullable value types also don't have to be declared before they can be used.</span></span> <span data-ttu-id="cbb1d-167">Para cada tipo de valor `T` que no acepta valores NULL, existe un tipo de valor `T?` que admite un valor NULL correspondiente, que puede tener un valor adicional, `null`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-167">For each non-nullable value type `T`, there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="cbb1d-168">Por ejemplo, `int?` es un tipo que puede contener cualquier número entero de 32 bits o el valor `null`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-168">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="cbb1d-169">El sistema de tipos de C# está unificado, de tal forma que un valor de cualquier tipo puede tratarse como `object`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-169">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="cbb1d-170">Todos los tipos de C# directa o indirectamente se derivan del tipo de clase `object`, y `object` es la clase base definitiva de todos los tipos.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-170">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="cbb1d-171">Los valores de tipos de referencia se tratan como objetos mediante la visualización de los valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-171">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="cbb1d-172">Los valores de tipos de valor se tratan como objetos mediante la realización de *operaciones de conversión boxing* y *operaciones de conversión unboxing*.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-172">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="cbb1d-173">En el ejemplo siguiente, un valor `int` se convierte en `object` y vuelve a `int`.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-173">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="cbb1d-174">Cuando se asigna un valor de un tipo de valor a una referencia `object`, se asigna un "box" para contener el valor.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-174">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="cbb1d-175">Ese box es una instancia de un tipo de referencia, y es donde se copia el valor.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-175">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="cbb1d-176">Por el contrario, cuando una referencia `object` se convierte en un tipo de valor, se comprueba si el elemento `object` al que se hace referencia es un box del tipo de valor correcto.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-176">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="cbb1d-177">Si la comprobación se realiza correctamente, el valor del box se copia en el tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-177">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="cbb1d-178">El sistema de tipos unificado de C# conlleva efectivamente que los tipos de valor se tratan como referencias `object` "a petición".</span><span class="sxs-lookup"><span data-stu-id="cbb1d-178">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="cbb1d-179">Debido a la unificación, las bibliotecas de uso general que utilizan el tipo `object` pueden usarse con todos los tipos que se derivan de `object`, como, por ejemplo, los tipos de referencia y los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-179">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="cbb1d-180">Hay varios tipos de *variables* en C#, entre otras, campos, elementos de matriz, variables locales y parámetros.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-180">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="cbb1d-181">Las variables representan ubicaciones de almacenamiento, y cada variable tiene un tipo que determina qué valores pueden almacenarse en la variable, como se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="cbb1d-181">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="cbb1d-182">Tipo de valor distinto a NULL</span><span class="sxs-lookup"><span data-stu-id="cbb1d-182">Non-nullable value type</span></span>
  - <span data-ttu-id="cbb1d-183">Un valor de ese tipo exacto</span><span class="sxs-lookup"><span data-stu-id="cbb1d-183">A value of that exact type</span></span>
- <span data-ttu-id="cbb1d-184">Tipos de valor NULL</span><span class="sxs-lookup"><span data-stu-id="cbb1d-184">Nullable value type</span></span>
  - <span data-ttu-id="cbb1d-185">Un valor `null` o un valor de ese tipo exacto</span><span class="sxs-lookup"><span data-stu-id="cbb1d-185">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="cbb1d-186">objeto</span><span class="sxs-lookup"><span data-stu-id="cbb1d-186">object</span></span>
  - <span data-ttu-id="cbb1d-187">Una referencia `null`, una referencia a un objeto de cualquier tipo de referencia o una referencia a un valor de conversión boxing de cualquier tipo de valor</span><span class="sxs-lookup"><span data-stu-id="cbb1d-187">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="cbb1d-188">Tipo de clase</span><span class="sxs-lookup"><span data-stu-id="cbb1d-188">Class type</span></span>
  - <span data-ttu-id="cbb1d-189">Una referencia `null`, una referencia a una instancia de ese tipo de clase o una referencia a una instancia de una clase derivada de ese tipo de clase</span><span class="sxs-lookup"><span data-stu-id="cbb1d-189">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="cbb1d-190">Tipo de interfaz</span><span class="sxs-lookup"><span data-stu-id="cbb1d-190">Interface type</span></span>
  - <span data-ttu-id="cbb1d-191">Un referencia `null`, una referencia a una instancia de un tipo de clase que implementa dicho tipo de interfaz o una referencia a un valor de conversión boxing de un tipo de valor que implementa dicho tipo de interfaz</span><span class="sxs-lookup"><span data-stu-id="cbb1d-191">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="cbb1d-192">Tipo de matriz</span><span class="sxs-lookup"><span data-stu-id="cbb1d-192">Array type</span></span>
  - <span data-ttu-id="cbb1d-193">Una referencia `null`, una referencia a una instancia de ese tipo de matriz o una referencia a una instancia de un tipo de matriz compatible</span><span class="sxs-lookup"><span data-stu-id="cbb1d-193">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="cbb1d-194">Tipo delegado</span><span class="sxs-lookup"><span data-stu-id="cbb1d-194">Delegate type</span></span>
  - <span data-ttu-id="cbb1d-195">Una referencia `null` o una referencia a una instancia de un tipo delegado compatible</span><span class="sxs-lookup"><span data-stu-id="cbb1d-195">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="cbb1d-196">[Anterior](program-structure.md)
> [Siguiente](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="cbb1d-196">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
