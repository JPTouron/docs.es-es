---
title: Realizar combinaciones agrupadas (LINQ en C#)
description: Obtenga información sobre cómo realizar combinaciones agrupadas con LINQ en C#.
ms.date: 04/22/2020
ms.assetid: 9667daf9-a5fd-4b43-a5c4-a9c2b744000e
ms.openlocfilehash: 6411479c5fe6cb0ee79a0cd3df6de2f4d42c26a2
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/15/2020
ms.locfileid: "90542814"
---
# <a name="perform-grouped-joins"></a><span data-ttu-id="28ddd-103">Realizar combinaciones agrupadas</span><span class="sxs-lookup"><span data-stu-id="28ddd-103">Perform grouped joins</span></span>

<span data-ttu-id="28ddd-104">La combinación agrupada resulta útil para generar estructuras de datos jerárquicas.</span><span class="sxs-lookup"><span data-stu-id="28ddd-104">The group join is useful for producing hierarchical data structures.</span></span> <span data-ttu-id="28ddd-105">Empareja cada elemento de la primera colección con un conjunto de elementos correlacionados de la segunda colección.</span><span class="sxs-lookup"><span data-stu-id="28ddd-105">It pairs each element from the first collection with a set of correlated elements from the second collection.</span></span>

<span data-ttu-id="28ddd-106">Por ejemplo, una clase o una tabla de base de datos relacional denominada `Student` podría contener dos campos: `Id` y `Name`.</span><span class="sxs-lookup"><span data-stu-id="28ddd-106">For example, a class or a relational database table named `Student` might contain two fields: `Id` and `Name`.</span></span> <span data-ttu-id="28ddd-107">Una segunda clase o tabla de base de datos relacional denominada `Course` podría contener dos campos: `StudentId` y `CourseTitle`.</span><span class="sxs-lookup"><span data-stu-id="28ddd-107">A second class or relational database table named `Course` might contain two fields: `StudentId` and `CourseTitle`.</span></span> <span data-ttu-id="28ddd-108">Una combinación agrupada de estos dos orígenes de datos, basada en la combinación de `Student.Id` y `Course.StudentId`, agruparía cada `Student` con una colección de objetos `Course` (que podrían estar vacíos).</span><span class="sxs-lookup"><span data-stu-id="28ddd-108">A group join of these two data sources, based on matching `Student.Id` and `Course.StudentId`, would group each `Student` with a collection of `Course` objects (which might be empty).</span></span>

> [!NOTE]
> <span data-ttu-id="28ddd-109">Cada elemento de la primera colección aparece en el conjunto de resultados de una combinación agrupada, independientemente de si se encuentran elementos correlacionados en la segunda colección.</span><span class="sxs-lookup"><span data-stu-id="28ddd-109">Each element of the first collection appears in the result set of a group join regardless of whether correlated elements are found in the second collection.</span></span> <span data-ttu-id="28ddd-110">En el caso de que no se encuentren elementos correlacionados, la secuencia de elementos correlacionados para ese elemento estaría vacía.</span><span class="sxs-lookup"><span data-stu-id="28ddd-110">In the case where no correlated elements are found, the sequence of correlated elements for that element is empty.</span></span> <span data-ttu-id="28ddd-111">Por consiguiente, el selector de resultados tiene acceso a cada uno de los elementos de la primera colección.</span><span class="sxs-lookup"><span data-stu-id="28ddd-111">The result selector therefore has access to every element of the first collection.</span></span> <span data-ttu-id="28ddd-112">Esto difiere del selector de resultados en una combinación no agrupada, que no puede acceder a los elementos de la primera colección que no tienen ninguna coincidencia en la segunda colección.</span><span class="sxs-lookup"><span data-stu-id="28ddd-112">This differs from the result selector in a non-group join, which cannot access elements from the first collection that have no match in the second collection.</span></span>

> [!WARNING]
> <span data-ttu-id="28ddd-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> no tiene ningún equivalente directo en términos de base de datos relacional tradicional.</span><span class="sxs-lookup"><span data-stu-id="28ddd-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> has no direct equivalent in traditional relational database terms.</span></span> <span data-ttu-id="28ddd-114">Sin embargo, este método implementa un superconjunto de combinaciones internas y combinaciones externas izquierdas.</span><span class="sxs-lookup"><span data-stu-id="28ddd-114">However, this method does implement a superset of inner joins and left outer joins.</span></span> <span data-ttu-id="28ddd-115">Ambas operaciones se pueden escribir en términos de una combinación agrupada.</span><span class="sxs-lookup"><span data-stu-id="28ddd-115">Both of these operations can be written in terms of a grouped join.</span></span> <span data-ttu-id="28ddd-116">Para obtener más información, consulte [Operaciones de combinación](../programming-guide/concepts/linq/join-operations.md) y [Entity Framework Core, GroupJoin](/ef/core/querying/complex-query-operators#groupjoin).</span><span class="sxs-lookup"><span data-stu-id="28ddd-116">For more information, see [Join Operations](../programming-guide/concepts/linq/join-operations.md) and [Entity Framework Core, GroupJoin](/ef/core/querying/complex-query-operators#groupjoin).</span></span>

<span data-ttu-id="28ddd-117">En el primer ejemplo de este artículo se muestra cómo realizar una combinación agrupada.</span><span class="sxs-lookup"><span data-stu-id="28ddd-117">The first example in this article shows you how to perform a group join.</span></span> <span data-ttu-id="28ddd-118">En el segundo ejemplo se muestra cómo usar una combinación agrupada para crear elementos XML.</span><span class="sxs-lookup"><span data-stu-id="28ddd-118">The second example shows you how to use a group join to create XML elements.</span></span>

## <a name="example---group-join"></a><span data-ttu-id="28ddd-119">Ejemplo: Combinación agrupada</span><span class="sxs-lookup"><span data-stu-id="28ddd-119">Example - Group join</span></span>

<span data-ttu-id="28ddd-120">En el ejemplo siguiente se realiza una combinación agrupada de objetos de tipo `Person` y `Pet` basada en la coincidencia de `Person` con la propiedad `Pet.Owner`.</span><span class="sxs-lookup"><span data-stu-id="28ddd-120">The following example performs a group join of objects of type `Person` and `Pet` based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="28ddd-121">A diferencia de una combinación no agrupada, que generaría un par de elementos para cada coincidencia, la combinación agrupada produce un único objeto resultante para cada elemento de la primera colección, que en este ejemplo es un objeto `Person`.</span><span class="sxs-lookup"><span data-stu-id="28ddd-121">Unlike a non-group join, which would produce a pair of elements for each match, the group join produces only one resulting object for each element of the first collection, which in this example is a `Person` object.</span></span> <span data-ttu-id="28ddd-122">Los elementos correspondientes de la segunda colección, que en este ejemplo son objetos `Pet`, se agrupan en una colección.</span><span class="sxs-lookup"><span data-stu-id="28ddd-122">The corresponding elements from the second collection, which in this example are `Pet` objects, are grouped into a collection.</span></span> <span data-ttu-id="28ddd-123">Por último, la función de selector de resultados crea un tipo anónimo para cada coincidencia formada por `Person.FirstName` y una colección de objetos `Pet`.</span><span class="sxs-lookup"><span data-stu-id="28ddd-123">Finally, the result selector function creates an anonymous type for each match that consists of `Person.FirstName` and a collection of `Pet` objects.</span></span>

[!code-csharp[CsLINQProgJoining#5](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_1.cs)]

## <a name="example---group-join-to-create-xml"></a><span data-ttu-id="28ddd-124">Ejemplo: Combinación agrupada para crear XML</span><span class="sxs-lookup"><span data-stu-id="28ddd-124">Example - Group join to create XML</span></span>

<span data-ttu-id="28ddd-125">Las combinaciones agrupadas resultan ideales para crear XML con LINQ to XML.</span><span class="sxs-lookup"><span data-stu-id="28ddd-125">Group joins are ideal for creating XML by using LINQ to XML.</span></span> <span data-ttu-id="28ddd-126">El siguiente ejemplo es similar al anterior, pero en lugar de crear tipos anónimos, la función de selector de resultados crea elementos XML que representan los objetos combinados.</span><span class="sxs-lookup"><span data-stu-id="28ddd-126">The following example is similar to the previous example except that instead of creating anonymous types, the result selector function creates XML elements that represent the joined objects.</span></span>

[!code-csharp[CsLINQProgJoining#6](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_2.cs)]

## <a name="see-also"></a><span data-ttu-id="28ddd-127">Vea también</span><span class="sxs-lookup"><span data-stu-id="28ddd-127">See also</span></span>

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [<span data-ttu-id="28ddd-128">Realizar combinaciones internas</span><span class="sxs-lookup"><span data-stu-id="28ddd-128">Perform inner joins</span></span>](perform-inner-joins.md)
- [<span data-ttu-id="28ddd-129">Realizar operaciones de combinación externa izquierda</span><span class="sxs-lookup"><span data-stu-id="28ddd-129">Perform left outer joins</span></span>](perform-left-outer-joins.md)
- <span data-ttu-id="28ddd-130">[Tipos anónimos (Guía de programación de C#)](../programming-guide/classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="28ddd-130">[Anonymous types](../programming-guide/classes-and-structs/anonymous-types.md)</span></span>
