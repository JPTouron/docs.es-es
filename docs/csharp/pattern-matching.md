---
title: 'Coincidencia de patrones: Guía de C#'
description: Información sobre las expresiones de coincidencia de patrones en C#
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 2dd1401e3ef22a02f327e44ff884182ee3e22278
ms.sourcegitcommit: b1f4756120deaecb8b554477bb040620f69a4209
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/03/2020
ms.locfileid: "89414999"
---
# <a name="pattern-matching"></a><span data-ttu-id="edcf7-103">Coincidencia de modelos</span><span class="sxs-lookup"><span data-stu-id="edcf7-103">Pattern Matching</span></span>

<span data-ttu-id="edcf7-104">Los patrones comprueban que un valor tenga una determinada *forma* y pueden *extraer* información del valor cuando tiene la forma coincidente.</span><span class="sxs-lookup"><span data-stu-id="edcf7-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="edcf7-105">La coincidencia de patrones proporciona una sintaxis más concisa para los algoritmos que se usan actualmente.</span><span class="sxs-lookup"><span data-stu-id="edcf7-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="edcf7-106">Ya se crean algoritmos de coincidencia de patrones mediante la sintaxis existente.</span><span class="sxs-lookup"><span data-stu-id="edcf7-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="edcf7-107">Se escriben instrucciones `if` o `switch` que comprueban valores.</span><span class="sxs-lookup"><span data-stu-id="edcf7-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="edcf7-108">Luego, si esas instrucciones coinciden, se extrae y se usa la información de ese valor.</span><span class="sxs-lookup"><span data-stu-id="edcf7-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="edcf7-109">Los nuevos elementos de sintaxis son extensiones de instrucciones con las que ya está familiarizado: `is` y `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="edcf7-110">Estas nuevas extensiones combinan la comprobación de un valor y la extracción de esa información.</span><span class="sxs-lookup"><span data-stu-id="edcf7-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="edcf7-111">En este artículo se tratará la nueva sintaxis para mostrar cómo permite escribir un código conciso y legible.</span><span class="sxs-lookup"><span data-stu-id="edcf7-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="edcf7-112">La coincidencia de patrones permite expresiones donde se separan el código y los datos, a diferencia de los diseños orientados a objetos, donde los datos y los métodos que los manipulan están estrechamente unidos.</span><span class="sxs-lookup"><span data-stu-id="edcf7-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="edcf7-113">Para mostrar estas nuevas expresiones, vamos a trabajar con estructuras que representan formas geométricas mediante instrucciones de coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="edcf7-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="edcf7-114">Probablemente esté familiarizado con la creación de jerarquías de clases y de [métodos virtuales y métodos invalidados](methods.md#inherited) para personalizar el comportamiento de los objetos según el tipo de tiempo de ejecución del objeto.</span><span class="sxs-lookup"><span data-stu-id="edcf7-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="edcf7-115">Esas técnicas no son posibles en el caso de los datos que no están estructurados en una jerarquía de clases.</span><span class="sxs-lookup"><span data-stu-id="edcf7-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="edcf7-116">Cuando los datos y los métodos están separados, se necesitan otras herramientas.</span><span class="sxs-lookup"><span data-stu-id="edcf7-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="edcf7-117">Las nuevas construcciones de *coincidencia de patrones* permiten una sintaxis más limpia para examinar los datos y manipular el flujo de control basándose en cualquier condición de esos datos.</span><span class="sxs-lookup"><span data-stu-id="edcf7-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="edcf7-118">Ya escribe instrucciones `if` y `switch` que comprueban el valor de una variable.</span><span class="sxs-lookup"><span data-stu-id="edcf7-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="edcf7-119">Escribe instrucciones `is` que comprueban el tipo de una variable.</span><span class="sxs-lookup"><span data-stu-id="edcf7-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="edcf7-120">La *coincidencia de patrones* agrega nuevas capacidades a esas instrucciones.</span><span class="sxs-lookup"><span data-stu-id="edcf7-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="edcf7-121">En este artículo se creará un método que calcula el área de distintas formas geométricas.</span><span class="sxs-lookup"><span data-stu-id="edcf7-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="edcf7-122">Pero se hará sin recurrir a técnicas orientadas a objetos y sin crear una jerarquía de clases para las diferentes formas.</span><span class="sxs-lookup"><span data-stu-id="edcf7-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="edcf7-123">En lugar de esto se usará la *coincidencia de patrones*.</span><span class="sxs-lookup"><span data-stu-id="edcf7-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="edcf7-124">Conforme avance en este ejemplo, compare este código con cómo se estructuraría como una jerarquía de objetos.</span><span class="sxs-lookup"><span data-stu-id="edcf7-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="edcf7-125">Cuando los datos que se deben consultar y manipular no son una jerarquía de clases, la coincidencia de patrones permite diseños elegantes.</span><span class="sxs-lookup"><span data-stu-id="edcf7-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="edcf7-126">En lugar de empezar con una definición de forma abstracta y agregar diferentes clases de formas concretas, se comenzará con simples definiciones solo de datos para cada una de las formas geométricas:</span><span class="sxs-lookup"><span data-stu-id="edcf7-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="edcf7-127">A partir de estas estructuras se va a escribir un método que calcula el área de alguna forma.</span><span class="sxs-lookup"><span data-stu-id="edcf7-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="edcf7-128">Expresión de patrón de tipo `is`</span><span class="sxs-lookup"><span data-stu-id="edcf7-128">The `is` type pattern expression</span></span>

<span data-ttu-id="edcf7-129">Antes de C# 7.0, había que comprobar cada tipo en una serie de instrucciones `if` e `is`:</span><span class="sxs-lookup"><span data-stu-id="edcf7-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="edcf7-130">El código anterior es una expresión clásica del *patrón de tipo*: se prueba una variable para determinar su tipo y se realiza una acción diferente basada en ese tipo.</span><span class="sxs-lookup"><span data-stu-id="edcf7-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="edcf7-131">Este código se simplifica con extensiones de la expresión `is` para asignar una variable si la prueba se realiza correctamente:</span><span class="sxs-lookup"><span data-stu-id="edcf7-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="edcf7-132">En esta versión actualizada, la expresión `is` prueba la variable y la asigna a una nueva variable del tipo correcto.</span><span class="sxs-lookup"><span data-stu-id="edcf7-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="edcf7-133">Observe también que esta versión incluye el tipo `Rectangle`, que es un elemento `struct`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="edcf7-134">La nueva expresión `is` funciona con tipos de valor y con tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="edcf7-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="edcf7-135">Las reglas del lenguaje para las expresiones de coincidencia de patrones ayudan a evitar el uso indebido de los resultados de una expresión de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="edcf7-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="edcf7-136">En el ejemplo anterior, las variables `s`, `c` y `r` solo están en el ámbito y se asignan definitivamente cuando las expresiones de coincidencia de patrones respectivas tienen resultados `true`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="edcf7-137">Si intenta usar una de las variables en otra ubicación, el código genera errores del compilador.</span><span class="sxs-lookup"><span data-stu-id="edcf7-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="edcf7-138">Vamos a examinar detenidamente esas dos reglas, a partir del ámbito.</span><span class="sxs-lookup"><span data-stu-id="edcf7-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="edcf7-139">La variable `c` está en el ámbito únicamente en la rama `else` de la primera instrucción `if`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="edcf7-140">La variable `s` está en el ámbito en el método `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="edcf7-141">Eso se debe a que cada rama de una instrucción `if` establece un ámbito independiente para las variables.</span><span class="sxs-lookup"><span data-stu-id="edcf7-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="edcf7-142">Pero la propia instrucción `if` no.</span><span class="sxs-lookup"><span data-stu-id="edcf7-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="edcf7-143">Eso significa que las variables declaradas en la instrucción `if` están en el mismo ámbito que la instrucción `if` (el método en este caso).</span><span class="sxs-lookup"><span data-stu-id="edcf7-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case).</span></span> <span data-ttu-id="edcf7-144">Este comportamiento no es específico de la coincidencia de patrones, sino que es el definido para los ámbitos de variable y las instrucciones `if` y `else`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-144">This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="edcf7-145">Las variables `c` y `s` se asignan cuando las respectivas instrucciones `if` son true debido al mecanismo when true asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="edcf7-145">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="edcf7-146">En los ejemplos de este tema se usa la construcción recomendada, donde una expresión de coincidencia de patrones `is` asigna definitivamente la variable de coincidencia en la rama `true` de la instrucción `if`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-146">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="edcf7-147">Se podría invertir la lógica al decir `if (!(shape is Square s))` y la variable `s` se asignaría definitivamente solo en la rama `false`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-147">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="edcf7-148">Aunque esto es C# válido, no se recomienda, porque es más confuso para seguir la lógica.</span><span class="sxs-lookup"><span data-stu-id="edcf7-148">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="edcf7-149">Estas reglas significan que es poco probable que se acceda accidentalmente al resultado de una expresión de coincidencia de patrones cuando no ha habido coincidencia de ese patrón.</span><span class="sxs-lookup"><span data-stu-id="edcf7-149">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="edcf7-150">Uso de instrucciones de coincidencia de patrones `switch`</span><span class="sxs-lookup"><span data-stu-id="edcf7-150">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="edcf7-151">Con el tiempo, es posible que tenga que admitir otros tipos de formas.</span><span class="sxs-lookup"><span data-stu-id="edcf7-151">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="edcf7-152">A medida que crece el número de condiciones que se está probando, puede resultar pesado el uso de expresiones de coincidencia de patrones `is`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-152">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="edcf7-153">Además de necesitar instrucciones `if` en cada tipo que se quiere comprobar, las expresiones `is` solo se pueden probar si la entrada coincide con un único tipo.</span><span class="sxs-lookup"><span data-stu-id="edcf7-153">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="edcf7-154">En este caso, las expresiones de coincidencia de patrones `switch` son una mejor opción.</span><span class="sxs-lookup"><span data-stu-id="edcf7-154">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="edcf7-155">La instrucción tradicional `switch` era una expresión de patrón: admitía el patrón de constante.</span><span class="sxs-lookup"><span data-stu-id="edcf7-155">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="edcf7-156">Se podía comparar una variable con cualquier constante usada en una instrucción `case`:</span><span class="sxs-lookup"><span data-stu-id="edcf7-156">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="edcf7-157">El único patrón admitido por la instrucción `switch` era el patrón de constante.</span><span class="sxs-lookup"><span data-stu-id="edcf7-157">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="edcf7-158">Se limitaba aún más a tipos numéricos y al tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-158">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="edcf7-159">Esas restricciones se han eliminado y ahora se puede escribir una instrucción `switch` con el patrón de tipos:</span><span class="sxs-lookup"><span data-stu-id="edcf7-159">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="edcf7-160">La instrucción de coincidencia de patrones `switch` usa una sintaxis familiar para los desarrolladores que han empleado la instrucción de estilo C tradicional `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-160">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="edcf7-161">Cada `case` se evalúa y se ejecuta el código debajo de la condición que coincide con la variable de entrada.</span><span class="sxs-lookup"><span data-stu-id="edcf7-161">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="edcf7-162">La ejecución de código no puede "pasar explícitamente" de una expresión case a la siguiente; la sintaxis de la instrucción `case` exige que cada `case` termine con `break`, `return` o `goto`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-162">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="edcf7-163">Las instrucciones `goto` para saltar a otra etiqueta solo son válidas para el patrón de constante, la instrucción switch clásica.</span><span class="sxs-lookup"><span data-stu-id="edcf7-163">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="edcf7-164">Hay nuevas e importantes reglas que rigen la instrucción `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-164">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="edcf7-165">Las restricciones respecto al tipo de la variable en la expresión `switch` se han eliminado.</span><span class="sxs-lookup"><span data-stu-id="edcf7-165">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="edcf7-166">Se puede usar cualquier tipo, como `object` en este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="edcf7-166">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="edcf7-167">Las expresiones case ya no se limitan a valores constantes.</span><span class="sxs-lookup"><span data-stu-id="edcf7-167">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="edcf7-168">La eliminación de esa limitación significa que la reordenación de secciones `switch` puede cambiar el comportamiento de un programa.</span><span class="sxs-lookup"><span data-stu-id="edcf7-168">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="edcf7-169">Cuando se limitaba a valores constantes, más de una etiqueta `case` podía coincidir con el valor de la expresión `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-169">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="edcf7-170">Eso sumado a la regla de que cada sección `switch` no debe pasar explícitamente a la sección siguiente, el resultado era que las secciones `switch` se podían reorganizar en cualquier orden sin afectar al comportamiento.</span><span class="sxs-lookup"><span data-stu-id="edcf7-170">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="edcf7-171">Ahora, con expresiones `switch` más generalizadas, el orden de cada sección importa.</span><span class="sxs-lookup"><span data-stu-id="edcf7-171">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="edcf7-172">Las expresiones `switch` se evalúan en orden textual.</span><span class="sxs-lookup"><span data-stu-id="edcf7-172">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="edcf7-173">La ejecución se transfiere a la primera etiqueta `switch` que coincide con la expresión `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-173">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="edcf7-174">El caso `default` solo se ejecutará si no coincide ninguna otra etiqueta case.</span><span class="sxs-lookup"><span data-stu-id="edcf7-174">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="edcf7-175">El caso `default` se evalúa en último lugar, independientemente de su orden textual.</span><span class="sxs-lookup"><span data-stu-id="edcf7-175">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="edcf7-176">Si no hay ningún caso `default` y ninguna de las instrucciones `case` coincide, la ejecución continúa en la instrucción siguiente a la instrucción `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-176">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="edcf7-177">No se ejecuta el código de ninguna de las etiquetas `case`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-177">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="edcf7-178">Cláusulas `when` en expresiones `case`</span><span class="sxs-lookup"><span data-stu-id="edcf7-178">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="edcf7-179">Puede crear casos especiales para las formas que tengan área 0 mediante una cláusula `when` en la etiqueta `case`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-179">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="edcf7-180">Un cuadrado con una longitud de lado de 0 o un círculo con un radio de 0 tiene un área 0.</span><span class="sxs-lookup"><span data-stu-id="edcf7-180">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="edcf7-181">Esa condición se especifica mediante una cláusula `when` en la etiqueta `case`:</span><span class="sxs-lookup"><span data-stu-id="edcf7-181">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="edcf7-182">Este cambio muestra algunos puntos importantes sobre la nueva sintaxis.</span><span class="sxs-lookup"><span data-stu-id="edcf7-182">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="edcf7-183">En primer lugar, se pueden aplicar varias etiquetas `case` a una sección `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-183">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="edcf7-184">El bloque de instrucciones se ejecuta cuando cualquiera de esas etiquetas es `true`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-184">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="edcf7-185">En esta instancia, si la expresión `switch` es un círculo o un cuadrado con área 0, el método devuelve la constante 0.</span><span class="sxs-lookup"><span data-stu-id="edcf7-185">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="edcf7-186">Este ejemplo presenta dos variables distintas en las dos etiquetas `case` del primer bloque `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-186">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="edcf7-187">Observe que las instrucciones de este bloque `switch` no usan las variables `c` (para el círculo) ni `s` (para el cuadrado).</span><span class="sxs-lookup"><span data-stu-id="edcf7-187">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="edcf7-188">Ninguna de esas variables se ha asignado definitivamente en este bloque `switch`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-188">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="edcf7-189">Si alguno de estos casos coincide, claramente se ha asignado una de las variables.</span><span class="sxs-lookup"><span data-stu-id="edcf7-189">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="edcf7-190">Pero no es posible saber *cuál* se ha asignado en tiempo de compilación, ya que cualquiera de los casos podría coincidir en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="edcf7-190">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="edcf7-191">Por ese motivo, la mayoría de las veces en que se usan varias etiquetas `case` para el mismo bloque, no se presenta una nueva variable en la instrucción `case` o solo se usará la variable en la cláusula `when`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-191">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="edcf7-192">Una vez agregadas esas formas con área 0, se van a agregar un par de tipos de formas más: un rectángulo y un triángulo:</span><span class="sxs-lookup"><span data-stu-id="edcf7-192">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="edcf7-193">Este conjunto de cambios agrega etiquetas `case` para el caso degenerado y etiquetas y bloques para cada una de las nuevas formas.</span><span class="sxs-lookup"><span data-stu-id="edcf7-193">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="edcf7-194">Por último, puede agregar un caso `null` para garantizar que el argumento no sea `null`:</span><span class="sxs-lookup"><span data-stu-id="edcf7-194">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="edcf7-195">El comportamiento especial del patrón `null` es interesante porque la constante `null` del patrón no tiene un tipo, pero se puede convertir a cualquier tipo de referencia o tipo que acepte valores NULL.</span><span class="sxs-lookup"><span data-stu-id="edcf7-195">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="edcf7-196">En lugar de convertir `null` en cualquier tipo, el lenguaje define que un valor `null` no coincidirá con ningún patrón de tipo, independientemente del tipo de tiempo de compilación de la variable.</span><span class="sxs-lookup"><span data-stu-id="edcf7-196">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="edcf7-197">Este comportamiento hace que el nuevo patrón de tipo basado en `switch` sea coherente con la instrucción `is`: las instrucciones `is` siempre devuelven `false` cuando el valor que se está comprobando es `null`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-197">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="edcf7-198">También es más sencillo: una vez que haya comprobado el tipo, no necesita una comprobación de NULL adicional.</span><span class="sxs-lookup"><span data-stu-id="edcf7-198">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="edcf7-199">Puede comprobar esto en que no existen comprobaciones de NULL en ninguno de los bloques de casos de los ejemplos anteriores: no son necesarias, ya que la coincidencia del patrón de tipo garantiza un valor distinto de NULL.</span><span class="sxs-lookup"><span data-stu-id="edcf7-199">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="edcf7-200">Declaraciones `var` en expresiones `case`</span><span class="sxs-lookup"><span data-stu-id="edcf7-200">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="edcf7-201">La introducción de `var` como una de las expresiones de coincidencia presenta nuevas reglas para la coincidencias de patrones.</span><span class="sxs-lookup"><span data-stu-id="edcf7-201">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="edcf7-202">La primera regla es que la declaración `var` sigue las reglas de inferencia de tipo normal: El tipo se infiere para que sea el tipo estático de la expresión switch.</span><span class="sxs-lookup"><span data-stu-id="edcf7-202">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="edcf7-203">De esa regla, el tipo siempre coincide.</span><span class="sxs-lookup"><span data-stu-id="edcf7-203">From that rule, the type always matches.</span></span>

<span data-ttu-id="edcf7-204">La segunda regla es que una declaración `var` no tiene la comprobación de valores NULL que incluyen otras expresiones de patrón de tipo.</span><span class="sxs-lookup"><span data-stu-id="edcf7-204">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="edcf7-205">Esto significa que la variable puede ser NULL y se necesita una comprobación de valores NULL en ese caso.</span><span class="sxs-lookup"><span data-stu-id="edcf7-205">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="edcf7-206">Esas dos reglas implican que, en muchos casos, una declaración `var` en una expresión `case` coincide con las mismas condiciones que una expresión `default`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-206">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="edcf7-207">Dado que se prefiere cualquier caso que no sea default al caso `default`, el caso `default` nunca se ejecutará.</span><span class="sxs-lookup"><span data-stu-id="edcf7-207">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="edcf7-208">El compilador no emite una advertencia en esos casos en que se ha escrito un caso `default` pero nunca se ejecutará.</span><span class="sxs-lookup"><span data-stu-id="edcf7-208">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="edcf7-209">Esto es coherente con el comportamiento actual de la instrucción `switch` donde se han enumerado todos los casos posibles.</span><span class="sxs-lookup"><span data-stu-id="edcf7-209">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="edcf7-210">La tercera regla presenta usos donde un caso `var` puede resultar útil.</span><span class="sxs-lookup"><span data-stu-id="edcf7-210">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="edcf7-211">Imagine que va a realizar una coincidencia de patrones donde la entrada es una cadena y busca valores de comando conocidos.</span><span class="sxs-lookup"><span data-stu-id="edcf7-211">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="edcf7-212">Podría escribir algo parecido a esto:</span><span class="sxs-lookup"><span data-stu-id="edcf7-212">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="edcf7-213">El caso `var` coincide con `null`, la cadena vacía, o cualquier cadena que contenga solo espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="edcf7-213">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="edcf7-214">Tenga en cuenta que el código anterior usa el operador `?.` para asegurarse de que no genera por accidente una <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="edcf7-214">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="edcf7-215">El caso `default` controla cualquier otro valor de cadena que no entienda este analizador de comandos.</span><span class="sxs-lookup"><span data-stu-id="edcf7-215">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="edcf7-216">Este es un ejemplo en que puede que quiera considerar el uso de una expresión de caso `var` que sea distinta de una expresión `default`.</span><span class="sxs-lookup"><span data-stu-id="edcf7-216">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="edcf7-217">Conclusiones</span><span class="sxs-lookup"><span data-stu-id="edcf7-217">Conclusions</span></span>

<span data-ttu-id="edcf7-218">Las *construcciones de coincidencia de patrones* permiten administrar fácilmente el flujo de control entre distintas variables y tipos que no están relacionados mediante una jerarquía de herencia.</span><span class="sxs-lookup"><span data-stu-id="edcf7-218">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="edcf7-219">También se puede controlar la lógica para usar cualquier condición que se pruebe en la variable.</span><span class="sxs-lookup"><span data-stu-id="edcf7-219">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="edcf7-220">Permite patrones y expresiones que se van a necesitar más a menudo a medida que se crean aplicaciones más distribuidas, donde los datos y los métodos que los manipulan están separados.</span><span class="sxs-lookup"><span data-stu-id="edcf7-220">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="edcf7-221">Observará que las estructuras de forma usadas en este ejemplo no contienen métodos, solo propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="edcf7-221">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="edcf7-222">La coincidencia de patrones funciona con cualquier tipo de datos.</span><span class="sxs-lookup"><span data-stu-id="edcf7-222">Pattern Matching works with any data type.</span></span> <span data-ttu-id="edcf7-223">Se escriben expresiones que examinan el objeto y se toman decisiones de flujo de control basadas en esas condiciones.</span><span class="sxs-lookup"><span data-stu-id="edcf7-223">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="edcf7-224">Compare el código de este ejemplo con el diseño que se obtendría al crear una jerarquía de clases para un elemento `Shape` abstracto y formas derivadas concretas cada una con su propia implementación de un método virtual para calcular el área.</span><span class="sxs-lookup"><span data-stu-id="edcf7-224">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="edcf7-225">A menudo encontrará que las expresiones de coincidencia de patrones pueden ser una herramienta muy útil al trabajar con datos y querer separar las preocupaciones sobre almacenamiento de datos de las preocupaciones sobre comportamiento.</span><span class="sxs-lookup"><span data-stu-id="edcf7-225">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="edcf7-226">Vea también</span><span class="sxs-lookup"><span data-stu-id="edcf7-226">See also</span></span>

- [<span data-ttu-id="edcf7-227">Tutorial: Uso de las características de coincidencia de patrones para ampliar los tipos de datos</span><span class="sxs-lookup"><span data-stu-id="edcf7-227">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
