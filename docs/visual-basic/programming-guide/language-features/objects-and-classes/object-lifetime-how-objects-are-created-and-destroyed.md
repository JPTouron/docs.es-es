---
title: 'Duración de los objetos: cómo se crean y destruyen'
ms.date: 07/20/2015
f1_keywords:
- vb.Constructor
helpviewer_keywords:
- destructors, object lifetime
- Sub Finalize destructor
- objects [Visual Basic], destroying
- lifetime [Visual Basic], objects
- Sub New constructor, object lifetime
- Finalize method [Visual Basic], object lifetime
- objects [Visual Basic], creating
- Class_Terminate
- Dispose method [Visual Basic], object lifetime
- Class_Initialize
- object creation [Visual Basic], object lifetime
- parameterized constructors
- objects [Visual Basic], lifetime
- objects [Visual Basic], garbage collection
- constructors [Visual Basic], object lifetime
- Sub Dispose destructor
- garbage collection [Visual Basic], Visual Basic
ms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8
ms.openlocfilehash: a32a5d075b5b1d02632c80216e7c2c12920bf4a2
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/15/2020
ms.locfileid: "90544146"
---
# <a name="object-lifetime-how-objects-are-created-and-destroyed-visual-basic"></a><span data-ttu-id="bc637-102">Duración de los objetos: cómo se crean y destruyen (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="bc637-102">Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</span></span>

<span data-ttu-id="bc637-103">Mediante el uso de la palabra clave `New` se crea una instancia de una clase, un objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-103">An instance of a class, an object, is created by using the `New` keyword.</span></span> <span data-ttu-id="bc637-104">A menudo, las tareas de inicialización deben realizarse en los objetos nuevos antes de utilizarlos.</span><span class="sxs-lookup"><span data-stu-id="bc637-104">Initialization tasks often must be performed on new objects before they are used.</span></span> <span data-ttu-id="bc637-105">Las tareas de inicialización comunes incluyen abrir archivos, conectarse a bases de datos y leer los valores de las claves del registro.</span><span class="sxs-lookup"><span data-stu-id="bc637-105">Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</span></span> <span data-ttu-id="bc637-106">Visual Basic controla la inicialización de nuevos objetos mediante procedimientos denominados *constructores* (métodos especiales que permiten el control sobre la inicialización).</span><span class="sxs-lookup"><span data-stu-id="bc637-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span></span>

<span data-ttu-id="bc637-107">Después de que un objeto abandone el ámbito, se libera por Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="bc637-107">After an object leaves scope, it is released by the common language runtime (CLR).</span></span> <span data-ttu-id="bc637-108">Visual Basic controla la liberación de recursos del sistema mediante procedimientos denominados *destructores*.</span><span class="sxs-lookup"><span data-stu-id="bc637-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span></span> <span data-ttu-id="bc637-109">Juntos, los constructores y los destructores permiten la creación de bibliotecas de clases completas y predecibles.</span><span class="sxs-lookup"><span data-stu-id="bc637-109">Together, constructors and destructors support the creation of robust and predictable class libraries.</span></span>

## <a name="using-constructors-and-destructors"></a><span data-ttu-id="bc637-110">Usar constructores y destructores</span><span class="sxs-lookup"><span data-stu-id="bc637-110">Using Constructors and Destructors</span></span>

<span data-ttu-id="bc637-111">Los constructores y los destructores controlan la creación y la destrucción de objetos.</span><span class="sxs-lookup"><span data-stu-id="bc637-111">Constructors and destructors control the creation and destruction of objects.</span></span> <span data-ttu-id="bc637-112">Los `Sub New` `Sub Finalize` procedimientos y de Visual Basic inicializar y destruir objetos; reemplazan los `Class_Initialize` métodos y que se `Class_Terminate` usan en Visual Basic 6,0 y versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="bc637-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span></span>

### <a name="sub-new"></a><span data-ttu-id="bc637-113">Sub New</span><span class="sxs-lookup"><span data-stu-id="bc637-113">Sub New</span></span>

<span data-ttu-id="bc637-114">El constructor `Sub New` solo puede ejecutarse una vez cuando se crea una clase.</span><span class="sxs-lookup"><span data-stu-id="bc637-114">The `Sub New` constructor can run only once when a class is created.</span></span> <span data-ttu-id="bc637-115">No se puede llamar explícitamente en ningún lugar que no sea la primera línea de código de otro constructor de la misma clase o de una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bc637-115">It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</span></span> <span data-ttu-id="bc637-116">Además, el código del método `Sub New` siempre se ejecuta antes que cualquier otro código en una clase.</span><span class="sxs-lookup"><span data-stu-id="bc637-116">Furthermore, the code in the `Sub New` method always runs before any other code in a class.</span></span> <span data-ttu-id="bc637-117">Visual Basic crea implícitamente un `Sub New` constructor en tiempo de ejecución si no se define explícitamente un `Sub New` procedimiento para una clase.</span><span class="sxs-lookup"><span data-stu-id="bc637-117">Visual Basic implicitly creates a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span></span>

<span data-ttu-id="bc637-118">Para crear un constructor para una clase, cree un procedimiento denominado `Sub New` en cualquier parte de la definición de clase.</span><span class="sxs-lookup"><span data-stu-id="bc637-118">To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition.</span></span> <span data-ttu-id="bc637-119">Para crear un constructor parametrizado, especifique los nombres y los tipos de datos de los argumentos en `Sub New` tal y como haría al especificar argumentos en cualquier otro procedimiento, como en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="bc637-119">To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#42)]

<span data-ttu-id="bc637-120">Los constructores suelen sobrecargarse con frecuencia, como en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="bc637-120">Constructors are frequently overloaded, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#116](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#116)]

<span data-ttu-id="bc637-121">Cuando defina una clase que derive de otra clase, la primera línea de un constructor debe ser una llamada al constructor de la clase base, a menos que la clase base tenga un constructor accesible que no tome ningún parámetro.</span><span class="sxs-lookup"><span data-stu-id="bc637-121">When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</span></span> <span data-ttu-id="bc637-122">Una llamada a la clase base que contiene el constructor anterior sería, por ejemplo, `MyBase.New(s)`.</span><span class="sxs-lookup"><span data-stu-id="bc637-122">A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`.</span></span> <span data-ttu-id="bc637-123">De lo contrario, `MyBase.New` es opcional y el tiempo de ejecución de Visual Basic lo llama implícitamente.</span><span class="sxs-lookup"><span data-stu-id="bc637-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span></span>

<span data-ttu-id="bc637-124">Después de escribir el código para llamar al constructor del objeto primario, puede agregar código de inicialización al procedimiento `Sub New`.</span><span class="sxs-lookup"><span data-stu-id="bc637-124">After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure.</span></span> <span data-ttu-id="bc637-125">`Sub New` puede aceptar argumentos cuando se llama como constructor parametrizado.</span><span class="sxs-lookup"><span data-stu-id="bc637-125">`Sub New` can accept arguments when called as a parameterized constructor.</span></span> <span data-ttu-id="bc637-126">Estos parámetros se pasan desde el procedimiento que llama al constructor, por ejemplo, `Dim AnObject As New ThisClass(X)`.</span><span class="sxs-lookup"><span data-stu-id="bc637-126">These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.</span></span>

### <a name="sub-finalize"></a><span data-ttu-id="bc637-127">Sub Finalize</span><span class="sxs-lookup"><span data-stu-id="bc637-127">Sub Finalize</span></span>

<span data-ttu-id="bc637-128">Antes de liberar objetos, CLR llama automáticamente al método `Finalize` para los objetos que definen un procedimiento `Sub Finalize`.</span><span class="sxs-lookup"><span data-stu-id="bc637-128">Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure.</span></span> <span data-ttu-id="bc637-129">El método `Finalize` puede contener código que es necesario ejecutar inmediatamente antes de destruir un objeto, como el código para cerrar archivos y guardar información de estado.</span><span class="sxs-lookup"><span data-stu-id="bc637-129">The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</span></span> <span data-ttu-id="bc637-130">Hay una ligera disminución del rendimiento para la ejecución de `Sub Finalize`, por lo que se debe definir un método `Sub Finalize` solo cuando sea necesario liberar objetos explícitamente.</span><span class="sxs-lookup"><span data-stu-id="bc637-130">There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.</span></span>

> [!NOTE]
> <span data-ttu-id="bc637-131">El recolector de elementos no utilizados de CLR no (y no puede) desechar *objetos no administrados*, objetos que el sistema operativo ejecuta directamente, fuera del entorno de CLR.</span><span class="sxs-lookup"><span data-stu-id="bc637-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span></span> <span data-ttu-id="bc637-132">Esto se debe a que los diferentes objetos no administrados deben eliminarse de maneras diferentes.</span><span class="sxs-lookup"><span data-stu-id="bc637-132">This is because different unmanaged objects must be disposed of in different ways.</span></span> <span data-ttu-id="bc637-133">Esta información no está directamente asociada con el objeto no administrado; debe buscarse en la documentación del objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-133">That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</span></span> <span data-ttu-id="bc637-134">Las clases que utilizan objetos no administrados deben eliminarlos en su método `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="bc637-134">A class that uses unmanaged objects must dispose of them in its `Finalize` method.</span></span>

<span data-ttu-id="bc637-135">El destructor `Finalize` es un método protegido al que se puede llamar desde la clase a la que pertenece o desde clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="bc637-135">The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</span></span> <span data-ttu-id="bc637-136">El sistema llama automáticamente a `Finalize` cuando se destruye un objeto, por lo que no debería llamar explícitamente a `Finalize` desde fuera de una implementación `Finalize` de una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bc637-136">The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.</span></span>

<span data-ttu-id="bc637-137">A diferencia de `Class_Terminate`, que se ejecuta en cuanto un objeto se establece en Nothing, suele haber un retraso entre el momento en que un objeto pierde su ámbito y el momento en que Visual Basic llama al destructor `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="bc637-137">Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor.</span></span> <span data-ttu-id="bc637-138">Visual Basic .NET permite un segundo tipo de destructor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> , al que se puede llamar explícitamente en cualquier momento para liberar recursos inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="bc637-138">Visual Basic .NET allows for a second kind of destructor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>, which can be explicitly called at any time to immediately release resources.</span></span>

> [!NOTE]
> <span data-ttu-id="bc637-139">Un destructor `Finalize` no debería producir excepciones, ya que la aplicación no puede controlarlas y eso puede hacer que la aplicación finalice.</span><span class="sxs-lookup"><span data-stu-id="bc637-139">A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</span></span>

### <a name="how-new-and-finalize-methods-work-in-a-class-hierarchy"></a><span data-ttu-id="bc637-140">Cómo funcionan los métodos New y Finalize en una jerarquía de clases</span><span class="sxs-lookup"><span data-stu-id="bc637-140">How New and Finalize Methods Work in a Class Hierarchy</span></span>

<span data-ttu-id="bc637-141">Siempre que se crea una instancia de una clase, Common Language Runtime (CLR) intenta ejecutar un procedimiento denominado `New`, si existe en ese objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-141">Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object.</span></span> <span data-ttu-id="bc637-142">`New` es un tipo de procedimiento llamado `constructor` que se utiliza para inicializar objetos nuevos antes de que se ejecute otro código en un objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span></span> <span data-ttu-id="bc637-143">Un constructor `New` puede utilizarse para abrir archivos, conectarse a bases de datos, inicializar variables y ocuparse de las demás tareas que deban realizarse para que pueda utilizarse un objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-143">A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</span></span>

<span data-ttu-id="bc637-144">Cuando se crea una instancia de una clase derivada, se ejecuta primero el constructor `Sub New` de la clase base, seguido de los constructores de las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="bc637-144">When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes.</span></span> <span data-ttu-id="bc637-145">Esto se debe a que la primera línea de código de un constructor `Sub New` utiliza la sintaxis `MyBase.New()` para llamar al constructor de la clase que se encuentra inmediatamente encima en la jerarquía de clases.</span><span class="sxs-lookup"><span data-stu-id="bc637-145">This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy.</span></span> <span data-ttu-id="bc637-146">A continuación, se llama al constructor `Sub New` para cada clase de la jerarquía de clases hasta que se alcanza el constructor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="bc637-146">The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</span></span> <span data-ttu-id="bc637-147">En ese momento, se ejecuta el código en el constructor de la clase base, seguido del código en cada constructor de todas las clases derivadas y, en último lugar, se ejecuta el código de las clases más derivadas.</span><span class="sxs-lookup"><span data-stu-id="bc637-147">At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</span></span>

![Captura de pantalla que muestra los constructores y la herencia de la jerarquía de clases.](./media/object-lifetime-how-objects-are-created-and-destroyed/subnew-constructor-inheritance.gif)

<span data-ttu-id="bc637-149">Cuando un objeto ya no es necesario, CLR llama al método <xref:System.Object.Finalize%2A> para ese objeto antes de liberar su memoria.</span><span class="sxs-lookup"><span data-stu-id="bc637-149">When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory.</span></span> <span data-ttu-id="bc637-150">El método <xref:System.Object.Finalize%2A> se denomina `destructor`, ya que realiza tareas de limpieza, como guardar información de estado, cerrar archivos y conexiones a bases de datos, y otras tareas que deben realizarse antes de liberar el objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-150">The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</span></span>

![Captura de pantalla que muestra el destructor del método Finalize.](./media/object-lifetime-how-objects-are-created-and-destroyed/finalize-method-destructor.gif)

## <a name="idisposable-interface"></a><span data-ttu-id="bc637-152">Interfaz IDisposable</span><span class="sxs-lookup"><span data-stu-id="bc637-152">IDisposable Interface</span></span>

<span data-ttu-id="bc637-153">Las instancias de clase suelen controlar los recursos no administrados por CLR, como identificadores de ventanas y conexiones de base de datos.</span><span class="sxs-lookup"><span data-stu-id="bc637-153">Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</span></span> <span data-ttu-id="bc637-154">Estos recursos deben eliminarse en el método `Finalize` de la clase, para que se liberen cuando el recolector de elementos no utilizados destruya el objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-154">These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector.</span></span> <span data-ttu-id="bc637-155">Sin embargo, el recolector de elementos no utilizados solo destruye objetos cuando CLR requiere más memoria libre.</span><span class="sxs-lookup"><span data-stu-id="bc637-155">However, the garbage collector destroys objects only when the CLR requires more free memory.</span></span> <span data-ttu-id="bc637-156">Esto significa que los recursos podrían no liberarse hasta mucho después de que el objeto haya salido del ámbito.</span><span class="sxs-lookup"><span data-stu-id="bc637-156">This means that the resources may not be released until long after the object goes out of scope.</span></span>

<span data-ttu-id="bc637-157">Para complementar la recolección de elementos no utilizados, las clases pueden proporcionar un mecanismo para administrar activamente los recursos del sistema si implementan la interfaz <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="bc637-157">To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="bc637-158"><xref:System.IDisposable> tiene un método, <xref:System.IDisposable.Dispose%2A>, al que los clientes deben llamar cuando acaben de utilizar un objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span></span> <span data-ttu-id="bc637-159">Puede utilizar el método <xref:System.IDisposable.Dispose%2A> para liberar recursos inmediatamente y realizar tareas como cerrar archivos y conexiones de base de datos.</span><span class="sxs-lookup"><span data-stu-id="bc637-159">You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections.</span></span> <span data-ttu-id="bc637-160">A diferencia del destructor `Finalize`, no se llama automáticamente al método <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="bc637-160">Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically.</span></span> <span data-ttu-id="bc637-161">Los clientes de una clase deben llamar explícitamente a <xref:System.IDisposable.Dispose%2A> si desea liberar recursos inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="bc637-161">Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.</span></span>

### <a name="implementing-idisposable"></a><span data-ttu-id="bc637-162">Implementar IDisposable</span><span class="sxs-lookup"><span data-stu-id="bc637-162">Implementing IDisposable</span></span>

<span data-ttu-id="bc637-163">Una clase que implemente la interfaz <xref:System.IDisposable> debería incluir estas secciones de código:</span><span class="sxs-lookup"><span data-stu-id="bc637-163">A class that implements the <xref:System.IDisposable> interface should include these sections of code:</span></span>

- <span data-ttu-id="bc637-164">Un campo para realizar un seguimiento de si se ha eliminado el objeto:</span><span class="sxs-lookup"><span data-stu-id="bc637-164">A field for keeping track of whether the object has been disposed:</span></span>

  ```vb
  Protected disposed As Boolean = False
  ```

- <span data-ttu-id="bc637-165">Una sobrecarga de <xref:System.IDisposable.Dispose%2A> que libere los recursos de la clase.</span><span class="sxs-lookup"><span data-stu-id="bc637-165">An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources.</span></span> <span data-ttu-id="bc637-166">Este método debería ser llamado por los métodos <xref:System.IDisposable.Dispose%2A> y `Finalize` de la clase base:</span><span class="sxs-lookup"><span data-stu-id="bc637-166">This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:</span></span>

  ```vb
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
          If disposing Then
              ' Insert code to free managed resources.
          End If
          ' Insert code to free unmanaged resources.
      End If
      Me.disposed = True
  End Sub
  ```

- <span data-ttu-id="bc637-167">Una implementación de <xref:System.IDisposable.Dispose%2A> que solo contenga el siguiente código:</span><span class="sxs-lookup"><span data-stu-id="bc637-167">An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:</span></span>

  ```vb
  Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
  End Sub
  ```

- <span data-ttu-id="bc637-168">Un reemplazo del método `Finalize` que solo contenga el siguiente código:</span><span class="sxs-lookup"><span data-stu-id="bc637-168">An override of the `Finalize` method that contains only the following code:</span></span>

  ```vb
  Protected Overrides Sub Finalize()
      Dispose(False)
      MyBase.Finalize()
  End Sub
  ```

### <a name="deriving-from-a-class-that-implements-idisposable"></a><span data-ttu-id="bc637-169">Derivar de una clase que implemente IDisposable</span><span class="sxs-lookup"><span data-stu-id="bc637-169">Deriving from a Class that Implements IDisposable</span></span>

<span data-ttu-id="bc637-170">Una clase que deriva de una clase base que implementa la interfaz <xref:System.IDisposable> no necesita reemplazar ninguno de los métodos base, a menos que utilice recursos adicionales que deban eliminarse.</span><span class="sxs-lookup"><span data-stu-id="bc637-170">A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</span></span> <span data-ttu-id="bc637-171">En ese caso, la clase derivada debe reemplazar el método `Dispose(disposing)` de la clase base para eliminar los recursos de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bc637-171">In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources.</span></span> <span data-ttu-id="bc637-172">Este reemplazo debe llamar al método `Dispose(disposing)` de la clase base.</span><span class="sxs-lookup"><span data-stu-id="bc637-172">This override must call the base class's `Dispose(disposing)` method.</span></span>

```vb
Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
        If disposing Then
            ' Insert code to free managed resources.
        End If
        ' Insert code to free unmanaged resources.
    End If
    MyBase.Dispose(disposing)
End Sub
```

<span data-ttu-id="bc637-173">Una clase derivada no debe reemplazar los métodos <xref:System.IDisposable.Dispose%2A> y `Finalize` de la clase base.</span><span class="sxs-lookup"><span data-stu-id="bc637-173">A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods.</span></span> <span data-ttu-id="bc637-174">Cuando se llama a dichos métodos desde una instancia de la clase derivada, la implementación de la clase base de los métodos llama al reemplazo de la clase derivada del método `Dispose(disposing)`.</span><span class="sxs-lookup"><span data-stu-id="bc637-174">When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.</span></span>

## <a name="garbage-collection-and-the-finalize-destructor"></a><span data-ttu-id="bc637-175">Recolección de elementos no utilizados y el destructor Finalize</span><span class="sxs-lookup"><span data-stu-id="bc637-175">Garbage Collection and the Finalize Destructor</span></span>

<span data-ttu-id="bc637-176">El .NET Framework usa el sistema *de recolección de elementos no utilizados de seguimiento de referencias* para liberar periódicamente los recursos no usados.</span><span class="sxs-lookup"><span data-stu-id="bc637-176">The .NET Framework uses the *reference-tracing garbage collection* system to periodically release unused resources.</span></span> <span data-ttu-id="bc637-177">Visual Basic 6,0 y las versiones anteriores usaban un sistema diferente denominado *recuento de referencias* para administrar recursos.</span><span class="sxs-lookup"><span data-stu-id="bc637-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span></span> <span data-ttu-id="bc637-178">Aunque ambos sistemas realizan la misma función automáticamente, existen algunas diferencias importantes.</span><span class="sxs-lookup"><span data-stu-id="bc637-178">Although both systems perform the same function automatically, there are a few important differences.</span></span>

<span data-ttu-id="bc637-179">CLR destruye periódicamente objetos cuando el sistema determina que ya no son necesarios.</span><span class="sxs-lookup"><span data-stu-id="bc637-179">The CLR periodically destroys objects when the system determines that such objects are no longer needed.</span></span> <span data-ttu-id="bc637-180">Los objetos se liberan más rápidamente cuando los recursos del sistema son escasos, y menos frecuentemente en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="bc637-180">Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</span></span> <span data-ttu-id="bc637-181">El retraso que se produce entre el momento en que un objeto pierde su ámbito y el momento en que CLR lo libera conlleva que, a diferencia de lo que sucede con los objetos en Visual Basic 6.0 y versiones anteriores, no se puede determinar exactamente cuándo se destruirá el objeto.</span><span class="sxs-lookup"><span data-stu-id="bc637-181">The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</span></span> <span data-ttu-id="bc637-182">En tal situación, se dice que los objetos tienen *una duración no determinista*.</span><span class="sxs-lookup"><span data-stu-id="bc637-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span></span> <span data-ttu-id="bc637-183">En la mayoría de los casos, la duración no determinista no cambia la manera de escribir las aplicaciones, siempre y cuando tenga en cuenta que el destructor `Finalize` puede no ejecutarse inmediatamente cuando un objeto pierde su ámbito.</span><span class="sxs-lookup"><span data-stu-id="bc637-183">In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.</span></span>

<span data-ttu-id="bc637-184">Otra diferencia entre los sistemas de recolección de elementos no utilizados implica el uso de `Nothing`.</span><span class="sxs-lookup"><span data-stu-id="bc637-184">Another difference between the garbage-collection systems involves the use of `Nothing`.</span></span> <span data-ttu-id="bc637-185">Para aprovechar el recuento de referencias de Visual Basic 6.0 y versiones anteriores, los programadores a veces asignaban `Nothing` a variables de objetos para liberar las referencias que incluían dichas variables.</span><span class="sxs-lookup"><span data-stu-id="bc637-185">To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held.</span></span> <span data-ttu-id="bc637-186">Si la variable almacenaba la última referencia al objeto, los recursos del objeto se liberaban inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="bc637-186">If the variable held the last reference to the object, the object's resources were released immediately.</span></span> <span data-ttu-id="bc637-187">En versiones posteriores de Visual Basic, aunque puede haber casos en los que este procedimiento todavía sea útil, su uso nunca hace que el objeto de referencia libere sus recursos inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="bc637-187">In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</span></span> <span data-ttu-id="bc637-188">Para liberar inmediatamente los recursos, utilice el método <xref:System.IDisposable.Dispose%2A> del objeto, si está disponible.</span><span class="sxs-lookup"><span data-stu-id="bc637-188">To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available.</span></span> <span data-ttu-id="bc637-189">El único caso en el que una variable debe establecerse en `Nothing` es cuando su duración sea larga en comparación con el tiempo que tarda el recolector de elementos no utilizados en detectar objetos huérfanos.</span><span class="sxs-lookup"><span data-stu-id="bc637-189">The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="bc637-190">Vea también</span><span class="sxs-lookup"><span data-stu-id="bc637-190">See also</span></span>

- <xref:System.IDisposable.Dispose%2A>
- <span data-ttu-id="bc637-191">[Inicialización y finalización de componentes](/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="bc637-191">[Initialization and Termination of Components](/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span></span>
- [<span data-ttu-id="bc637-192">New (operador)</span><span class="sxs-lookup"><span data-stu-id="bc637-192">New Operator</span></span>](../../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="bc637-193">Limpieza de recursos no administrados</span><span class="sxs-lookup"><span data-stu-id="bc637-193">Cleaning Up Unmanaged Resources</span></span>](../../../../standard/garbage-collection/unmanaged.md)
- [<span data-ttu-id="bc637-194">Nothing</span><span class="sxs-lookup"><span data-stu-id="bc637-194">Nothing</span></span>](../../../language-reference/nothing.md)
