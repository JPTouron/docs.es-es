---
title: Migración de aplicaciones WPF a .NET Core 3.0
description: Obtenga información sobre cómo migrar una aplicación para Windows Presentation Foundation (WPF) a .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: fda4f618ddb4a3edbe6f2dd9fba0b10bc618e88d
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 05/29/2020
ms.locfileid: "84201557"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="d2cc0-103">Migración de aplicaciones WPF a .NET Core</span><span class="sxs-lookup"><span data-stu-id="d2cc0-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="d2cc0-104">En este artículo se describen los pasos necesarios para migrar una aplicación para Windows Presentation Foundation (WPF) de .NET Framework a .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="d2cc0-105">Si no tiene una aplicación WPF disponible para migrarla, pero quiere probar el proceso, puede usar la aplicación de ejemplo **Bean Trader** disponible en [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="d2cc0-106">La aplicación original (que tiene como destino .NET Framework 4.7.2) está disponible en la carpeta NetFx\BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="d2cc0-107">En primer lugar, se explicarán los pasos necesarios para migrar aplicaciones en general y, después, se analizarán los cambios específicos que se aplican al ejemplo **Bean Trader**.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="d2cc0-108">Para migrar a .NET Core, primero tendrá que:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="d2cc0-109">Comprender y actualizar las dependencias de NuGet:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="d2cc0-110">Actualice las dependencias de NuGet al formato `<PackageReference>`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="d2cc0-111">Revise las dependencias de NuGet de nivel superior para la compatibilidad con .NET Core o .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="d2cc0-112">Actualice los paquetes NuGet a las versiones más recientes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="d2cc0-113">Use el [Analizador de portabilidad de .NET](../../standard/analyzers/portability-analyzer.md) para comprender las dependencias de .NET.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="d2cc0-114">Migrar el archivo del proyecto al nuevo formato de estilo de SDK:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="d2cc0-115">Elija como destino .NET Core y .NET Framework, o bien solo .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="d2cc0-116">Copie las propiedades y elementos pertinentes del archivo del proyecto en el nuevo archivo del proyecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="d2cc0-117">Corregir problemas de compilación:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-117">Fix build issues:</span></span>

    01. <span data-ttu-id="d2cc0-118">Agregue una referencia al paquete [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="d2cc0-119">Busque y corrija las diferencias de nivel de API.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="d2cc0-120">Quite las secciones de *app.config* que no sean `appSettings` o `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="d2cc0-121">Vuelva a generar el código generado, si es necesario.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="d2cc0-122">Pruebas en tiempo de ejecución:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-122">Runtime testing:</span></span>

    01. <span data-ttu-id="d2cc0-123">Confirme que la aplicación que ha migrado funciona según lo previsto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="d2cc0-124">Tenga cuidado con las excepciones <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="d2cc0-125">Sobre el ejemplo</span><span class="sxs-lookup"><span data-stu-id="d2cc0-125">About the sample</span></span>

<span data-ttu-id="d2cc0-126">En este artículo se hace referencia a la [aplicación de ejemplo Bean Trader](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) porque usa una serie de dependencias similares a las que pueden tener las aplicaciones WPF del mundo real.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="d2cc0-127">La aplicación no es grande, pero está pensada como un paso adicional a "Hola mundo" en términos de complejidad.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="d2cc0-128">La aplicación muestra algunos problemas que los usuarios pueden encontrar al migrar aplicaciones reales.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="d2cc0-129">Se comunica con un servicio WCF, de modo que para que se ejecute correctamente, también tendrá que ejecutar el proyecto BeanTraderServer (disponible en el mismo repositorio de GitHub) y asegurarse de que la configuración de BeanTraderClient señala al punto de conexión correcto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="d2cc0-130">(De forma predeterminada, en el ejemplo se supone que el servidor se ejecuta en el mismo equipo en `http://localhost:8090`, si inicia BeanTraderServer de manera local).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="d2cc0-131">Tenga en cuenta que esta aplicación de ejemplo está pensada para mostrar las soluciones y los desafíos de portabilidad de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="d2cc0-132">No está diseñada para mostrar los procedimientos recomendados de WPF.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="d2cc0-133">De hecho, incluye deliberadamente algunos antipatrones para asegurarse de que al menos vea un par de retos interesantes durante la migración.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="d2cc0-134">Preparación</span><span class="sxs-lookup"><span data-stu-id="d2cc0-134">Getting ready</span></span>

<span data-ttu-id="d2cc0-135">El principal desafío de migrar una aplicación .NET Framework a .NET Core es que sus dependencias pueden funcionar de forma diferente o no hacerlo en absoluto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="d2cc0-136">La migración es mucho más fácil de lo que solía ser; ahora muchos paquetes NuGet tienen como destino .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="d2cc0-137">A partir de .NET Core 2.0, las áreas expuestas de .NET Framework y .NET Core se han vuelto similares.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="d2cc0-138">Aun así, sigue habiendo algunas diferencias (tanto en la compatibilidad de los paquetes NuGet como en las API de .NET disponibles).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="d2cc0-139">El primer paso en la migración consiste en revisar las dependencias de la aplicación y asegurarse de que las referencias se encuentran en un formato que se pueda migrar con facilidad a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="d2cc0-140">Actualización a las referencias `<PackageReference>` de NuGet</span><span class="sxs-lookup"><span data-stu-id="d2cc0-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="d2cc0-141">Los proyectos de .NET Framework más antiguos suelen mostrar sus dependencias de NuGet en un archivo *packages.config*.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="d2cc0-142">El nuevo formato de archivo del proyecto con estilo de SDK hace referencia a los paquetes NuGet como elementos [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) en el propio archivo csproj en lugar de hacerlo en un archivo de configuración independiente.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="d2cc0-143">Al realizar la migración, el uso de referencias de estilo `<PackageReference>`ofrece dos ventajas:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="d2cc0-144">Este es el estilo de referencia de NuGet que se requiere para el nuevo archivo del proyecto de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="d2cc0-145">Si ya usa `<PackageReference>`, esos elementos de archivo del proyecto se pueden copiar y pegar directamente en el proyecto nuevo.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="d2cc0-146">A diferencia de un archivo packages.config, los elementos `<PackageReference>` solo hacen referencia a las dependencias de nivel superior de las que depende directamente el proyecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="d2cc0-147">Todos los demás paquetes NuGet transitivos se determinarán en tiempo de restauración y se registrarán en el archivo obj\project.assets.json generado de forma automática.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="d2cc0-148">Esto hace que sea mucho más fácil determinar qué dependencias tiene el proyecto, lo que resulta útil a la hora de determinar si las dependencias necesarias funcionarán en .NET Core o no.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="d2cc0-149">El primer paso para migrar una aplicación de .NET Framework a .NET Core consiste en actualizarla para que use referencias `<PackageReference>` de NuGet.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="d2cc0-150">Visual Studio facilita este proceso.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="d2cc0-151">Simplemente haga clic con el botón derecho en el archivo *packages.config* del proyecto en el **Explorador de soluciones** de Visual Studio y, después, seleccione **Migrar packages.config a PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Actualización a PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="d2cc0-153">Aparece un cuadro de diálogo en el que se muestran las dependencias de NuGet de nivel superior calculadas y en el que se pregunta por otros paquetes NuGet que se deban promover al nivel superior.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="d2cc0-154">Ninguno de estos paquetes adicionales debe ser de nivel superior para el ejemplo Bean Trader, por lo que puede desactivar todas esas casillas.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="d2cc0-155">Después, haga clic en **Aceptar**; se quitará el archivo *packages.config* y se agregarán elementos `<PackageReference>` al archivo del proyecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="d2cc0-156">Las referencias de estilo `<PackageReference>` no almacenan los paquetes NuGet localmente en una carpeta de paquetes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="d2cc0-157">En su lugar, se almacenan de forma global como una optimización.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="d2cc0-158">Una vez que ha finalizado la migración, edite el archivo csproj y quite los elementos `<Analyzer>` que hacen referencia a los analizadores que anteriormente procedían del directorio *..\packages*.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="d2cc0-159">No se preocupe; como todavía tiene las referencias del paquete NuGet, los analizadores se incluirán en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="d2cc0-160">Solo tiene que limpiar los elementos `<Analyzer>` de estilo packages.config antiguos.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="d2cc0-161">Revisión de los paquetes NuGet</span><span class="sxs-lookup"><span data-stu-id="d2cc0-161">Review NuGet packages</span></span>

<span data-ttu-id="d2cc0-162">Ahora que puede ver los paquetes NuGet de nivel superior de los que depende el proyecto, puede revisar si están disponibles en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="d2cc0-163">Puede determinar si un paquete es compatible con .NET Core si examina sus dependencias en [nuget.org](https://www.nuget.org/). En el sitio [fuget.org](https://www.fuget.org/) creado por la comunidad se muestra esta información de forma destacada en la parte superior de la página de información del paquete.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="d2cc0-164">Cuando el destino es .NET Core 3.0, los paquetes que tienen como destino .NET Core o .NET Standard deberían funcionar (ya que .NET Core implementa el área expuesta .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="d2cc0-165">En algunos casos, la versión específica de un paquete que se usa no tiene como destino .NET Core o .NET Standard, pero sí las versiones más recientes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="d2cc0-166">En este caso, debería considerar la posibilidad de actualizar a la versión más reciente del paquete.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="d2cc0-167">También puede usar paquetes que tengan como destino .NET Framework, aunque esto supone cierto riesgo.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="d2cc0-168">Se permiten las dependencias de .NET Core a .NET Framework porque las áreas expuestas de .NET Core y .NET Framework son lo suficientemente similares para que esas dependencias *suelan* funcionar.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="d2cc0-169">Pero si el paquete intenta usar una API de .NET que no está presente en .NET Core, se producirá una excepción en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="d2cc0-170">Por eso, solo debe hacer referencia a los paquetes de .NET Framework cuando no haya otras opciones disponibles y asumir que esto impone una carga de prueba.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="d2cc0-171">Si hay paquetes a los que se hace referencia y que no tienen como destino .NET Core o .NET Standard, tendrá que pensar en otras alternativas:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="d2cc0-172">¿Hay otros paquetes similares que se puedan usar en su lugar?</span><span class="sxs-lookup"><span data-stu-id="d2cc0-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="d2cc0-173">En ocasiones, los autores de NuGet publican versiones ".Core" independientes de sus bibliotecas, destinadas en concreto a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="d2cc0-174">Los paquetes de Enterprise Library son un ejemplo de la publicación de alternativas ".NetCore" en la comunidad.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="d2cc0-175">En otros casos, hay SDK más recientes para un servicio determinado (a veces con otros nombres de paquete) disponibles para .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="d2cc0-176">Si no hay ninguna alternativa disponible, puede seguir usando los paquetes destinados a .NET Framework, pero tenga en cuenta que tendrá que probarlos exhaustivamente una vez que se ejecuten en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="d2cc0-177">El ejemplo Bean Trader tiene las siguientes dependencias de NuGet de nivel superior:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="d2cc0-178">**Castle.Windsor, versión 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="d2cc0-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="d2cc0-179">Este paquete tiene como destino .NET Standard 1.6, por lo que funciona en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="d2cc0-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, versión 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="d2cc0-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="d2cc0-181">Se trata de un metapaquete, por lo que no es evidente de inmediato qué plataformas admite, pero en la [documentación](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) se indica que su versión más reciente (2.9.2) funcionará para .NET Framework y .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="d2cc0-182">**Nito.AsyncEx, versión 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="d2cc0-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="d2cc0-183">Este paquete no tiene como destino .NET Core, pero la versión más reciente 5.0 sí lo hace.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="d2cc0-184">Esto es habitual cuando se realiza la migración, ya que a muchos paquetes NuGet se les ha agregado recientemente compatibilidad con .NET Standard, pero las versiones de proyecto anteriores solo tendrán como destino .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="d2cc0-185">Si la diferencia de versión es solo de versión secundaria, a menudo es fácil actualizar a la versión más reciente.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="d2cc0-186">Como este es un cambio de versión principal, tendrá que realizar la actualización con precaución, ya que podría haber cambios importantes en el paquete.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="d2cc0-187">Pero el futuro parece prometedor.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="d2cc0-188">**MahApps.Metro, versión 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="d2cc0-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="d2cc0-189">Este paquete tampoco tiene como destino .NET Core, pero una versión preliminar más reciente (2.0-alpha) sí lo hace.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="d2cc0-190">De nuevo, debe tener en cuenta los cambios importantes, pero el paquete más reciente es alentador.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="d2cc0-191">Todas las dependencias de NuGet del ejemplo Bean Trader tienen como destino .NET Standard o .NET Core, o bien versiones más recientes que sí lo hacen, por lo que no es probable que haya problemas de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="d2cc0-192">Actualización de paquetes NuGet</span><span class="sxs-lookup"><span data-stu-id="d2cc0-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="d2cc0-193">Si es posible, en este momento sería conveniente actualizar las versiones de todos los paquetes que solo tienen como destino .NET Core o .NET Standard con versiones más recientes (con el proyecto todavía destinado a .NET Framework) para detectar y resolver los cambios más importantes al principio.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="d2cc0-194">Si prefiere no realizar cambios sustanciales en la versión de .NET Framework existente de la aplicación, puede esperar hasta que tenga un nuevo archivo del proyecto destinado a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="d2cc0-195">Pero la actualización de los paquetes NuGet a versiones compatibles con .NET Core con anterioridad hace que el proceso de migración sea aún más fácil una vez que se crea el archivo del proyecto y se reduce el número de diferencias entre las versiones para .NET Framework y .NET Core de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="d2cc0-196">Con el ejemplo Bean Trader, todas las actualizaciones necesarias se pueden realizar fácilmente (con el administrador de paquetes NuGet de Visual Studio) con una excepción: la actualización desde **MahApps.Metro 1.6.5** a **2.0** revela cambios importantes relacionados con las API de administración de temas y de acentos.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="d2cc0-197">Idealmente, la aplicación se actualizaría para usar la versión más reciente del paquete (ya que es más probable que funcione en .NET Core).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="d2cc0-198">Pero en algunos casos, puede que no sea factible.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="d2cc0-199">En estos casos, no actualice **MahApps.Metro** porque los cambios necesarios son significativos y este tutorial se centra en la migración a .NET Core 3, no a **MahApps.Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="d2cc0-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="d2cc0-200">Además, se trata de una dependencia de .NET Framework de bajo riesgo porque la aplicación Bean Trader solo ejerce una pequeña parte de **MahApps.Metro**.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="d2cc0-201">Por supuesto, será necesario realizar pruebas para asegurarse de que todo funciona una vez que haya finalizado la migración.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="d2cc0-202">Si se tratase de un escenario real, sería conveniente registrar una incidencia para realizar el seguimiento del trabajo para cambiar a **MahApps.Metro** versión 2.0, ya que si ahora no se realiza la migración, se mantiene cierta deuda técnica.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="d2cc0-203">Una vez que los paquetes NuGet se actualizan a las versiones recientes, el grupo de elementos `<PackageReference>` del archivo del proyecto del ejemplo Bean Trader debe tener este aspecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="d2cc0-204">Análisis de portabilidad de .NET Framework</span><span class="sxs-lookup"><span data-stu-id="d2cc0-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="d2cc0-205">Una vez que comprenda el estado de las dependencias de NuGet del proyecto, lo siguiente que debe tener en cuenta son las dependencias de API de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="d2cc0-206">La herramienta [Analizador de portabilidad de .NET](../../standard/analyzers/portability-analyzer.md) es útil para entender cuál de las API de .NET que se usan el proyecto están disponibles en otras plataformas de .NET.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="d2cc0-207">La herramienta se ofrece como [complemento de Visual Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), como [herramienta de línea de comandos](https://github.com/Microsoft/dotnet-apiport/releases), o bien se encapsula en una [GUI sencilla](https://github.com/Microsoft/dotnet-apiport-ui), donde se simplifican sus opciones.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="d2cc0-208">Puede leer más sobre el uso del Analizador de portabilidad de .NET (API Port) mediante la interfaz gráfica de usuario en la entrada de blog [Portabilidad de aplicaciones de escritorio a .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="d2cc0-209">Si prefiere usar la línea de comandos, los pasos necesarios son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="d2cc0-210">Descargue el [Analizador de portabilidad de .NET](https://github.com/Microsoft/dotnet-apiport/releases) si todavía no lo tiene.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="d2cc0-211">Asegúrese de que la aplicación de .NET Framework que se va a migrar se compila correctamente (en cualquier caso, es recomendable hacerlo antes de la migración).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="d2cc0-212">Ejecute API Port con una línea de comandos como esta.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="d2cc0-213">El argumento `-f` especifica la ruta de acceso que contiene los archivos binarios que se van a analizar.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="d2cc0-214">El argumento `-r` especifica el formato del archivo de salida deseado.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="d2cc0-215">El argumento `-t` especifica en qué plataforma .NET se va a analizar el uso de la API.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="d2cc0-216">En este caso, le interesa .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="d2cc0-217">Al abrir el informe HTML, en la primera sección se enumeran todos los archivos binarios analizados y qué porcentaje de las API de .NET que usan están disponibles en la plataforma de destino.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="d2cc0-218">El porcentaje por sí solo no es significativo.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="d2cc0-219">Lo más útil es ver las API específicas que faltan.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="d2cc0-220">Para ello, seleccione un nombre de ensamblado o desplácese hacia abajo hasta los informes de ensamblados individuales.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="d2cc0-221">Céntrese en los ensamblados para los que tiene el código fuente.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="d2cc0-222">Por ejemplo, en el informe Bean Trader ApiPort, se muestran muchos archivos binarios, pero la mayoría de ellos pertenecen a paquetes NuGet.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="d2cc0-223">`Castle.Windsor` muestra que depende de algunas API de System.Web que faltan en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="d2cc0-224">Esto no es un problema porque antes se ha comprobado que `Castle.Windsor` es compatible con .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="d2cc0-225">Es habitual que los paquetes NuGet tengan distintos archivos binarios para usarlos con distintas plataformas de .NET, por lo que si la versión de .NET Framework de `Castle.Windsor` usa las API de System.Web o no es irrelevante, siempre que el paquete también tenga como destino .NET Standard o .NET Core (que sí lo hace).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="d2cc0-226">Con el ejemplo Bean Trader, el único binario que debe tener en cuenta es **BeanTraderClient** y el informe muestra que solo faltan dos API de .NET: `System.ServiceModel.ClientBase<T>.Close` y `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Informe de portabilidad de BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="d2cc0-228">No es probable que sean problemas de bloqueo porque las API de cliente WCF se admiten en .NET Core (en su mayoría), por lo que debe haber alternativas disponibles para estas API centrales.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="d2cc0-229">De hecho, al examinar el área expuesta de .NET Core de `System.ServiceModel` (con <https://apisof.net>), verá que en su lugar hay alternativas asincrónicas en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="d2cc0-230">Según este informe y el análisis de dependencias de NuGet anterior, parece que no debería haber ningún problema importante al migrar el ejemplo Bean Trader a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="d2cc0-231">Está listo para el siguiente paso en el que iniciará realmente la migración.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="d2cc0-232">Migración del archivo del proyecto</span><span class="sxs-lookup"><span data-stu-id="d2cc0-232">Migrating the project file</span></span>

<span data-ttu-id="d2cc0-233">Si la aplicación no usa el nuevo [formato de archivo del proyecto de estilo SDK](../../core/tools/csproj.md), necesitará un nuevo archivo del proyecto con .NET Core como destino.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="d2cc0-234">Puede reemplazar el archivo csproj existente o, si prefiere mantener el proyecto existente en su estado actual sin modificarlo, puede agregar un nuevo archivo csproj destinado a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="d2cc0-235">Puede compilar versiones de la aplicación para .NET Framework y .NET Core con un solo archivo del proyecto de estilo SDK con [compatibilidad con múltiples versiones](../../standard/library-guidance/cross-platform-targeting.md) (si especifica varios destinos `<TargetFrameworks>`).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="d2cc0-236">Para crear el archivo del proyecto, puede crear un proyecto de WPF en Visual Studio o usar el comando `dotnet new wpf` en un directorio temporal para generar el archivo del proyecto y, después, copiarlo o cambiarle el nombre a la ubicación correcta.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="d2cc0-237">También hay una herramienta creada por la comunidad, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), que puede automatizar parte de la migración del archivo del proyecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="d2cc0-238">La herramienta es útil pero todavía se necesita un humano para revisar los resultados con el fin de asegurarse de que todos los detalles de la migración son correctos.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="d2cc0-239">Un área concreta que la herramienta no controla de forma óptima es la migración de paquetes NuGet desde archivos *packages.config*.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="d2cc0-240">Si la herramienta se ejecuta en un archivo del proyecto en el que todavía se usa un archivo *packages.config* para hacer referencia a los paquetes NuGet, se migrará automáticamente a elementos `<PackageReference>`, pero agregará elementos `<PackageReference>` para *todos* los paquetes en lugar de solo los de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="d2cc0-241">Si ya ha migrado a elementos `<PackageReference>` con Visual Studio (como en este ejemplo), la herramienta puede ayudarle con el resto de la conversión.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="d2cc0-242">Como Scott Hanselman recomienda en [su entrada de blog sobre la migración de archivos csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), la migración manual es educativa y dará mejores resultados si solo tiene unos pocos proyectos para migrar.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="d2cc0-243">Pero si va a migrar docenas o cientos de archivos de proyecto, una herramienta como [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) puede ser de utilidad.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="d2cc0-244">Para crear un archivo del proyecto para el ejemplo Bean Trader, ejecute `dotnet new wpf` en un directorio temporal, mueva el archivo *.csproj* generado a la carpeta *BeanTraderClient* y cambie el nombre a **BeanTraderClient.Core.csproj**.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="d2cc0-245">Como el nuevo formato de archivo del proyecto incluye automáticamente archivos de C#, archivos *resx* y archivos XAML que encuentra en el directorio, el archivo del proyecto ya está casi completo.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="d2cc0-246">Para finalizar la migración, abra los archivos del proyecto antiguos y nuevos en paralelo, y examine el antiguo para ver si es necesario migrar la información que contiene.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="d2cc0-247">En el caso del ejemplo Bean Trader, se deben copiar los elementos siguientes en el nuevo proyecto:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="d2cc0-248">Se deben copiar las propiedades `<RootNamespace>`, `<AssemblyName>` y `<ApplicationIcon>`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="d2cc0-249">También debe agregar una propiedad `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` al nuevo archivo del proyecto, ya que el ejemplo Bean Trader incluye atributos de nivel de ensamblado (como `[AssemblyTitle]`) en un archivo AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="d2cc0-250">De forma predeterminada, los nuevos proyectos de estilo SDK generarán automáticamente estos atributos en función de las propiedades del archivo csproj.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="d2cc0-251">Como en este caso no quiere que suceda (los atributos generados automáticamente entrarían en conflicto con los de AssemblyInfo.cs), deshabilite los atributos generados automáticamente con `<GenerateAssemblyInfo>`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="d2cc0-252">Aunque los archivos *resx* se incluyen de forma automática como recursos incrustados, no se incluyen otros elementos `<Resource>` como las imágenes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="d2cc0-253">Por tanto, copie los elementos `<Resource>` para insertar archivos de imagen e icono.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="d2cc0-254">Puede simplificar las referencias png a una sola línea mediante la compatibilidad del nuevo formato de archivo del proyecto con los patrones globales: `<Resource Include="**\*.png" />`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="d2cc0-255">De forma similar, los elementos `<None>` se incluyen automáticamente, pero no se copian en el directorio de salida de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="d2cc0-256">Como el proyecto Bean Trader incluye un elemento `<None>` que *se* copia en el directorio de salida (mediante comportamientos `PreserveNewest`), tendrá que actualizar el elemento `<None>` rellenado de forma automática para ese archivo, como se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="d2cc0-257">El ejemplo Bean Trader incluye un archivo XAML (Default.Accent.xaml) como `Content` (en lugar de como objeto `Page`) porque los temas y los acentos definidos en este archivo se cargan desde el código XAML del archivo en tiempo de ejecución, en lugar de insertarse en la propia aplicación.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="d2cc0-258">Pero el nuevo sistema del proyecto incluye automáticamente este archivo como `<Page>`, ya que es un archivo XAML.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="d2cc0-259">Por tanto, debe quitar el archivo XAML como una página (`<Page Remove="**\Default.Accent.xaml" />`) y agregarlo como contenido.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="d2cc0-260">Por último, para agregar las referencias de NuGet, copie `<ItemGroup>` con todos los elementos `<PackageReference>`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="d2cc0-261">Si no ha actualizado previamente los paquetes NuGet a las versiones compatibles con .NET Core, puede hacerlo ahora que las referencias del paquete se encuentran en un proyecto específico de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="d2cc0-262">En este punto, debería ser posible agregar el nuevo proyecto a la solución BeanTrader y abrirlo en Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="d2cc0-263">El proyecto debe tener un aspecto correcto en el **Explorador de soluciones** y `dotnet restore BeanTraderClient.Core.csproj` debe restaurar correctamente los paquetes (con dos advertencias previstas relacionadas con la versión MahApps.Metro que se usa destinada a .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="d2cc0-264">Aunque es posible mantener los dos archivos del proyecto en paralelo (e incluso deseable si quiere seguir compilando el proyecto anterior exactamente como era), complica el proceso de migración (los dos proyectos intentarán usar las mismas carpetas bin y obj), y normalmente no es necesario.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="d2cc0-265">Si quiere compilar para los destinos .NET Core y .NET Framework, puede reemplazar la propiedad `<TargetFramework>netcoreapp3.0</TargetFramework>` del nuevo archivo del proyecto por `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="d2cc0-266">En el ejemplo Bean Trader, elimine el archivo del proyecto antiguo (BeanTraderClient.csproj), ya que ya no es necesario.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="d2cc0-267">Si prefiere conservar ambos archivos del proyecto, asegúrese de que se compilan en diferentes rutas de acceso de salida e intermedias.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="d2cc0-268">Solución de problemas de compilación</span><span class="sxs-lookup"><span data-stu-id="d2cc0-268">Fix build issues</span></span>

<span data-ttu-id="d2cc0-269">El tercer paso del proceso de portabilidad es la compilación del proyecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="d2cc0-270">Algunas aplicaciones se compilarán correctamente una vez que el archivo de proyecto se convierta en un proyecto de estilo SDK.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="d2cc0-271">Si ese es el caso de la aplicación, enhorabuena.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="d2cc0-272">Puede continuar con el paso 4.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-272">You can go on to Step 4.</span></span> <span data-ttu-id="d2cc0-273">Otras aplicaciones necesitarán algunas actualizaciones para que se compilen para .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="d2cc0-274">Si ahora intenta ejecutar `dotnet build` en el proyecto Bean Trader, por ejemplo, (o compilarlo en Visual Studio), habrá muchos errores, pero conseguirá solucionarlos rápidamente.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="d2cc0-275">Referencias a System.ServiceModel y Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="d2cc0-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="d2cc0-276">Una fuente común de errores es que faltan referencias para API que están disponibles para .NET Core, pero que no se incluyen de forma automática en el metapaquete de la aplicación .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="d2cc0-277">Para solucionarlo, debe hacer referencia al paquete `Microsoft.Windows.Compatibility`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="d2cc0-278">El paquete de compatibilidad incluye un amplio conjunto de API comunes en las aplicaciones de escritorio de Windows, como el cliente WCF, los servicios de directorio, el registro, la configuración, las API de ACL, etc.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="d2cc0-279">Con el ejemplo Bean Trader, la mayoría de los errores de compilación se deben a que faltan tipos de <xref:System.ServiceModel>.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="d2cc0-280">Para solucionarlos, se hace referencia a los paquetes NuGet de WCF necesarios.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="d2cc0-281">Pero las API de cliente WCF son algunas de las que se incluyen en el paquete `Microsoft.Windows.Compatibility`, por lo que hacer referencia al paquete de compatibilidad es una solución todavía mejor (ya que también se soluciona cualquier problema relacionado con las API, así como soluciones para los problemas de WCF que el paquete de compatibilidad pone a disposición).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="d2cc0-282">El paquete `Microsoft.Windows.Compatibility` es útil en la mayoría de los escenarios de migración de WPF y WinForms a .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="d2cc0-283">Después de agregar la referencia de NuGet a `Microsoft.Windows.Compatibility`, solo queda un error de compilación.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="d2cc0-284">Limpieza de los archivos sin usar</span><span class="sxs-lookup"><span data-stu-id="d2cc0-284">Cleaning up unused files</span></span>

<span data-ttu-id="d2cc0-285">Un tipo de problema de migración que surge con frecuencia está relacionado con los archivos de C# y XAML que antes no se incluían en la compilación y que ahora toman los nuevos proyectos de estilo de SDK que incluyen *todo* el origen de forma automática.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="d2cc0-286">El siguiente error de compilación que se ve en el ejemplo de Bean Trader hace referencia a una implementación de interfaz incorrecta en *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="d2cc0-287">El nombre de archivo es una sugerencia, pero, tras inspeccionarlo, observará que este archivo de código fuente es incorrecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="d2cc0-288">No causaba problemas anteriormente porque no se incluía en el proyecto de .NET Framework original.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="d2cc0-289">Los archivos de origen que estaban presentes en el disco pero que no se incluían en el archivo *csproj* anterior ahora se incluyen de forma automática.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="d2cc0-290">Para los problemas únicos como este, es fácil comparar con el archivo *csproj* anterior para confirmar que el archivo no es necesario y, después, aplicarle `<Compile Remove="" />` o, si el archivo de origen ya no es necesario, eliminarlo.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="d2cc0-291">En este caso, se puede eliminar *OldUnusedViewModel.cs* sin problema.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="d2cc0-292">Si tiene muchos archivos de código fuente que se deban excluir de esta forma, puede deshabilitar la inclusión automática de archivos de C# si establece la propiedad `<EnableDefaultCompileItems>` en false en el archivo del proyecto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="d2cc0-293">Después, puede copiar los elementos `<Compile Include>` desde el archivo del proyecto anterior al nuevo para crear solo los orígenes de compilación que quiera incluir.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="d2cc0-294">De forma similar, se puede usar `<EnableDefaultPageItems>` para desactivar la inclusión automática de páginas XAML y `<EnableDefaultItems>` puede controlar ambos con una sola propiedad.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="d2cc0-295">Ahora se ofrecerá un breve apunte adicional sobre los compiladores de pases múltiples</span><span class="sxs-lookup"><span data-stu-id="d2cc0-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="d2cc0-296">Después de quitar el archivo erróneo del ejemplo Bean Trader, puede volver a compilar y obtendrá cuatro errores.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="d2cc0-297">¿No había solo uno antes?</span><span class="sxs-lookup"><span data-stu-id="d2cc0-297">Didn't you have one before?</span></span> <span data-ttu-id="d2cc0-298">¿Por qué ha aumentado el número de errores?</span><span class="sxs-lookup"><span data-stu-id="d2cc0-298">Why did the number of errors go up?</span></span> <span data-ttu-id="d2cc0-299">El compilador de C# es un [compilador de varios pasos](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="d2cc0-300">Esto significa que recorre dos veces cada archivo de código fuente.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="d2cc0-301">En primer lugar, el compilador solo examina los metadatos y las declaraciones de cada archivo de código fuente e identifica los problemas de nivel de declaración.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="d2cc0-302">Esos son los errores que se han corregido.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="d2cc0-303">Después, vuelve a pasar por el código para compilar el código fuente de C# en lenguaje intermedio; son el segundo conjunto de errores que se ven ahora.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="d2cc0-304">El compilador de C# realiza [más de dos pasos](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), pero el resultado final es que los errores del compilador para cambios de código grandes como este tienden a aparecer en dos oleadas.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="d2cc0-305">Correcciones de dependencia de terceros (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="d2cc0-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="d2cc0-306">Otra clase de problema que surge en algunos escenarios de migración son las diferencias de API entre las versiones para .NET Framework y .NET Core de las dependencias.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="d2cc0-307">Incluso si un paquete NuGet tiene como destino .NET Framework y .NET Standard o .NET Core, puede haber distintas bibliotecas para usarlas con diferentes destinos .NET.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="d2cc0-308">Esto permite que los paquetes admitan muchas plataformas .NET diferentes, que pueden requerir otras implementaciones.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="d2cc0-309">También significa que puede haber pequeñas diferencias de API en las bibliotecas cuando se seleccionan como destino distintas plataformas .NET.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="d2cc0-310">El siguiente conjunto de errores que verá en el ejemplo Bean Trader se relaciona con las API de `Castle.Windsor`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="d2cc0-311">El proyecto Bean Trader de .NET Core usa la misma versión de `Castle.Windsor` que el proyecto destinado a .NET Framework (4.1.1), pero las implementaciones para esas dos plataformas son ligeramente diferentes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="d2cc0-312">En este caso, verá los siguientes problemas que deben corregirse:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="d2cc0-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` no está disponible en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="d2cc0-314">Pero hay una API `Classes.FromAssemblyContaining` similar disponible, por lo que se pueden reemplazar los dos usos de `Classes.FromThisAssembly()` con llamadas a `Classes.FromAssemblyContaining(t)`, donde `t` es el tipo que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="d2cc0-315">Del mismo modo, en *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`no está disponible en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="d2cc0-316">En su lugar, esta llamada se puede reemplazar por `FromAssembly.Containing(typeof(Bootstrapper))`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="d2cc0-317">Actualización del uso del cliente WCF</span><span class="sxs-lookup"><span data-stu-id="d2cc0-317">Updating WCF client usage</span></span>

<span data-ttu-id="d2cc0-318">Después de corregir las diferencias de `Castle.Windsor`, el último error de compilación en el proyecto Bean Trader de .NET Core es que `BeanTraderServiceClient` (que se deriva de `DuplexClientBase`) no tiene un método `Open`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="d2cc0-319">Esto no es sorprendente, ya que se trata de una API identificada por el Analizador de portabilidad de .NET al principio de este proceso de migración.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="d2cc0-320">Pero al examinar `BeanTraderServiceClient`, la atención se centra en un problema mayor.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="d2cc0-321">Este cliente WCF se ha generado de forma automática mediante la herramienta [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="d2cc0-322">**Los clientes WCF generados por Svcutil están pensados para usar en .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="d2cc0-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="d2cc0-323">Las soluciones que usan clientes WCF generados por Svcutil tendrán que volver a generar clientes compatibles con .NET Standard para su uso con .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="d2cc0-324">Uno de los motivos principales por los que los clientes antiguos no funcionarán es que dependen de la configuración de la aplicación para definir enlaces y puntos de conexión de WCF.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="d2cc0-325">Como las API de WCF de .NET Standard pueden funcionar entre plataformas (donde las API de System.Configuration no están disponibles), los clientes WCF para los escenarios de .NET Core y .NET Standard deben definir enlaces y puntos de conexión mediante programación en lugar de hacerlo en la configuración.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="d2cc0-326">De hecho, cualquier uso de cliente WCF que dependa de la sección `<system.serviceModel>` de app.config (se haya creado con Svcutil o de forma manual) tendrá que cambiarse para que funcione en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="d2cc0-327">Hay dos maneras de generar automáticamente clientes WCF compatibles con .NET Standard:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="d2cc0-328">La herramienta `dotnet-svcutil` de .NET genera clientes WCF de forma similar a como se ha ejecutado Svcutil antes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="d2cc0-329">Visual Studio puede generar clientes WCF mediante la opción [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) de su característica Servicios conectados.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="d2cc0-330">Los dos enfoques funcionan bien.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-330">Either approach works well.</span></span> <span data-ttu-id="d2cc0-331">Por supuesto, como alternativa puede escribir personalmente el código de cliente WCF.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="d2cc0-332">En este ejemplo, se ha optado por usar la característica Servicio conectado de Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="d2cc0-333">Para ello, haga clic con el botón derecho en el proyecto *BeanTraderClient.Core* en el explorador de soluciones de Visual Studio y seleccione **Agregar** > **Servicio conectado**.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="d2cc0-334">Después, seleccione el proveedor WCF Web Service Reference.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="d2cc0-335">Se abrirá un cuadro de diálogo en el que puede especificar la dirección del servicio web Bean Trader de back-end (`localhost:8080` si ejecuta el servidor localmente) y el espacio de nombres que deben usar los tipos generados (**BeanTrader.Service**, por ejemplo).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Cuadro de diálogo del Servicio conectado WCF Web Service Reference](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="d2cc0-337">Después de seleccionar el botón **Finalizar**, se agrega un nuevo nodo Servicios conectados al proyecto y un archivo Reference.cs en ese nodo que contiene el nuevo cliente WCF de .NET Standard para acceder al servicio Bean Trader.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="d2cc0-338">Si observa los métodos `GetEndpointAddress` o `GetBindingForEndpoint` de ese archivo, verá que los enlaces y puntos de conexión ahora se generan mediante programación (en lugar de mediante la configuración de la aplicación).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="d2cc0-339">La característica "Agregar servicios conectados" también puede agregar al archivo del proyecto referencias a algunos paquetes System.ServiceModel innecesarios, ya que todos los paquetes WCF necesarios se incluyen a través de Microsoft.Windows.Compatibility.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="d2cc0-340">Compruebe el archivo csproj para ver si se ha agregado algún elemento `<PackageReference>` de System.ServiceModel adicional y, si es así, quítelo.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="d2cc0-341">Ahora el proyecto tiene nuevas clases de cliente WCF (en *Reference.cs*), pero también las antiguas (en BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="d2cc0-342">En este momento, dispone de dos opciones:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-342">There are two options at this point:</span></span>

- <span data-ttu-id="d2cc0-343">Si quiere poder compilar el proyecto de .NET Framework original (junto con el nuevo destinado a .NET Core), puede usar un elemento `<Compile Remove="BeanTrader.cs" />` en el archivo csproj del proyecto de .NET Core para que las versiones de .NET Framework y .NET Core de la aplicación usen distintos clientes WCF.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="d2cc0-344">La ventaja de esto es que el proyecto de .NET Framework existente no cambia, pero la desventaja es que el código que usa los clientes WCF generados sea ligeramente diferente en .NET Core que en el proyecto de .NET Framework, por lo que probablemente tendrá que usar directivas `#if` para compilar de forma condicional algún uso de cliente WCF (por ejemplo, la creación de clientes) para que funcione de una manera cuando se compila para NET Core y de otra para .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="d2cc0-345">Por otro lado, si se acepta alguna renovación de código en el proyecto para .NET Framework existente, puede quitar *BeanTrader.cs* definitivamente.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="d2cc0-346">Como el nuevo cliente WCF se compila para .NET Standard, funcionará en los escenarios de .NET Core y .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="d2cc0-347">Si va a compilar para .NET Framework además de .NET Core (ya sea mediante la compatibilidad con múltiples versiones o con dos archivos csproj), puede usar este nuevo archivo *Reference.cs* para los dos destinos.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="d2cc0-348">Este enfoque tiene la ventaja de que no es necesario bifurcar el código para admitir dos clientes WCF diferentes: se usará el mismo en todas partes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="d2cc0-349">El inconveniente es que implica cambiar el proyecto de .NET Framework (supuestamente estable).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="d2cc0-350">En el caso del ejemplo Bean Trader, puede realizar pequeños cambios en el proyecto original si eso facilita la migración, por lo que debe seguir estos pasos para conciliar el uso del cliente WCF:</span><span class="sxs-lookup"><span data-stu-id="d2cc0-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="d2cc0-351">Agregue el nuevo archivo Reference.cs al proyecto *BeanTraderClient.csproj* de .NET Framework mediante el menú contextual "Agregar elemento existente" desde el Explorador de soluciones.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="d2cc0-352">Asegúrese de agregar "como vínculo" para que ambos proyectos usen el mismo archivo (en lugar de copiar el archivo de C#).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="d2cc0-353">Si va a compilar para .NET Core y .NET Framework con un solo archivo csproj (con compatibilidad con múltiples versiones), este paso no es necesario.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="d2cc0-354">Elimine *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="d2cc0-355">El nuevo cliente WCF es similar al anterior, pero varios espacios de nombres del código generado son distintos.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="d2cc0-356">Por este motivo, es necesario actualizar el proyecto para que los tipos de cliente WCF se usen desde BeanTrader.Service (o el espacio de nombres que haya elegido) en lugar de BeanTrader.Model o sin un espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="d2cc0-357">La compilación de *BeanTraderClient.Core.csproj* ayudará a identificar dónde se deben realizar estos cambios.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="d2cc0-358">Se necesitarán correcciones en C# y en los archivos de código fuente XAML.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="d2cc0-359">Por último, descubrirá que hay un error en *BeanTraderServiceClientFactory.cs* porque los constructores disponibles para el tipo `BeanTraderServiceClient` han cambiado.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="d2cc0-360">Solía ser posible proporcionar un argumento `InstanceContext` (creado con un elemento `CallbackHandler` del contenedor de IoC `Castle.Windsor`).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="d2cc0-361">Los nuevos constructores crean objetos `CallbackHandler`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="d2cc0-362">Pero hay constructores en el tipo base de `BeanTraderServiceClient` que coinciden con lo que quiere.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="d2cc0-363">Como todo el código de cliente WCF generado automáticamente existe en clases parciales, puede extenderlo con facilidad.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="d2cc0-364">Para ello, cree un archivo llamado *BeanTraderServiceClient.cs* y, después, una clase parcial con ese mismo nombre (mediante el espacio de nombres BeanTrader.Service).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="d2cc0-365">Luego, agregue un constructor al tipo parcial como se muestra aquí.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="d2cc0-366">Con esos cambios, en el ejemplo Bean Trader ahora se usará un nuevo cliente WCF compatible con .NET Standard y puede realizar la corrección final del cambio de la llamada a `Open` en *TradingService.cs* para usar `await OpenAsync` en su lugar.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="d2cc0-367">Después de solucionar los problemas de WCF, ahora la versión para .NET Core del ejemplo Bean Trader se compila correctamente.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="d2cc0-368">Pruebas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="d2cc0-368">Runtime testing</span></span>

<span data-ttu-id="d2cc0-369">Es fácil olvidarse de que el trabajo de migración no termina después de compilar ahora sin problemas en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="d2cc0-370">También es importante dejar tiempo para probar la aplicación que se ha migrado.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="d2cc0-371">Una vez que todo se haya compilado correctamente, asegúrese de que la aplicación se ejecuta y funciona según lo previsto, especialmente si usa algún paquete destinado a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="d2cc0-372">Ahora se intentará iniciar la aplicación Bean Trade que se ha migrado para ver lo que sucede.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="d2cc0-373">La aplicación no avanza demasiado antes de que se produzca un error con la siguiente excepción.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="d2cc0-374">Esto tiene sentido, por supuesto.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-374">This makes sense, of course.</span></span> <span data-ttu-id="d2cc0-375">Recuerde que WCF ya no usa la configuración de la aplicación, por lo que es necesario quitar la sección system.serviceModel antigua del archivo app.config.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="d2cc0-376">El cliente WCF actualizado incluye toda esta misma información en su código, por lo que la sección de configuración ya no es necesaria.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="d2cc0-377">Si quiere que el punto de conexión de WCF se pueda configurar en app.config, puede agregarlo como una configuración de aplicación y actualizar el código de cliente WCF para recuperar el punto de conexión de servicio de WCF de la configuración.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="d2cc0-378">Después de quitar la sección system.serviceModel de *app.config*, la aplicación se inicia pero se produce un error con otra excepción cuando un usuario inicia sesión.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="d2cc0-379">La versión de la API no admitida es `Func<T>.BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="d2cc0-380">Como se explica en [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core no admite los métodos `BeginInvoke` y `EndInvoke` en los tipos de delegado debido a las dependencias de comunicación remota subyacentes.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="d2cc0-381">Este problema y su corrección se explican con más detalle en la entrada de blog [Migración de llamadas a Delegate.BeginInvoke para .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) pero, para resumir, las llamadas a `BeginInvoke` y `EndInvoke` se deben reemplazar por `Task.Run` (o alternativas asincrónicas, si es posible).</span><span class="sxs-lookup"><span data-stu-id="d2cc0-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="d2cc0-382">Si en este caso se aplica la solución general, la llamada a `BeginInvoke` se puede reemplazar por una llamada a `Invoke` iniciada por `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="d2cc0-383">Después de quitar el uso de `BeginInvoke`, la aplicación Bean Trader se ejecuta correctamente en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Bean Trader en ejecución en .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="d2cc0-385">Todas las aplicaciones son diferentes, de modo que los pasos específicos necesarios para migrar aplicaciones propias a .NET Core variarán.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="d2cc0-386">Pero es de esperar que el ejemplo Bean Trader sirva para mostrar el flujo de trabajo general y los tipos de problemas previstos.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="d2cc0-387">Y, a pesar de la longitud de este artículo, los cambios reales necesarios en el ejemplo Bean Trader para hacer que funcione en .NET Core han sido bastante limitados.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="d2cc0-388">Muchas aplicaciones se migran a .NET Core de esta misma manera; con un número limitado de cambios en el código o incluso sin ellos.</span><span class="sxs-lookup"><span data-stu-id="d2cc0-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
